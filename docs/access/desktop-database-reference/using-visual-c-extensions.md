---
title: Использование расширений Visual C++
TOCTitle: Using Visual C++ Extensions
ms:assetid: 0fb1014c-7ab6-6add-d09f-e5e48b2b32cb
ms:mtpsurl: https://msdn.microsoft.com/library/JJ248866(v=office.15)
ms:contentKeyID: 48543270
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 8bf2234e5935c2a1a13871e7e45c980fb9f33109
ms.sourcegitcommit: d6695c94415fa47952ee7961a69660abc0904434
ms.translationtype: Auto
ms.contentlocale: ru-RU
ms.lasthandoff: 01/17/2019
ms.locfileid: "28713781"
---
# <a name="using-visual-c-extensions"></a>Использование расширений Visual C++


**Применимо к**: Access 2013, Office 2013

## <a name="the-iadorecordbinding-interface"></a>Интерфейс IADORecordBinding

Расширения Visual C++ Майкрософт для полей свяжите ADO или привязку объекта [набора записей](recordset-object-ado.md) переменным C/C++. При каждом изменении текущей строки связанных **записей** , привязанных полей в **записей** копируются переменные C/C++. При необходимости, скопированные данные преобразуется в тип данных объявленные переменной C/C++.

Метод **BindToRecordset** интерфейса **IADORecordBinding** привязывает поля переменным C/C++. Метод **AddNew** добавляет новую строку в привязанной **набора записей**. Метод **Update** заполняет поля в новые строки **набора записей**или обновления поля в строках со значением переменные C/C++.

Интерфейс **IADORecordBinding** реализуется объекта **набора записей** . Не кода реализации самостоятельно.

## <a name="binding-entries"></a>Привязка записей

Расширения Visual C++ для ADO сопоставление полей объекта [набора записей](recordset-object-ado.md) с переменным C/C++. Определения сопоставления между полем и переменной называется *записи привязки*. Макросы предоставляют записи привязки для числовых, фиксированной длины и переменной длины данных. Привязка записей и переменные C/C++ объявляются в класс, производный от класса расширения Visual C++ **CADORecordBinding**. Класс **CADORecordBinding** определяется во внутренней сети в привязке записи макросов.

ADO во внутренней сети сопоставляется структуру OLE DB **DBBINDING** параметров в этих макросов и создает объект OLE DB **доступа к данным** для управления перемещения и преобразования данных между полями и переменных. OLE DB определяет данные, состоящий из трех частей: *буфера* , где хранятся данные; *состояние* , указывает ли поле было успешно сохранены в буфере или как восстановлены переменная поля; и *длину* данных. ( *Справочник программиста OLE DB*, Глава 6: получение и установка данных для получения дополнительных сведений.)

## <a name="header-file"></a>Файл заголовка

Добавьте следующий файл в приложении для использования расширений Visual C++ для ADO:

```cpp 
 
#include <icrsint.h> 
```

## <a name="binding-recordset-fields"></a>Привязка полей набора записей

**Привязка полей набора записей переменным C/C++**

1.  Создайте класс, производный от класса **CADORecordBinding** .

2.  Укажите привязку записей и соответствующие переменные C/C++ в производного класса. Квадратная скобка записей привязки между **приступить к\_ADO\_ПРИВЯЗКИ** и **конечных\_ADO\_ПРИВЯЗКИ** макросы. Не прерывания макросов с помощью запятой или точкой с запятой. Каждый макрос автоматически задаются соответствующие разделители. Укажите одной записи привязки для каждого поля для сопоставления с переменной C/C++. Используйте соответствующий элемент из **ADO\_ФИКСИРОВАННАЯ\_длина\_запись**, **ADO\_ЧИСЛОВОЕ\_запись**, или **ADO\_ПЕРЕМЕННЫХ\_длина\_запись** семейства макросов.

3.  В приложении создайте экземпляр класса, производного от **CADORecordBinding**. Получите интерфейс **IADORecordBinding** из **набора записей**. Затем вызовите метод **BindToRecordset** для привязки полей **набора записей** переменные C/C++.

[Пример расширения Visual C++](visual-c-extensions-example.md) для получения дополнительных сведений см.

## <a name="interface-methods"></a>Методы интерфейса

Этот интерфейс **IADORecordBinding** содержит три метода: **BindToRecordset**, **AddNew**и **обновления**. Единственный аргумент для каждого метода — указатель на экземпляр класса, производного от **CADORecordBinding**. Таким образом методы **AddNew** и **обновление** нельзя указать параметры их namesakes метод ADO.

**Синтаксис**

Метод **BindToRecordset** связывает полей **набора записей** с помощью переменных C/C++.

`BindToRecordset(CADORecordBinding *binding)` 

Метод **AddNew** вызывает его namesake, метод ADO [AddNew](addnew-method-ado.md) , чтобы добавить новую строку **набора записей**.

`AddNew(CADORecordBinding *binding)` 

Метод **Update** вызывает его namesake, метод ADO [обновления](update-method-ado.md) для обновления **набора записей**.

`Update(CADORecordBinding *binding)` 

## <a name="binding-entry-macros"></a>Привязка записи макросов

Привязка записи макросов определение поля **набора записей** и переменной. Макрос начального и конечного отделяет набор привязки записей.

Семейства операционных систем макросов предоставляются для данных фиксированной длины, например **adDate** или **adBoolean**; числовые данные, такие как **adTinyInt**, **adInteger**или **adDouble**; и данные переменной длины, например **adChar**, **adVarChar** или **adVarBinary**. Все числовые типы, за исключением **adVarNumeric**, могут также типы фиксированной длины. Каждое семейство имеет различные наборы параметров, поэтому можно исключить сведения о привязке, не представляют интереса.

Типы данных приложение а: *Справочник программиста OLE DB* для получения дополнительных сведений см.

_**Приступить к привязке записей**_

**Приступить к\_ADO\_ПРИВЯЗКИ**(*класс*)

_**Данные фиксированной длины**_

**ADO\_ФИКСИРОВАННАЯ\_длина\_запись**(*порядковый номер, тип данных, буфера, состояние, изменение*)  
**ADO\_ФИКСИРОВАННАЯ\_длина\_ENTRY2**(*порядковый номер, тип данных, буфера, изменение*)

_**Числовые данные**_

**ADO\_ЧИСЛОВОЕ\_запись**(*порядковый номер, тип данных, буфера, точности, масштаба, состояние, изменение*)  
**ADO\_ЧИСЛОВОЕ\_ENTRY2**(*порядковый номер, тип данных, буфера, точность, масштаб, изменение*)

_**Данные переменной длины**_

**ADO\_ПЕРЕМЕННЫХ\_длина\_запись**(*порядковый номер, тип данных, буфер, размер, состояние, длину, изменение*)  
**ADO\_ПЕРЕМЕННЫХ\_длина\_ENTRY2**(*порядковый номер, тип данных, буфер, размер, состояние, изменение*)  
**ADO\_ПЕРЕМЕННЫХ\_длина\_ENTRY3**(*порядковый номер, тип данных, буфер, размер, длины, изменение*)  
**ADO\_ПЕРЕМЕННЫХ\_длина\_ENTRY4**(*порядковый номер, тип данных, буфер, размер, изменение*)

_**Привязка записи плана**_

**Конец\_ADO\_ПРИВЯЗКИ** ()

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Параметр</p></th>
<th><p>Описание</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><em>Класс</em></p></td>
<td><p>Класс определенные операции привязки и переменные C/C++.</p></td>
</tr>
<tr class="even">
<td><p><em>Ordinal</em></p></td>
<td><p>Порядковый номер, начиная с одним из поля <strong>набора записей</strong> , соответствующего переменной C/C++.</p></td>
</tr>
<tr class="odd">
<td><p><em>DataType</em></p></td>
<td><p>Эквивалентный тип данных ADO переменной C/C++ (см. <a href="datatypeenum.md">DataTypeEnum</a> список типов данных). Значение поля <strong>набора записей</strong> будут преобразованы в этот тип данных, если это необходимо.</p></td>
</tr>
<tr class="even">
<td><p><em>Буфера</em></p></td>
<td><p>Имя переменной C/C++, где будут храниться в поле <strong>набора записей</strong> .</p></td>
</tr>
<tr class="odd">
<td><p><em>Size</em></p></td>
<td><p>Максимальный размер <em>буфера</em>в байтах. Если <em>буфер</em> будет содержать строку переменной длины, разрешить комнаты для выполнения определенного нулю.</p></td>
</tr>
<tr class="even">
<td><p><em>Status</em></p></td>
<td><p>Имя переменной, которая появится сообщение о том, является ли содержимое <em>буфера</em> являются допустимыми и ли преобразование поля в <em>типе данных</em> прошла успешно. Наиболее важные значения для этой переменной не <strong>adFldOK</strong>, что означает, что преобразование прошло успешно; и <strong>adFldNull</strong>, что означает значение поля будет иметь тип VARIANT типа VT_NULL и не просто пустой. В следующей таблице перечислены возможные значения для <em>состояния</em> &quot;значения состояния.&quot;</p></td>
</tr>
<tr class="odd">
<td><p><em>Modify</em></p></td>
<td><p>Флаг типа Boolean; Если значение TRUE, указывает, что ADO может обновить соответствующее поле <strong>записей</strong> со значением, содержащихся в <em>буфере</em>. Параметр типа Boolean, <em>Изменение</em> в значение true, чтобы включить ADO для обновления связанное поле и FALSE, если вы хотите изучить поля, но не меняйте его.</p></td>
</tr>
<tr class="even">
<td><p><em>Точность</em></p></td>
<td><p>Число знаков, которые могут быть представлены в числовая переменная.</p></td>
</tr>
<tr class="odd">
<td><p><em>Scale</em></p></td>
<td><p>Число десятичных знаков в числовая переменная.</p></td>
</tr>
<tr class="even">
<td><p><em>Length</em></p></td>
<td><p>Имя переменной 4 байта, которая будет содержать длину данные в <em>буфер</em>.</p></td>
</tr>
</tbody>
</table>


## <a name="status-values"></a>Значения состояний

Значение переменной *состояние* указывает, является ли поле успешно скопирована в переменной.

При задании данных, *состояние* может быть присвоено **adFldNull** для указания поля **набора записей** необходимо задать значение null.

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Константа</p></th>
<th><p>Значение</p></th>
<th><p>Описание</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><strong>adFldOK</strong></p></td>
<td><p>0</p></td>
<td><p>Возвращено значение поля не являющееся null.</p></td>
</tr>
<tr class="even">
<td><p><strong>adFldBadAccessor</strong></p></td>
<td><p>1</p></td>
<td><p>Привязка недопустима.</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFldCantConvertValue</strong></p></td>
<td><p>2</p></td>
<td><p>Не удалось преобразовать значение по причине, отличной от несоответствия знака или данных переполнения.</p></td>
</tr>
<tr class="even">
<td><p><strong>adFldNull</strong></p></td>
<td><p>3</p></td>
<td><p>При получении поле, указывает, что возвращается значение null. При установке на поле, указывает, что поле должно быть присвоено <strong>значение NULL,</strong> Если поле не удалось зашифровать <strong>значение NULL,</strong> сам (например, массив символов или целое число).</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFldTruncated</strong></p></td>
<td><p>4</p></td>
<td><p>Данные переменной длины или цифр были усечено.</p></td>
</tr>
<tr class="even">
<td><p><strong>adFldSignMismatch</strong></p></td>
<td><p>5</p></td>
<td><p>Значение является подписью и является неподписанные переменной типа.</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFldDataOverFlow</strong></p></td>
<td><p>6</p></td>
<td><p>Значение больше, чем может храниться в типе данных переменной.</p></td>
</tr>
<tr class="even">
<td><p><strong>adFldCantCreate</strong></p></td>
<td><p>7</p></td>
<td><p>Неизвестный тип столбца и поле уже открыт.</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFldUnavailable</strong></p></td>
<td><p>8</p></td>
<td><p>Не удается определить значение поля — например, на новое поле неназначенных без значения по умолчанию.</p></td>
</tr>
<tr class="even">
<td><p><strong>adFldPermissionDenied</strong></p></td>
<td><p>9</p></td>
<td><p>При обновлении, нет разрешения для записи данных.</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFldIntegrityViolation</strong></p></td>
<td><p>10</p></td>
<td><p>При обновлении, значение поля может нарушить целостности столбца.</p></td>
</tr>
<tr class="even">
<td><p><strong>adFldSchemaViolation</strong></p></td>
<td><p>11</p></td>
<td><p>При обновлении, значение поля нарушит схемы столбца.</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFldBadStatus</strong></p></td>
<td><p>12</p></td>
<td><p>При обновлении параметр недопустимое состояние.</p></td>
</tr>
<tr class="even">
<td><p><strong>adFldDefault</strong></p></td>
<td><p>13</p></td>
<td><p>При обновлении, было использовано значение по умолчанию.</p></td>
</tr>
</tbody>
</table>

