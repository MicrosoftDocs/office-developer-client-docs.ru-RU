---
title: Использование расширений Visual C++
TOCTitle: Using Visual C++ Extensions
ms:assetid: 0fb1014c-7ab6-6add-d09f-e5e48b2b32cb
ms:mtpsurl: https://msdn.microsoft.com/library/JJ248866(v=office.15)
ms:contentKeyID: 48543270
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 8bf2234e5935c2a1a13871e7e45c980fb9f33109
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32312063"
---
# <a name="using-visual-c-extensions"></a>Использование расширений Visual C++


**Область применения**: Access 2013, Office 2013

## <a name="the-iadorecordbinding-interface"></a>Интерфейс Иадорекордбиндинг

Расширения Microsoft Visual C++ для ADO связывают или привязывают поля объекта [Recordset](recordset-object-ado.md) к переменным C/C++. При изменении текущей строки в связанном **наборе записей** все связанные поля в **наборе записей** копируются в переменные C/C++. При необходимости скопированные данные преобразуются в объявленный тип данных переменной C/C++.

Метод **биндторекордсет** интерфейса **иадорекордбиндинг** привязывают поля к переменным C/C++. Метод **AddNew** добавляет новую строку в связанный **набор записей**. Метод **Update** заполняет поля в новых строках **набора записей**или обновляет поля в существующих строках, используя значения переменных C/C++.

Интерфейс **иадорекордбиндинг** реализуется с помощью объекта **Recordset** . Вы не можете самостоятельно кодировать реализацию.

## <a name="binding-entries"></a>Записи привязки

Расширения Visual C++ для полей сопоставления ADO объекта [Recordset](recordset-object-ado.md) с переменными C/C++. Определение сопоставления между полем и переменной называется *записью привязки*. Макросы предоставляют записи привязки для числовых, фиксированной длины и данных переменной длины. Записи привязки и переменные C/C++ объявляются в классе, производном от класса расширений Visual C++, **кадорекордбиндинг**. Класс **кадорекордбиндинг** определяется внутренним образом с помощью макросов записи привязки.

ADO внутренне сопоставляет параметры в этих макросах с структурой **ДББИНДИНГ** OLE DB и создает объект средства **доступа** OLE DB для управления перемещением и преобразованием данных между полями и переменными. OLE DB определяет данные, состоящие из трех частей: *буфера* , в котором хранятся данные; *состояние* , указывающее, успешно ли сохранено поле в буфере или как переменная должна быть восстановлена в поле; и *Длина* данных. (См. *Справочник по программированию OLE DB*, глава 6: извлечение и Настройка данных для получения дополнительных сведений.)

## <a name="header-file"></a>Заголовочный файл

Добавьте следующий файл в приложение, чтобы использовать расширения Visual C++ для ADO:

```cpp 
 
#include <icrsint.h> 
```

## <a name="binding-recordset-fields"></a>Привязка полей Recordset

**Привязка полей Recordset к переменным C/C++**

1.  Создайте класс, производный от класса **кадорекордбиндинг** .

2.  Укажите записи привязки и соответствующие переменные C/C++ в производном классе. Разделять записи привязки между макросами **\_Begin привязки ADO\_** и **End\_привязки ADO\_** . Не прерывать макросы запятыми или точками с запятой. Соответствующие разделители задаются автоматически каждым макросом. Укажите одну запись привязки для каждого поля, которое необходимо сопоставить с переменной C/C++. Используйте соответствующий член из **записи фиксированной\_\_\_длины ADO**, **цифровой\_\_записи ADO**или семейства макросов с **записью\_переменной\_длины\_ADO** .

3.  В приложении создайте экземпляр класса, производного от **кадорекордбиндинг**. Получение интерфейса **иадорекордбиндинг** из **набора записей**. Затем вызовите метод **биндторекордсет** , чтобы присоединить поля **Recordset** к переменным C/C++.

Дополнительные сведения см. в [примере расширений Visual C++](visual-c-extensions-example.md) .

## <a name="interface-methods"></a>Методы интерфейса

Интерфейс **иадорекордбиндинг** содержит три метода: **биндторекордсет**, **AddNew**и **Update**. Единственный аргумент для каждого метода является указателем на экземпляр класса, производного от **кадорекордбиндинг**. Таким образом, методы **AddNew** и **Update** не могут указывать ни один из параметров метода ADO намесакес.

**Синтаксис**

Метод **биндторекордсет** связывает поля **набора записей** с переменными C/C++.

`BindToRecordset(CADORecordBinding *binding)` 

Метод **AddNew** вызывает метод намесаке, метод ADO [AddNew](addnew-method-ado.md) , чтобы добавить новую строку в **набор записей**.

`AddNew(CADORecordBinding *binding)` 

Метод **Update** вызывает метод намесаке, способ [обновления](update-method-ado.md) ADO, для обновления объекта **Recordset**.

`Update(CADORecordBinding *binding)` 

## <a name="binding-entry-macros"></a>Привязка макросов записи

Привязывание макросов записи определяет связь поля **набора записей** и переменной. Начальный и конечный макросы ограничивают набор записей привязки.

Для данных фиксированной длины, таких как **аддате** или **адбулеан**, предусмотрены семейства макросов; числовые данные, например **адтининт**, **адинтежер**или **аддаубле**; и данные переменной длины, такие как **адчар**, **адварчар** или **адварбинари**. Все числовые типы, кроме **адварнумерик**, также являются типами фиксированной длины. Каждое семейство имеет разные наборы параметров, чтобы можно было исключить информацию о привязке, не представляющую интереса.

В *справочных материалах программиста OLE DB,* приложение а: типы данных для дополнительной информации.

_**Начало записи привязки**_

**Начало\_привязки\_ADO**(*класс*)

_**Данные фиксированной длины**_

**Запись\_\_фиксированной\_длины ADO**(*порядковый номер, тип данных, буфер, состояние, изменение*)  
**\_Фиксированная\_длина\_ADO ENTRY2**(*Ordinal, DataType, buffer, Modify*)

_**Числовые данные**_

**\_Числовая\_запись ADO**(*Ordinal, DataType, buffer, Precision, Scale, Status, Modify*)  
**\_Числовой\_ENTRY2 ADO**(*порядковый, тип данных, буфер, точность, масштаб, изменение*)

_**Данные переменной длины**_

**Запись\_переменной\_длины\_ADO**(*порядковый номер, тип данных, буфер, размер, состояние, длина, изменение*)  
**\_ПЕРЕМЕННАЯ\_длина\_ADO ENTRY2**(*Ordinal, DataType, buffer, Size, Status, Modify*)  
**\_ПЕРЕМЕННАЯ\_длина\_ADO ENTRY3**(*Ordinal, DataType, buffer, Size, Length, Modify*)  
**\_ПЕРЕМЕННАЯ\_длина\_ADO ENTRY4**(*Ordinal, DataType, buffer, Size, Modify*)

_**Закончить записи привязки**_

**Завершение\_привязки\_ADO**()

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Параметр</p></th>
<th><p>Описание</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><em>Класс</em></p></td>
<td><p>Класс, в котором определены записи привязки и переменные C/C++.</p></td>
</tr>
<tr class="even">
<td><p><em>Ordinal</em></p></td>
<td><p>Порядковый номер, подсчитывающий из одного из поля <strong>Recordset</strong> , соответствующего переменной C/C++.</p></td>
</tr>
<tr class="odd">
<td><p><em>DataType</em></p></td>
<td><p>Эквивалентный тип данных ADO для переменной C/C++ (обратитесь к разделу <a href="datatypeenum.md">DataTypeEnum</a> для получения списка допустимых типов данных). Если необходимо, значение поля <strong>Recordset</strong> будет преобразовано в этот тип данных.</p></td>
</tr>
<tr class="even">
<td><p><em>Буферизовать</em></p></td>
<td><p>Имя переменной C/C++, в которой будет храниться поле <strong>Recordset</strong> .</p></td>
</tr>
<tr class="odd">
<td><p><em>Размер</em></p></td>
<td><p>Максимальный размер <em>буфера</em>в байтах. Если <em>буфер</em> будет содержать строку переменной длины, разрешите место для нулевого значения.</p></td>
</tr>
<tr class="even">
<td><p><em>Состояние</em></p></td>
<td><p>Имя переменной, указывающей, является ли содержимое <em>буфера</em> допустимым и было ли преобразование поля в <em>тип данных</em> успешным. Два наиболее важных значения этой переменной — <strong>адфлдок</strong>, что означает, что преобразование выполнено успешно; и <strong>адфлднулл</strong>, что означает, что значение поля является вариантом типа VT_NULL, а не просто пустым. Возможные значения <em>Status</em> указаны в следующей таблице: &quot;значения состояния.&quot;</p></td>
</tr>
<tr class="odd">
<td><p><em>Modify</em></p></td>
<td><p>Логический флаг; Если этот параметр имеет значение TRUE, то для ADO разрешено обновление соответствующего поля <strong>Recordset</strong> с использованием значения, содержащегося в <em>буфере</em>. Установите для параметра логического <em>изменения</em> значение true, чтобы функция ADO обновляла связанное поле, и значение false, если нужно проверить поле, но не изменять его.</p></td>
</tr>
<tr class="even">
<td><p><em>Точности</em></p></td>
<td><p>Количество цифр, которое может быть представлено в числовой переменной.</p></td>
</tr>
<tr class="odd">
<td><p><em>Масштабирование</em></p></td>
<td><p>Количество десятичных разрядов в числовой переменной.</p></td>
</tr>
<tr class="even">
<td><p><em>Length</em></p></td>
<td><p>Имя переменной из четырех байтов, которая будет содержать фактическую длину данных в <em>буфере</em>.</p></td>
</tr>
</tbody>
</table>


## <a name="status-values"></a>Значения состояния

Значение переменной *Status* указывает, было ли поле успешно скопировано в переменную.

При задании данных параметру *Status* может быть присвоено значение **адфлднулл** , чтобы указать, что поле **Recordset** должно иметь значение null.

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Константа</p></th>
<th><p>Значение</p></th>
<th><p>Описание</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><strong>адфлдок</strong></p></td>
<td><p>нуль</p></td>
<td><p>Возвращено значение поля, отличное от NULL.</p></td>
</tr>
<tr class="even">
<td><p><strong>адфлдбадакцессор</strong></p></td>
<td><p>1,1</p></td>
<td><p>Недопустимая привязка.</p></td>
</tr>
<tr class="odd">
<td><p><strong>адфлдкантконвертвалуе</strong></p></td>
<td><p>2</p></td>
<td><p>Не удалось преобразовать значение по причине, отличной от несоответствия знака или переполнения данных.</p></td>
</tr>
<tr class="even">
<td><p><strong>адфлднулл</strong></p></td>
<td><p>4</p></td>
<td><p>При возврате поля показывается, что было возвращено значение null. При установке поля указывает, что для поля должно быть задано <strong>значение NULL</strong> , если поле не может закодировать само <strong>значение NULL</strong> (например, массив символов или целое число).</p></td>
</tr>
<tr class="odd">
<td><p><strong>адфлдтрункатед</strong></p></td>
<td><p>4 </p></td>
<td><p>Данные переменной длины или цифры были усечены.</p></td>
</tr>
<tr class="even">
<td><p><strong>адфлдсигнмисматч</strong></p></td>
<td><p>5 </p></td>
<td><p>Значение имеет подпись и тип данных переменной не подписан.</p></td>
</tr>
<tr class="odd">
<td><p><strong>адфлддатаоверфлов</strong></p></td>
<td><p>6 </p></td>
<td><p>Значение больше, чем может храниться в типе данных переменной.</p></td>
</tr>
<tr class="even">
<td><p><strong>адфлдканткреате</strong></p></td>
<td><p>7 </p></td>
<td><p>Неизвестный тип столбца и поле уже открыто.</p></td>
</tr>
<tr class="odd">
<td><p><strong>адфлдунаваилабле</strong></p></td>
<td><p>8 </p></td>
<td><p>Не удалось определить значение поля, например, для нового неназначенного поля без значения по умолчанию.</p></td>
</tr>
<tr class="even">
<td><p><strong>адфлдпермиссиондениед</strong></p></td>
<td><p>9 </p></td>
<td><p>При обновлении разрешение на запись данных не разрешится.</p></td>
</tr>
<tr class="odd">
<td><p><strong>адфлдинтегритивиолатион</strong></p></td>
<td><p>10 </p></td>
<td><p>При обновлении значение поля нарушает целостность столбца.</p></td>
</tr>
<tr class="even">
<td><p><strong>адфлдсчемавиолатион</strong></p></td>
<td><p>11 </p></td>
<td><p>При обновлении значение поля нарушает схему столбца.</p></td>
</tr>
<tr class="odd">
<td><p><strong>адфлдбадстатус</strong></p></td>
<td><p>12 </p></td>
<td><p>При обновлении — недопустимый параметр Status.</p></td>
</tr>
<tr class="even">
<td><p><strong>адфлддефаулт</strong></p></td>
<td><p>13</p></td>
<td><p>При обновлении используется значение по умолчанию.</p></td>
</tr>
</tbody>
</table>

