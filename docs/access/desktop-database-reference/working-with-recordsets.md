---
title: Работа с наборами записей
TOCTitle: Working with Recordsets
ms:assetid: 9cd52866-2738-8150-381c-eee0b8a6cd36
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249711(v=office.15)
ms:contentKeyID: 48546608
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 0d4b877b680c80a10067e19065facd4ce9e4819d
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32305975"
---
# <a name="working-with-recordsets"></a>Работа с наборами записей

**Область применения**: Access 2013, Office 2013 

Объект **Recordset** содержит встроенные функции, позволяющие изменить порядок данных в результирующем наборе, чтобы найти определенную запись на основе предоставленных условий, а также оптимизировать эти операции поиска с помощью индексов. Доступность этих функций зависит от поставщика и в некоторых случаях, таких как свойство [index](index-property-ado.md) — структура самого источника данных.

## <a name="arranging-data"></a>Упорядочение данных

Часто наиболее эффективный способ упорядочивания данных в **наборе записей** заключается в указании предложения ORDER BY в команде SQL, используемой для возврата результатов. Однако может потребоваться изменить порядок данных в уже созданном **наборе записей** . С помощью свойства **Sort** можно установить порядок, в котором просматриваются строки **набора записей** . Кроме того, свойство **Filter** определяет, какие строки доступны при переборе строк.

Свойство **Sort** задает или возвращает **строковое** значение, которое указывает имена полей в **наборе записей** , по которому выполняется сортировка. Каждое имя отделяется запятой и при необходимости за ним следует пробел и ключевое слово **ASC** (то есть сортировка поля по возрастанию) или **DESC** (сортировка поля в убывающем порядке). По умолчанию при условии, что ключевое слово не задано, поле сортируется в возрастающем порядке.

Операция сортировки эффективна, так как данные не переупорядочиваются физически, но доступ к ним осуществляется только в порядке, указанном индексом.

Для свойства **Sort** необходимо задать для свойства [CursorLocation](cursorlocation-property-ado.md) значение **адусеклиент**. Для каждого поля, указанного в свойстве **Sort** , будет создан временный индекс, если индекс еще не существует.

Если задать для свойства **Sort** пустую строку, строки будут сброшены в исходный порядок и удалять временные индексы. Существующие индексы не будут удалены.

Предположим, что объект **Recordset** содержит три поля с именами *FirstName*, *миддлеинитиал*и *LastName*. Задайте для свойства **Sort** строку "", которая будет упорядочивать **набор записей** по фамилии в убывающем порядке, а затем по имени по возрастанию. Посрединный инициал игнорируется.

Поля, на которые ссылается строка условий сортировки, не могут называться "ASC" или "DESC", так как эти имена конфликтуют с ключевыми словами **ASC** и **DESC**. Присвойте полю с конфликтующим именем псевдоним, используя ключевое слово **as** в запросе, возвращающем **набор записей**.

Более подробную информацию об фильтрации **наборов записей** можно узнать в статье фильтрация результатов в этой статье.

## <a name="finding-a-specific-record"></a>Поиск определенной записи

ADO предоставляет методы [поиска](find-method-ado.md) и [поиска](seek-method-ado.md) для поиска определенной записи в **наборе записей**. Метод **Find** поддерживается различными поставщиками, но ограничен одним условием поиска. Метод **Seek** поддерживает поиск по нескольким условиям, но не поддерживается многими поставщиками.

Индексы для полей могут значительно увеличить производительность метода **Find** объекта **Recordset** , а также свойства **сортировки** и **фильтрации** . Вы можете создать внутренний индекс для объекта **field** , задав его динамическое свойство [optimize](optimize-property-dynamic-ado.md) . Это динамическое свойство добавляется в коллекцию **свойств** объекта **field** , если для свойства [CursorLocation](cursorlocation-property-ado.md) задано значение **адусеклиент**. Помните, что этот индекс является внутренним по отношению к ADO, поэтому вы не можете получить к нему доступ или использовать его для других целей. Кроме того, этот индекс отличается от свойства [index](index-property-ado.md) объекта **Recordset** .

Метод **Find** быстро находит значение в столбце (поле) объекта **Recordset**. Часто можно улучшить скорость операции метода **Find** для столбца с помощью свойства **optimize** для создания индекса.

Метод **Find** позволяет ограничить поиск содержимым одного поля. Метод **Seek** требует наличия индекса и имеет также и другие ограничения. Если требуется выполнить поиск по нескольким полям, не являющимся основой для индекса, или если поставщик не поддерживает индексы, вы можете ограничить результаты с помощью свойства **Filter** объекта **Recordset** .

### <a name="find"></a>Найти

Метод **Find** выполняет поиск строки, удовлетворяющей заданному условию, в **наборе записей** . При необходимости можно указать направление поиска, начальную строку и смещение из начальной строки. Если условие выполнено, для найденной записи задается текущая позиция строки; в противном случае в качестве положения задается конец (или начало) **набора записей**в зависимости от направления поиска.

Для этого критерия можно указать только одно имя столбца. Другими словами, этот метод не поддерживает поиск по нескольким столбцам.

Оператор сравнения для критерия может иметь значение "**\>**" (больше),**\<**"" (меньше), "=" (равно), "\>=" (больше или равно), "\<=" (меньше или равно), "\<\>" (не равно) или "Like" (сопоставление по шаблону).

Значение критерия может быть строкой, числом с плавающей запятой или датой. Строковые значения разделяются символами одинарных\#кавычек или "" (знак номера) (например, "State = ' WA '" или "State \#=\#WA"). Значения дат разделяются знаками\#"" (знак номера) (например\_, "Дата \> \#начала 7/22/97\#").

Если оператор сравнения "Like", строковое значение может содержать звездочку (\*), чтобы найти один или несколько вхождений любого знака или подстроки. Например, "State Like m\*" соответствует Мэн и Массачусетс. Кроме того, можно использовать ведущие и замыкающие звездочки, чтобы найти подстроку, содержащуюся в значениях. Например, "состояние, например"\*как\*", соответствует" Аляска "," Арканзас "и Массачусетс.

Звездочки можно использовать только в конце строки условий, а также в начале и конце строки условий, как показано выше. Вы не можете использовать звездочку в качестве начального подстановочного\*знака ("str") или внедренного подстановочного знака ("\*r"). Это приведет к ошибке.

### <a name="seek-and-index"></a>Поиск и индексирование

Используйте метод **Seek** вместе со свойством **index** , если базовый поставщик поддерживает индексы для объекта **Recordset** . Используйте метод Supported **(адсик)** [, чтобы](supports-method-ado.md)определить, поддерживает ли базовый поставщик **Поиск**, и метод **поддержки (адиндекс)** , чтобы определить, поддерживает ли поставщик индексы. (Например, [поставщик OLE DB для Microsoft Jet](microsoft-ole-db-provider-for-microsoft-jet.md) поддерживает **Поиск** и **индексирование**.)

Если **Seek** не находит нужную строку, ошибка не возникает, а строка располагается в конце **набора записей**. Перед выполнением этого метода установите для свойства **index** нужный индекс.

Этот метод поддерживается только с курсорами на стороне сервера. Поиск не поддерживается, если значение свойства [CursorLocation](cursorlocation-property-ado.md) объекта **Recordset** равно **адусеклиент**.

Этот метод можно использовать только в том случае, если объект **Recordset** открыт со значением [коммандтипинум](commandtypeenum.md) для **адкмдтабледирект**.

## <a name="filtering-the-results"></a>Фильтрация результатов

Метод **Find** позволяет ограничить поиск содержимым одного поля. Метод **Seek** требует наличия индекса и имеет также и другие ограничения. Если вам нужно выполнить поиск по нескольким полям, которые не основаны на индексе, или поставщик не поддерживает индексы, вы можете ограничить результаты с помощью свойства **Filter** объекта **Recordset** .

Используйте свойство **Filter** для выборочного отображения записей в объекте **Recordset** . Отфильтрованный **набор записей** становится текущим курсором, что означает, что записи, которые не удовлетворяют условиям **фильтра** , не будут доступны в **наборе записей** до тех пор, пока **Фильтр** не будет удален. Затронуты другие свойства, возвращающие значения на основе текущего курсора, такие как **AbsolutePosition**, **AbsolutePage**, **RecordCount**и **PageCount**. Это связано с тем, что если задать для свойства **Filter** определенное значение, текущая запись будет перемещена в первую запись, которая соответствует новому значению.

Свойство **Filter** принимает аргумент Variant. Это значение представляет один из трех методов использования свойства **Filter** : строку условий, константу **филтерграупенум** или массив закладок. Дополнительные сведения приведены в статье фильтрация с использованием строки условий, фильтрации с использованием констант и фильтрации с помощью закладок далее в этом разделе.

> [!NOTE]
> Если вы знаете данные, которые вы хотите выбрать, обычно более эффективно открыть объект **Recordset** с помощью оператора SQL, который эффективно фильтрует набор результатов, а не полагается на свойство **Filter** .

Чтобы удалить фильтр из **набора записей**, используйте константу **адфилтерноне** . Установка свойства **Filter** для строки нулевой длины ("") имеет тот же последствия, что и использование константы **адфилтерноне** .

### <a name="filtering-with-a-criteria-string"></a>Фильтрация с помощью строки условий

Строка условия состоит из предложений в *значении оператора "FieldName* " формы (например, "LastName = ' Smith '). Можно создавать составные предложения, объединяя отдельные предложения с AND (например, "LastName = ' Smith ' и FirstName = ' John '") и или (например,). Можно создавать составные предложения, объединяя отдельные предложения с AND (например, "LastName = ' Smith ' и FirstName = ' John '"), а также (например, "LastName = ' Smith ' или LastName = ' Иванов '). Используйте следующие рекомендации для строк условий:

- Значение *fieldname* должно быть допустимым именем поля из **набора записей**. Если имя поля содержит пробелы, его необходимо заключить в квадратные скобки.

- *Оператор* должен быть одним из \<следующих:, \>, \<=, \>=, \< \>, = или LIKE.

- *Value* — это значение, с которым сравниваются значения полей (например, ' Smith ', \#8/24/95\#, 12,345 или $50,00). Используйте одинарные кавычки (') со строками и знаками решетки (\#) с датами. Для чисел можно использовать десятичные точки, знаки доллара и экспоненциальное представление. *Оператор* If имеет такой вид, *значение* может использовать подстановочные знаки. Только звездочка (\*) и знак процента (%) подстановочные знаки разрешены, и они должны быть последними символами в строке. *Значение* не может быть равно null.
    
  > [!NOTE]
  > Чтобы включить в *значение*фильтра одиночные кавычки ('), используйте два одинарных кавычка для обозначения одного. Например, для фильтрации по *о'маллэй*необходимо указать строку критерия "col1 = ' O ' ' маллэй '". 
  > 
  > Чтобы включить одинарные кавычки в начале и конце значения фильтра, заключите строку в знаки фунта (#). Например, чтобы выполнить фильтрацию по *"1"*, строка критериев должна иметь значение "col1 = #" 1 "#".

Нет приоритета между AND и OR. Предложения можно группировать в круглые скобки. Однако вы не можете группировать предложения, Соединенные с помощью оператора OR, а затем присоединить группу к другому предложению с помощью оператора AND, как показано ниже.

```vb 
 
(LastName = 'Smith' OR LastName = 'Jones') AND FirstName = 'John' 
```

Вместо этого этот фильтр создается следующим образом:

```vb 
 
(LastName = 'Smith' AND FirstName = 'John') OR (LastName = 'Jones' AND FirstName = 'John') 
```

В выражении LIKE можно использовать подстановочные знаки в начале и конце шаблона (например, LastName, например, "\*MIT\*") или только в конце шаблона (например, "Фамилия") или только в конце шаблона (например, LastName, например "Смит\*").

### <a name="filtering-with-a-constant"></a>Фильтрация с помощью константы

Для фильтрации **наборов записей**доступны следующие константы.

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Константа</p></th>
<th><p>Описание</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><strong>адфилтераффектедрекордс</strong></p></td>
<td><p>Фильтры для просмотра записей, которые были применены при вызове последней функции <strong>удаления</strong>, повторной <strong>синхронизации</strong>, <strong>UpdateBatch</strong>или <strong>CancelBatch</strong> .</p></td>
</tr>
<tr class="even">
<td><p><strong>адфилтерконфликтингрекордс</strong></p></td>
<td><p>Фильтры для просмотра записей, для которых не удалось выполнить Последнее пакетное обновление.</p></td>
</tr>
<tr class="odd">
<td><p><strong>адфилтерфетчедрекордс</strong></p></td>
<td><p>Фильтры для просмотра записей в текущем кэше (то есть результаты последнего вызова для получения записей из базы данных).</p></td>
</tr>
<tr class="even">
<td><p><strong>адфилтерноне</strong></p></td>
<td><p>Удаляет текущий фильтр и восстанавливает все записи для просмотра.</p></td>
</tr>
<tr class="odd">
<td><p><strong>адфилтерпендингрекордс</strong></p></td>
<td><p>Фильтры для просмотра только тех записей, которые были изменены, но еще не отправлены на сервер. Применяется только для режима пакетного обновления.</p></td>
</tr>
</tbody>
</table>

<br/>

Константы фильтра упрощают устранение конфликтов отдельных записей во время пакетного обновления, позволяя просматривать, например, только те записи, которые были применены при последнем вызове метода **UpdateBatch** , как показано в следующем примере:

```vb 
 
'BeginDeleteGroup 
    'add some bogus records 
    With objRs1 
        For i = 0 To 8 
            .AddNew 
            .Fields("CompanyName") = "Shipper Number " & i + 1 
            .Fields("Phone") = "(425) 555-000" & (i + 1) 
            .Update 
        Next i 
         
    're-connect & update 
        .ActiveConnection = GetNewConnection 
        .UpdateBatch 
         
    'filter on newly added records 
        .Filter = adFilterAffectedRecords 
        Debug.Print "Deleting the " & .RecordCount & _ 
                    " records you just added." 
         
    'delete the newly added bogus records 
        .Delete adAffectGroup 
        .Filter = adFilterNone 
        Debug.Print .RecordCount & " records remain." 
         
        .Close 
    End With 
'EndDeleteGroup 
```

### <a name="filtering-with-bookmarks"></a>Фильтрация с помощью закладок

Наконец, можно передать массив вариантов закладок в свойство **Filter** . Полученный курсор будет содержать только те записи, для которых в свойстве была передана закладка. В следующем примере кода создается массив закладок из записей в **наборе записей** , где в поле *ProductName* задано значение "B". Затем массив передается в свойство **Filter** и отображает сведения о итоговом отфильтрованном **наборе записей**.

```vb 
 
'BeginFilterBkmk 
    Dim vBkmkArray() As Variant 
    Dim i As Integer 
 
    'Recordset created using "SELECT * FROM Products" as command. 
    'So, we will check to see if ProductName has a capital B, and 
    'if so, add to the array. 
    i = 0 
    Do While Not objRs.EOF 
        If InStr(1, objRs("ProductName"), "B") Then 
            ReDim Preserve vBkmkArray(i) 
            vBkmkArray(i) = objRs.Bookmark 
            i = i + 1 
            Debug.Print objRs("ProductName") 
        End If 
        objRs.MoveNext 
    Loop 
     
    'Filter using the array of bookmarks. 
    objRs.Filter = vBkmkArray 
     
    objRs.MoveFirst 
    Do While Not objRs.EOF 
        Debug.Print objRs("ProductName") 
        objRs.MoveNext 
    Loop 
    'EndFilterBkmk 
```

## <a name="creating-a-clone-of-a-recordset"></a>Создание клона объекта Recordset

Используйте метод **clone** для создания нескольких дублирующихся объектов **Recordset** , в частности, если требуется поддерживать несколько текущих записей в заданном наборе записей. Использование метода **clone** является более эффективным, чем создание и открытие нового объекта **Recordset** с тем же определением, что и исходный.

Для текущей записи созданного клона изначально задается первая запись. Указатель текущей записи в клонированном **наборе записей** не синхронизирован с исходным и наоборот. В каждом **наборе записей**можно перемещаться независимо друг от друга.

Изменения, вносимые в один объект **Recordset** , отображаются во всех клонах, независимо от типа курсора. Однако после выполнения командлета [Requery](requery-method-ado.md) для исходного объекта **Recordset**клоны больше не будут синхронизироваться с исходным.

Закрытие исходного объекта **Recordset** не приводит к закрытию его копий, а также закрытию копии.

Вы можете клонировать объект **Recordset** только в том случае, если он поддерживает закладки. Значения закладок являются взаимозаменяемыми; то есть ссылка на закладку из одного объекта **Recordset** ссылается на одну и ту же запись в любом из его клонов.

