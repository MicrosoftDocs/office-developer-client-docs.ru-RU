---
title: Working with Recordsets
TOCTitle: Working with Recordsets
ms:assetid: 9cd52866-2738-8150-381c-eee0b8a6cd36
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249711(v=office.15)
ms:contentKeyID: 48546608
ms.date: 09/18/2015
mtps_version: v=office.15
ms.openlocfilehash: ab78043392801f04a85a80c103c7afad6091b30b
ms.sourcegitcommit: 19aca09c5812cfb98b68b5d4604dcaa814479df7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/09/2018
ms.locfileid: "25481022"
---
# <a name="working-with-recordsets"></a>Working with Recordsets


**Применимо к**: Access 2013 | Office 2013 

Объект **набора записей** содержит встроенные функции, которые позволяют изменить порядок данные в результате задать, для поиска конкретных записей по критерии, по которым вы задаете и даже для оптимизации тех поиска операций с помощью индексов. Эти возможности доступны для использования зависит от поставщика и в некоторых случаях — например, свойство [Index](index-property-ado.md) — Структура самого источника данных.

## <a name="arranging-data"></a>Упорядочивание данных

Часто самый эффективный способ упорядочивать данные набора **записей** — путем указания предложение ORDER BY в команды SQL, используется для возврата результатов. Тем не менее может потребоваться изменение порядка данных в **набор записей** , которые уже были созданы. Свойство **сортировки** для установления порядка проверено строк **набора записей** . Кроме того свойство **фильтра** определяет строк, которые доступны при обходе строк.

Свойство **сортировки** задает или возвращает **строковое** значение, указывающее, имена полей в наборе **записей** , по которому выполняется сортировка. Имя каждого разделенных точкой с запятой и при необходимости следуют пробел и ключевое слово **ASC** (который выполняется сортировка поля в порядке возрастания) или **DESC** (который выполняется сортировка поля в порядке убывания). По умолчанию если нет ключевых слов не указан, то это поле является сортироваться в восходящем порядке.

Операция сортировки эффективен, так как данные физически не изменяется, но просто осуществляется в порядке, указанном с помощью индекса.

Свойство **сортировки** требует свойства [CursorLocation](cursorlocation-property-ado.md) должно быть задано для **adUseClient**. Временный индекс создается для каждого поля, указанных в свойстве **сортировки** , если индекс еще не существует.

Свойства **сортировки** пустую строку Сброс исходный порядок строк и удалите временные индексы. Существующие индексы не удаляются.

Предположим, что **набор записей** содержит три поля с именами *firstName*, *middleInitial*и *Фамилия*. Присвойте свойству **сортировки** в строку «», которое будет порядке **записей** по фамилии в порядке убывания, а затем по имени в порядке возрастания. Инициалы игнорируется.

Поле не указывается в строке условия сортировки может быть с именем «ASC» или «DESC» конфликтовать с ключевыми словами **ASC** и **DESC**их имена. Задайте псевдоним поля с конфликтующими именами с помощью ключевого слова **AS** в запрос, возвращающий **набора записей**.

Для получения дополнительных сведений о фильтрации **записей** видеть фильтрации результатов, полученных данного раздела.

## <a name="finding-a-specific-record"></a>Поиск определенной записи

ADO предоставляет методы [поиска](find-method-ado.md) и [поиска](seek-method-ado.md) для поиска конкретной записи в **набор записей**. Метод **поиска** поддерживается различных поставщиков, но не может превышать одного поиска. Метод **Seek** поддерживает поиск по нескольким условиям, но не поддерживает многие поставщики.

Индексов на полях может значительно увеличить производительность **поиска** метода и **Сортировка** и **Фильтрация** свойства объекта **набора записей** . Можно создать внутренний индекс для объекта **поля** путем установки свойства динамического [оптимизировать](optimize-property-dynamic-ado.md) . Это свойство динамических добавляется в коллекцию **свойств** объекта **поля** при [CursorLocation](cursorlocation-property-ado.md) свойству присвоено значение **adUseClient**. Имейте в виду, что этот индекс внутренних ADO — не удается получить доступ к нему или использовать в любых других целях. Кроме того в этом индекса отличается от свойства [Index](index-property-ado.md) объекта **набора записей** .

Метод **поиска** быстро находит значение в столбец (поле) набора **записей**. Часто может увеличить скорость операции метод **поиска** для столбца с помощью свойства **оптимизировать** для создания индекса.

Метод **Найти** ограничивает поиск значения одного поля. Метод **Seek** требуется имеет индекса, а также другие ограничения. Если вам требуется выполнять поиск по нескольким полям, которые не отдельных индекса или ваш поставщик поддерживает индексы, можно ограничить результаты с помощью **фильтров** свойств объекта **набора записей** .

## <a name="find"></a>Найти

Метод **поиска** выполняет поиск **записей** для строки, которая должна удовлетворять указанного критерия. Кроме того можно указать направление поиска, начальную строку и смещением от начала строки. Если соблюдаются условия, текущей позиции строки имеет значение обнаруженного записи; в противном случае положение задано значение (начала или конца) набора **записей**, в зависимости от направление поиска.

Может быть указано только имя одного столбца критерия. Другими словами этот метод не поддерживает поиска по нескольким столбцам.

Оператор сравнения критерия может быть "**\>**«(больше),»**\<**«(меньше), «=» (равно),»\>=» (больше или равно),"\<=» (меньше или равно), "\<\>" (не равно) или «Как и» (подстановочные знаки).

Значение критерия может быть строка, число с плавающей запятой или дата. Строковые значения разделяются одинарные кавычки или "\#" (знак) помечает (, например «состояние = «Вашингтон»» или «состояние = \#WA\#«). Значения дат разделяются "\#" помечает (знак) (например, «запустите\_даты \> \#7/22/97\#«).

Если оператор сравнения «как», строковое значение может содержать символ звездочки (\*) для поиска одного или нескольких экземпляров любой символ или подстроки. Например «состояние как am\*"» соответствует Мэн и Массачусетского. Можно также использовать начальные и конечные звездочки поиск подстроки, содержащийся в значениях. Например «состояние как "\*как\*"» соответствует Аляска, Arkansas и Массачусетского.

Звездочки можно использовать только в конце строки критерии или друг с другом в начале и в конце строки критерии, как показано выше. Нельзя использовать в качестве начальных подстановочный знак звездочка ("\*str") или встраивается подстановочные знаки ('s\*r "). Это приведет к ошибке.

## <a name="seek-and-index"></a>Поиск и индексирование

Используйте метод **Seek** в сочетании со свойством **индекса** , если базовый поставщик поддерживает индексы в объекте **набора записей** . Используйте метод [поддерживает](supports-method-ado.md)**(adSeek)** , чтобы определить, поддерживает ли основного поставщика **поиска**и метод **Supports(adIndex)** , чтобы определить, поддерживает ли поставщик индексов. (Например, [Поставщик OLE DB для Microsoft Jet](microsoft-ole-db-provider-for-microsoft-jet.md) поддерживает **поиска** и **индекса**).

Если **Поиск** не удается найти нужную строку, ошибка не происходит и размещенный строку в конец **набора записей**. Значение свойства **Index** желаемую индекса перед выполнением этого метода.

Этот метод поддерживается только записей на стороне сервера. Поиск не поддерживается, если значение свойства [CursorLocation](cursorlocation-property-ado.md) объекта **набора записей** является **adUseClient**.

Этот метод можно использовать только в том случае, если был открыт со значением [CommandTypeEnum](commandtypeenum.md) **adCmdTableDirect**объекта **набора записей** .

## <a name="filtering-the-results"></a>Фильтрация результатов

Метод **Найти** ограничивает поиск значения одного поля. Метод **Seek** требуется имеет индекса, а также другие ограничения. Если вам требуется выполнять поиск по нескольким полям, которые не являются основой для индекса или ваш поставщик поддерживает индексы, можно ограничить результаты с помощью **фильтров** свойств объекта **набора записей** .

Используйте свойство **фильтра** выборочно пропускать записей в объекте **набора записей** . Отфильтрованного **набора записей** становится текущий указатель, что означает, что записи, которые не удовлетворяет условиям **фильтра** , недоступны в **записей** пока не будет снято **фильтра** . Другие свойства, возвращающие значения на основании текущей курсора влияет на, такие как **AbsolutePosition**, **AbsolutePage**, **RecordCount**и **PageCount**. Это связано с определенным значением свойства **фильтра** для первой записи, которая должна удовлетворять новое значение Перемещение текущей записи.

Свойство **фильтра** принимает аргумент типа variant. Это значение представляет один из трех способов использования свойства **фильтра** : строка критерии, константа **FilterGroupEnum** или массив закладки. Для получения дополнительных сведений см. Далее в этом разделе фильтрация со строкой критерии, фильтрация с константой и фильтрация с помощью закладок.


> [!NOTE]
> <P>Если вы знаете данных, которые нужно выбрать, обычно более эффективно для открытия <STRONG>набора записей</STRONG> с помощью оператора SQL, которая эффективно фильтрует результат установить, а не на свойство <STRONG>фильтра</STRONG> .</P>



Чтобы удалить фильтр из **набора записей**, используйте константу **adFilterNone** . Свойства **фильтра** в строку нулевой длины ("») имеет тот же эффект, что и использование **adFilterNone** константу.

## <a name="filtering-with-a-criteria-string"></a>Фильтрация с использованием строка условий

Строка условий включает в себя предложений в форме *FieldName оператор значение* (например, «LastName = «Smith»»). Можно создать составные предложения, объединив отдельных предложений с AND (например, «LastName = 'Smith» "и" FirstName = «John»») и или (например,). Можно создать составные предложения, объединив отдельных предложений с AND (, например «LastName = 'Smith» "и" FirstName = «John»») и или (, например «LastName = 'Smith» или LastName = «Jones»»). Используйте следующие рекомендации для строк с типом условия:

  - *FieldName* должно быть допустимое имя поля из **набора записей**. Если имя поля содержит пробелы, необходимо заключить имя в квадратные скобки.

  - *Оператор* должно быть одно из следующих значений: \<, \>, \<=, \>=, \< \>, = или как.

  - *Значение* — это значение, с которым будет сравнение значений полей (например, «Smith», \#8/24/95\#, 12.345 или $50,00). Используйте одинарные кавычки (') со строками и символов (\#) с датами. Для номеров можно использовать десятичные, знак доллара и научное обозначение. Если *оператор* LIKE *значение* можно использовать подстановочные знаки. Только звездочки (\*) и знак процента (%) подстановочные знаки допускаются, и они должны иметь последний символ в строке. Не может иметь *значение* null.
    

    > [!NOTE]
    > <P>Чтобы включить в фильтр <EM>значение</EM>одинарные кавычки ('), используйте одинарные кавычки для представления одного. Например, чтобы отфильтровать <EM>O'Malley</EM>, критерии строка должна быть «Столбец1 = "O'' Malley"». Для включения одинарные кавычки в начале и конце значение фильтра, заключите строку в знаки решетки (#). Например, чтобы отфильтровать <EM>"1"</EM>, критерии строка должна быть «Столбец1 = # "1" #».</P>



Нет нет приоритет между и и или. Предложения можно разбить в скобки. Тем не менее невозможно Группировать предложения, соединенные OR и затем присоединиться к группе на другое предложение с AND, следующим образом:

```vb 
 
(LastName = 'Smith' OR LastName = 'Jones') AND FirstName = 'John' 
```

Вместо этого построении этот фильтр как:

```vb 
 
(LastName = 'Smith' AND FirstName = 'John') OR (LastName = 'Jones' AND FirstName = 'John') 
```

В LIKE, можно использовать подстановочный знак в начале и в конце сопоставляться с шаблоном (, например LastName Like '\*mit\*") или только в конце шаблона (например) или только в конце сопоставляться с шаблоном (, например LastName Like" Smit\*").

## <a name="filtering-with-a-constant"></a>Фильтрация с использованием константа

Следующие константы доступны для фильтрации **наборов записей**.

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Константа</p></th>
<th><p>Описание</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><strong>adFilterAffectedRecords</strong></p></td>
<td><p>Фильтры для просмотра только записи, относится при последнем вызове <strong>Удаление</strong>, <strong>выполнить повторную синхронизацию</strong>, <strong>UpdateBatch</strong>или <strong>CancelBatch</strong> .</p></td>
</tr>
<tr class="even">
<td><p><strong>adFilterConflictingRecords</strong></p></td>
<td><p>Фильтры для просмотра записей, которые не удалось последнего обновления пакета.</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFilterFetchedRecords</strong></p></td>
<td><p>Фильтры для просмотра записей в кэше текущего — то есть, результаты последнего звонка для извлечения записей из базы данных.</p></td>
</tr>
<tr class="even">
<td><p><strong>adFilterNone</strong></p></td>
<td><p>Удаляет текущий фильтр и восстанавливает все записи для просмотра.</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFilterPendingRecords</strong></p></td>
<td><p>Фильтры для просмотра только записей, были изменены, но еще не были отправлены на сервер. Применимо только к режим пакетного обновления.</p></td>
</tr>
</tbody>
</table>


Константы фильтра упростить конфликтов отдельных записей в режиме пакетного обновления, позволяя просматривать, например позвонить только те записи, которые были относится во время последнего метода **UpdateBatch** , как показано в следующем примере:

```vb 
 
'BeginDeleteGroup 
    'add some bogus records 
    With objRs1 
        For i = 0 To 8 
            .AddNew 
            .Fields("CompanyName") = "Shipper Number " & i + 1 
            .Fields("Phone") = "(425) 555-000" & (i + 1) 
            .Update 
        Next i 
         
    're-connect & update 
        .ActiveConnection = GetNewConnection 
        .UpdateBatch 
         
    'filter on newly added records 
        .Filter = adFilterAffectedRecords 
        Debug.Print "Deleting the " & .RecordCount & _ 
                    " records you just added." 
         
    'delete the newly added bogus records 
        .Delete adAffectGroup 
        .Filter = adFilterNone 
        Debug.Print .RecordCount & " records remain." 
         
        .Close 
    End With 
'EndDeleteGroup 
```

## <a name="filtering-with-bookmarks"></a>Фильтрация с помощью закладок

И, наконец вы можете передать массив вариантов закладок свойство **фильтра** . Итоговый курсор будет содержать только записей, чьи закладку был передан в свойство. В следующем примере кода создается массив закладки из записей в наборе **записей** , которые имеют «Б» в поле *имя продукта* . Затем передает массив в свойство **фильтра** и отображается информация о результирующего **набора записей**.

```vb 
 
'BeginFilterBkmk 
    Dim vBkmkArray() As Variant 
    Dim i As Integer 
 
    'Recordset created using "SELECT * FROM Products" as command. 
    'So, we will check to see if ProductName has a capital B, and 
    'if so, add to the array. 
    i = 0 
    Do While Not objRs.EOF 
        If InStr(1, objRs("ProductName"), "B") Then 
            ReDim Preserve vBkmkArray(i) 
            vBkmkArray(i) = objRs.Bookmark 
            i = i + 1 
            Debug.Print objRs("ProductName") 
        End If 
        objRs.MoveNext 
    Loop 
     
    'Filter using the array of bookmarks. 
    objRs.Filter = vBkmkArray 
     
    objRs.MoveFirst 
    Do While Not objRs.EOF 
        Debug.Print objRs("ProductName") 
        objRs.MoveNext 
    Loop 
    'EndFilterBkmk 
```

## <a name="creating-a-clone-of-a-recordset"></a>Создание копии набора записей

Используйте метод **клонированной** для создания нескольких дубликатов объектов **набора записей** , особенно в том случае, если вы хотите поддерживать более одного текущей записи в данного набора записей. С помощью метода **клонированной** эффективнее, чем создания и открытия нового объекта **набора записей** с тем же определением, что и исходный.

Текущая запись только что созданный клонированной изначально присвоено значение первой записи. Указатель текущей записи в клонированной **записей** не синхронизируются с исходной или наоборот. Можно перемещаться независимо друг от друга в каждом **набора записей**.

Изменения, внесенные на **один Recordset** видны во всех его копирует вне зависимости от типа курсора. Тем не менее после выполнения [запроса](requery-method-ado.md) на исходный **набора записей**копирует больше не синхронизируются с исходным.

Закрытие исходного **набора записей** не закрывайте его копии, а также закрывая копии закрыть исходной или любых других копий.

Объект **набора записей** можно скопировать только в том случае, если он поддерживает закладки. Значения закладки являются взаимозаменяемыми; Таким образом закладка ссылку из одного объекта **набора записей** относится к одной и той же записи в любом из его копирует.

