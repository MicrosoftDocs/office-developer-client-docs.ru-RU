---
title: Работа с наборами записей
TOCTitle: Working with Recordsets
ms:assetid: 9cd52866-2738-8150-381c-eee0b8a6cd36
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249711(v=office.15)
ms:contentKeyID: 48546608
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 0d4b877b680c80a10067e19065facd4ce9e4819d
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32305975"
---
# <a name="working-with-recordsets"></a>Работа с наборами записей

**Область применения**: Access 2013, Office 2013 

Объект **Recordset** имеет встроенные функции, которые делают возможным перенастройку порядка данных в наборе результатов, поиск определенной записи на основе критериев, которые вы поставляете, и даже оптимизировать эти операции поиска с помощью индексов. Доступны ли эти функции для использования, зависит от поставщика, а в некоторых случаях — например, свойства [Index](index-property-ado.md) — структуры самого источника данных.

## <a name="arranging-data"></a>Организация данных

Часто наиболее эффективным способом заказа данных в наборе **записей** является указание пункта ORDER BY в команде SQL, используемой для возврата результатов. Однако может потребоваться изменить порядок данных в уже созданном **наборе recordset.** Вы можете использовать свойство **Sort,** чтобы установить порядок, в котором проходят строки **наборов записей.** Кроме того, свойство **Filter** определяет, какие строки доступны при обходе строк.

Свойство **Sort** задает или возвращает значение **String,** которое указывает имена полей в **наборе записей,** на которые следует сортировать. Каждое имя разделено запятой и по желанию сопровождается пробелом и ключевым словом **ASC** (сортировать поле в порядке восходящего) или **DESC** (которое сортировать поле в порядке убывания). По умолчанию, если ключевое слово не указано, поле сортироваться в порядке восходящей.

Операция сортировки эффективна, так как данные физически не перестановки, а просто доступны в порядке, указанном индексом.

Свойство **Sort** требует, чтобы [свойство CursorLocation](cursorlocation-property-ado.md) было настроено **на adUseClient.** Для каждого поля, указанного в свойстве **Sort,** будет создан временный индекс, если индекс еще не существует.

Настройка свойства **Sort** для пустой строки сбросит строки в исходный порядок и удалит временные индексы. Существующие индексы не будут удалены.

**Предположим, что набор Recordset** содержит три поля с именем *firstName,* *middleInitial* и *lastName.* Установите свойство **Sort** строке "", которая будет заказать **набор** записей по фамилии в порядке убывания, а затем по первому имени в порядке восхождения. Средний инициал игнорируется.

Ни один поле, на который ссылается строка критериев сортировки, не может быть названо "ASC" или "DESC", так как эти имена конфликтуют с ключевыми словами **ASC** и **DESC.** Дайте поле с противоречивым именем псевдоним, используя ключевое слово **AS** в запросе, возвращаемом **Набором записей.**

Дополнительные сведения о **фильтрации Recordset** см. в разделе Фильтрация результатов в этом разделе.

## <a name="finding-a-specific-record"></a>Поиск определенной записи

ADO предоставляет методы [](seek-method-ado.md) [поиска](find-method-ado.md) и поиска для поиска определенной записи в **наборе записей.** Метод **Find** поддерживается различными поставщиками, но ограничен одним критерием поиска. Метод **Seek** поддерживает поиск по нескольким критериям, но не поддерживается многими поставщиками.

Индексы на полях могут значительно повысить производительность  свойств find и  **filter** свойств объекта **Recordset.** Вы можете создать внутренний индекс объекта **Field,** установив его динамическое свойство [Оптимизируйте.](optimize-property-dynamic-ado.md) Это динамическое свойство добавляется в коллекцию **Свойств** объекта **Field** при задав свойство [CursorLocation](cursorlocation-property-ado.md) **adUseClient.** Помните, что этот индекс является внутренним для ADO — вы не можете получить доступ к нему или использовать его для каких-либо других целей. Кроме того, этот индекс отличается от свойства Index объекта **Recordset.** [](index-property-ado.md)

Метод **Find** быстро находит значение в столбце (поле) **recordset.** Вы часто можете повысить скорость работы метода **Find** в столбце с помощью свойства **Оптимизируйте** для создания индекса на столбце.

Метод **Find** ограничивает поиск содержимым одного поля. Метод **Seek** требует, чтобы у вас был индекс и были другие ограничения. Если вам необходимо искать несколько полей, которые не являются основой индекса, или если поставщик не поддерживает индексы, вы можете ограничить результаты с помощью свойства **Filter** объекта **Recordset.**

### <a name="find"></a>Найти

Метод **Find** ищет **набор записей** для строки, удовлетворяемой указанному критерию. Необязательно можно указать направление поиска, начальной строки и смещения из исходной строки. Если критерий будет соревнуют, то текущая позиция строки устанавливается в найденной записи; в противном случае позиция устанавливается до конца (или начала) **Набора записей** в зависимости от направления поиска.

Для этого критерия может быть задано только имя с одним столбцом. Другими словами, этот метод не поддерживает многоэтабные поиски.

Оператор сравнения для критерия может быть **\>** "(больше, **\<** чем)," (меньше), "=" (равно), \> "=" (больше или равно), \< "=" (меньше или равно), \< \> " (не равно) или "LIKE" (сопоставление шаблонов).

Значением критерия может быть строка, номер плавающей точки или дата. Значения строк делимитированы с одними кавычками или знаками \# "(знак номера) (например, состояние = "WA" или "state = \# \# WA"). Значения дат делимитированы со знаками \# "" (знак номера) (например, "дата начала \_ \> \# 7/22/97"). \#

Если оператор сравнения "like", строковая величина может содержать звездочку () для поиска одного или более случаев любого символа или \* подстройки. Например, "состояние типа \* "M" совпадает с штатами Maine и Massachusetts. Кроме того, для поиска подстройки, содержащееся в значениях, можно также использовать ведущие и следящее звездочки. Например, "state \* like' as \* "" совпадает с Аляской, Арканзасом и Массачусетсом.

Звездочки можно использовать только в конце строки критериев или вместе в начале и конце строки критериев, как показано выше. Звездочка не может быть включена в качестве ведущей подмастерье (' str') или встроенной подстройки \* \* (r'). Это приведет к ошибке.

### <a name="seek-and-index"></a>Поиск и индекс

Используйте метод **Seek** совместно с свойством **Index,** если поставщик поддерживает индексы на **объекте Recordset.** Используйте метод Supports **(adSeek),** чтобы определить, поддерживает ли поставщик seek **и** метод [Supports](supports-method-ado.md) **(adIndex),** чтобы определить, поддерживает ли поставщик индексы. (Например, поставщик [OLE DB для Microsoft Jet](microsoft-ole-db-provider-for-microsoft-jet.md) поддерживает **Seek** and **Index.)**

Если **Seek** не находит нужную строку, ошибки не возникает, и строка находится в конце **recordset.** Установите свойство **Index** в нужный индекс перед выполнением этого метода.

Этот метод поддерживается только с помощью курсоров на стороне сервера. Поиск не поддерживается, когда значение [свойства CursorLocation](cursorlocation-property-ado.md) объекта **Recordset** **является adUseClient.**

Этот метод можно использовать только в том случае, если объект **Recordset** открыт со значением [CommandTypeEnum](commandtypeenum.md) **adCmdTableDirect.**

## <a name="filtering-the-results"></a>Фильтрация результатов

Метод **Find** ограничивает поиск содержимым одного поля. Метод **Seek** требует, чтобы у вас был индекс и были другие ограничения. Если вам необходимо искать несколько полей, которые не являются основой индекса или если поставщик не поддерживает индексы, вы можете ограничить результаты с помощью свойства **Filter** объекта **Recordset.**

Используйте свойство **Filter,** чтобы выборочно отсеить записи в **объекте Recordset.** Фильтрованный **набор записей** становится текущим курсором, а это значит, что записи, не  удовлетворяющие критериям **фильтра,** недоступны в **Наборе** записей до удаления фильтра. Другие свойства, возвращающиеся значения на основе текущего курсора, затронуты, например **AbsolutePosition,** **AbsolutePage,** **RecordCount** и **PageCount.** Это потому, что при настройке свойства **Filter** к определенному значению текущая запись будет перемещаться к первой записи, удовлетворяемой новому значению.

Свойство **Filter** принимает аргумент варианта. Это значение представляет один из трех методов использования свойства **Filter:** строка критериев, константа **FilterGroupEnum** или массив закладок. Дополнительные сведения см. в разделе Фильтрация со строкой критериев, фильтрация с константой и фильтрация с закладки в этом разделе.

> [!NOTE]
> Когда вы знаете выбранные данные, обычно более эффективно  открывать набор записей с помощью SQL, который эффективно фильтрует набор результатов, а не полагается на свойство **Filter.**

Чтобы удалить фильтр из **recordset,** используйте **констант adFilterNone.** Настройка свойства **Filter** для строки нулевой длины ("") имеет тот же эффект, что и использование **константы adFilterNone.**

### <a name="filtering-with-a-criteria-string"></a>Фильтрация со строкой критериев

Строка критериев состоит из оговорок в форме *Значения оператора FieldName* (например, "LastName = "Smith"). Можно создавать сложные положения, согласуя отдельные положения с AND (например, "LastName = "Smith" и FirstName = "John") и OR (например, ). Можно создавать сложные положения, согласуя отдельные положения с AND (например, "LastName = "Smith" и FirstName = "John" и OR (например, "LastName = "Smith" ИЛИ LastName = "Jones"). Используйте следующие рекомендации для строк критериев:

- *Имя fieldName* должно быть допустимым именем поля из **Recordset.** Если имя поля содержит пробелы, необходимо включить имя в квадратные скобки.

- *Оператор* должен быть одним из следующих: \< \> ,, \< =, \> =, \< \> =, или LIKE.

- *Значение* — это значение, с которым вы будете сравнивать значения поля (например, "Smith", \# 8/24/95, \# 12.345 или $50.00). Используйте одиночные кавычка (') со строками и знаками фунта \# () с датами. Для чисел можно использовать десятичных точек, знаки доллара и научные нотации. Если *оператор* является LIKE, *Value* может использовать подкарды. Только знак звездочки \* () и процентный знак (%) подкарды разрешены, и они должны быть последними символами в строке. *Значение* не может быть null.
    
  > [!NOTE]
  > Чтобы включить одиночные кавычка (') в значение *фильтра,* используйте два одиночных кавычка для представления одного. Например, для фильтрации *на O'Malley* строка критериев должна быть "col1 = "O'Malley". 
  > 
  > Чтобы включить одиночные кавычка как в начале, так и в конце значения фильтра, заключив строку в знаки фунта (#). Например, чтобы отфильтровать *строку "1",* строка критериев должна быть "col1 = #'1'#".

Между AND и OR нет приоритета. Клаузула можно сгруппить в скобки. Однако вы не можете сгруппить пункты, к которые присоединяется or, а затем присоединиться к группе с другим пунктом AND, например:

```vb 
 
(LastName = 'Smith' OR LastName = 'Jones') AND FirstName = 'John' 
```

Вместо этого можно создать этот фильтр в качестве:

```vb 
 
(LastName = 'Smith' AND FirstName = 'John') OR (LastName = 'Jones' AND FirstName = 'John') 
```

В пункте LIKE можно использовать подпольную карту в начале и конце шаблона (например, LastName Like ' mit') или только в конце шаблона (например, ) или только в конце \* \* шаблона (например, LastName Like \* 'Smit').

### <a name="filtering-with-a-constant"></a>Фильтрация с помощью константы

Следующие константы доступны для фильтрации **записей.**

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Константа</p></th>
<th><p>Описание</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><strong>adFilterAffectedRecords</strong></p></td>
<td><p>Фильтры для просмотра только записей, в результате последнего вызова <strong>Delete,</strong> <strong>Resync,</strong> <strong>UpdateBatch</strong>или <strong>CancelBatch.</strong></p></td>
</tr>
<tr class="even">
<td><p><strong>adFilterConflictingRecords</strong></p></td>
<td><p>Фильтры для просмотра записей, провалив последнее пакетное обновление.</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFilterFetchedRecords</strong></p></td>
<td><p>Фильтры для просмотра записей в текущем кэше , то есть результаты последнего вызова для получения записей из базы данных.</p></td>
</tr>
<tr class="even">
<td><p><strong>adFilterNone</strong></p></td>
<td><p>Удаляет текущий фильтр и восстанавливает все записи для просмотра.</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFilterPendingRecords</strong></p></td>
<td><p>Фильтры для просмотра только записей, которые изменились, но еще не отправлены на сервер. Применимо только для режима пакетного обновления.</p></td>
</tr>
</tbody>
</table>

<br/>

Константы фильтра упрощают разрешение отдельных конфликтов записей в режиме пакетного обновления, позволяя просматривать, например, только те записи, которые были срабатываны во время последнего вызова метода **UpdateBatch,** как показано в следующем примере:

```vb 
 
'BeginDeleteGroup 
    'add some bogus records 
    With objRs1 
        For i = 0 To 8 
            .AddNew 
            .Fields("CompanyName") = "Shipper Number " & i + 1 
            .Fields("Phone") = "(425) 555-000" & (i + 1) 
            .Update 
        Next i 
         
    're-connect & update 
        .ActiveConnection = GetNewConnection 
        .UpdateBatch 
         
    'filter on newly added records 
        .Filter = adFilterAffectedRecords 
        Debug.Print "Deleting the " & .RecordCount & _ 
                    " records you just added." 
         
    'delete the newly added bogus records 
        .Delete adAffectGroup 
        .Filter = adFilterNone 
        Debug.Print .RecordCount & " records remain." 
         
        .Close 
    End With 
'EndDeleteGroup 
```

### <a name="filtering-with-bookmarks"></a>Фильтрация с помощью закладок

Наконец, вы можете передать в свойство **Filter** массив закладки вариантов. В результате курсор будет содержать только те записи, закладки которых были переданы свойству. В следующем примере кода создается массив закладок из записей в **наборе записей,** которые имеют "B" в поле *ProductName.* Затем он передает массив в свойство **Filter** и отображает сведения о отфильтрованного в результате **наборе записей.**

```vb 
 
'BeginFilterBkmk 
    Dim vBkmkArray() As Variant 
    Dim i As Integer 
 
    'Recordset created using "SELECT * FROM Products" as command. 
    'So, we will check to see if ProductName has a capital B, and 
    'if so, add to the array. 
    i = 0 
    Do While Not objRs.EOF 
        If InStr(1, objRs("ProductName"), "B") Then 
            ReDim Preserve vBkmkArray(i) 
            vBkmkArray(i) = objRs.Bookmark 
            i = i + 1 
            Debug.Print objRs("ProductName") 
        End If 
        objRs.MoveNext 
    Loop 
     
    'Filter using the array of bookmarks. 
    objRs.Filter = vBkmkArray 
     
    objRs.MoveFirst 
    Do While Not objRs.EOF 
        Debug.Print objRs("ProductName") 
        objRs.MoveNext 
    Loop 
    'EndFilterBkmk 
```

## <a name="creating-a-clone-of-a-recordset"></a>Создание клона наборов записей

Используйте метод **Клона** для создания нескольких дублирующихся объектов **Recordset,** особенно если вы хотите сохранить несколько текущих записей в определенном наборе записей. Использование метода **Клона** является более эффективным, чем создание и открытие нового объекта **Recordset** с тем же определением, что и оригинал.

Текущая запись только что созданного клона изначально установлена к первой записи. Текущий указатель записи в клонированном **наборе записей** не синхронизирован с оригиналом или наоборот. Вы можете самостоятельно перемещаться в каждом **наборе записей.**

Изменения, внесенные в один **объект Recordset,** видны во всех его клонах независимо от типа курсора. Однако после выполнения [Requery](requery-method-ado.md) в исходном **Наборе записей** клоны больше не будут синхронизированы с оригиналом.

Закрытие **исходного набора записей** не закрывает его копии и не закрывает копию оригинала или других копий.

Клонировать объект **Recordset** можно только в том случае, если он поддерживает закладки. Значения закладок взаимозаменяемы; то есть ссылка на закладки с одного объекта **Recordset** относится к одной записи в любом из его клонов.

