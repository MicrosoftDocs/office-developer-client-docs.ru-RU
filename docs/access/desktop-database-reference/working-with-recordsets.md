---
title: Работа с наборами записей
TOCTitle: Working with Recordsets
ms:assetid: 9cd52866-2738-8150-381c-eee0b8a6cd36
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249711(v=office.15)
ms:contentKeyID: 48546608
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 0d4b877b680c80a10067e19065facd4ce9e4819d
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32305975"
---
# <a name="working-with-recordsets"></a>Работа с наборами записей

**Область применения**: Access 2013, Office 2013 

Объект **Recordset** имеет встроенные функции, которые делают возможным переупорядочение порядка данных в наборе результатов, поиск определенной записи на основе заставляемого критерия и даже для оптимизации этих операций поиска с помощью индексов. То, доступны ли эти функции для использования, зависит от поставщика, а в некоторых случаях — например, от свойства [Index](index-property-ado.md) — от структуры самого источника данных.

## <a name="arranging-data"></a>Организация данных

Часто наиболее эффективным способом упорядочения данных в наборе **записей** является указание предложения ORDER BY в команде SQL, используемой для возврата результатов в него. Однако может потребоваться изменить порядок данных в наборе **записей,** который уже был создан. Вы можете использовать свойство **Sort,** чтобы установить порядок прохода по строкам **объекта Recordset.** Кроме того, свойство **Filter** определяет, какие строки доступны при проходе по строкам.

Свойство **Sort** задает или возвращает **строку,** которая указывает имена полей в **наборе записей,** по которому необходимо отсортировать. Каждое имя отделяется запятой, за которым при желании следует пробел и ключевое слово **ASC** (сортировать поле в порядке возрастания) или **DESC** (сортировать поле по убыванию). По умолчанию, если ключевое слово не указано, поле сортироваться в порядке возрастания.

Операция сортировки эффективна, так как данные физически не переупорядочены, а просто доступны в порядке, указанном индексом.

Свойство **Sort** требует, чтобы свойство [CursorLocation](cursorlocation-property-ado.md) было установлено в **adUseClient.** Для каждого поля, указанного в свойстве **Sort,** будет создан временный индекс, если индекс еще не существует.

При **установке для** свойства Sort пустой строки строки сбрасываются в исходный порядок и удаляются временные индексы. Существующие индексы не будут удалены.

**Предположим, что набор записей** содержит три поля с именами *firstName,* *middleInitial* и *lastName.* Установите для **свойства Sort** строку "", которая упорядочение набора **записей** по фамилии по убыванию, а затем по имени в порядке возрастания. Средний инициал игнорируется.

Поля, на которые ссылается строка условий сортировки, не могут называться ASC или DESC, так как эти имена конфликтуют с ключевыми словами **ASC** и **DESC.** Придайте полю с конфликтующий именем псевдоним с помощью ключевого слова **AS** в запросе, возвращаемом **набором записей.**

Дополнительные сведения о **фильтрации наборов** записей см. в разделе "Фильтрация результатов" далее в этом разделе.

## <a name="finding-a-specific-record"></a>Поиск определенной записи

ADO предоставляет методы [Find](find-method-ado.md) и [Seek](seek-method-ado.md) для поиска определенной записи в **наборе записей.** Метод **Find** поддерживается различными поставщиками, но ограничен одним критерием поиска. Метод **Seek** поддерживает поиск по нескольким критериям, но не поддерживается многими поставщиками.

Индексы полей могут значительно повысить производительность методов Find объекта **Recordset** и **свойств Sort** и **Filter.**  Вы можете создать внутренний индекс для объекта **Field,** установив его динамическое [свойство Optimize.](optimize-property-dynamic-ado.md) Это динамическое свойство добавляется в  коллекцию **свойств** объекта Field при задав свойству [CursorLocation](cursorlocation-property-ado.md) свойство **adUseClient.** Помните, что этот индекс является внутренним для ADO— вы не можете получить к нему доступ или использовать его для каких-либо других целей. Кроме того, этот индекс отличается от свойства [Index](index-property-ado.md) объекта **Recordset.**

Метод **Find** быстро находит значение в столбце (поле) **recordset.** Часто можно повысить скорость работы метода **Find** со столбцом с помощью свойства **Optimize,** чтобы создать на нем индекс.

Метод **Find** ограничивает поиск содержимым одного поля. Метод **Seek** требует на то, чтобы у вас был индекс и есть другие ограничения. Если требуется искать по нескольким полям, которые не являются основой индекса, или если поставщик не поддерживает индексы, можно ограничить результаты с помощью свойства **Filter** объекта **Recordset.**

### <a name="find"></a>Найти

Метод **Find** выполняет поиск **в наборе записей** строки, которая удовлетворяет указанному критерию. При желании может быть указано направление поиска, начальная строка и смещение от начальной строки. Если критерий установлен, для найденной записи устанавливается текущая позиция строки; в противном случае в зависимости от направления поиска устанавливается конец (или начало) набора записей.

Для этого критерия может быть указано только имя с одним столбцом. Другими словами, этот метод не поддерживает поиск с несколькими столбцами.

Оператор сравнения для критерия может быть " **\>** (больше), **\<** " " (меньше), "=" (равно), " \> =" (больше или равно), " \< =" (меньше или равно), \< \> " " (не равно) или "LIKE" (сопоставление шаблонов).

Значением критерия может быть строка, число с плавающей за точкой или дата. Строки с замещены одними кавычками или \# знаками "( знак номера) (например, "state = "WA"" или "state = \# \# WA"). Значения даты имеют знаки \# "" (знак номера) (например, \_ "дата начала \> \# 7/22/97"). \#

Если оператор сравнения имеет значение "like", строка может содержать звездочку ( ), чтобы найти одно или несколько вхождений любого символа \* или подстроки. Например, "state like 'M \* '" matches Maine andТs. Вы также можете использовать звездочки в конце и в конце, чтобы найти подстроку, содержащееся в значениях. Например, "state like' \* as \* "" соответствует "Юрасия", "Арканзас" и "Досье".

Звездочки можно использовать только в конце строки условия или вместе в начале и конце строки условий, как показано выше. Звезду нельзя использовать в качестве ведущего подкадрического знака (' str') или внедренного \* подкадрического знака \* (r'). Это приведет к ошибке.

### <a name="seek-and-index"></a>Поиск и индекс

Используйте метод **Seek** в сочетании со свойством **Index,** если поставщик поддерживает индексы объекта **Recordset.** Используйте метод [Supports](supports-method-ado.md)**(adSeek),** чтобы определить, поддерживает ли поставщик **поиск,** и метод **Supports(adIndex),** чтобы определить, поддерживает ли поставщик индексы. (Например, поставщик [OLE DB для Microsoft Jet](microsoft-ole-db-provider-for-microsoft-jet.md) поддерживает **Seek** и **Index.)**

Если **Seek** не находит нужную строку, ошибка не возникает, а строка находится в конце **recordset.** Перед **выполнением** этого метода установите для свойства Index нужный индекс.

Этот метод поддерживается только с помощью курсоров на стороне сервера. Seek не поддерживается, если свойство [CursorLocation](cursorlocation-property-ado.md) объекта **Recordset** имеет значение **adUseClient.**

Этот метод можно использовать только в том случае, если объект **Recordset** открыт со значением [CommandTypeEnum](commandtypeenum.md) **adCmdTableDirect.**

## <a name="filtering-the-results"></a>Фильтрация результатов

Метод **Find** ограничивает поиск содержимым одного поля. Метод **Seek** требует на то, чтобы у вас был индекс и есть другие ограничения. Если требуется искать по нескольким полям, которые не являются основой индекса или поставщик не поддерживает индексы, можно ограничить результаты с помощью свойства **Filter** объекта **Recordset.**

Используйте свойство **Filter,** чтобы выборочно отфильтровать записи в **объекте Recordset.** Отфильтрованный **набор** записей становится текущим курсором, то есть записи, не  удовлетворяющие  условиям **фильтра,** недоступны в наборе записей, пока фильтр не будет удален. Другие свойства, возвращающиеся значения на основе текущего курсора, влияют на такие свойства, как **AbsolutePosition,** **AbsolutePage,** **RecordCount** и **PageCount.** Это необходимо потому, что при установке для свойства **Filter** определенного значения текущая запись перемещается в первую запись, которая удовлетворяет новому значению.

Свойство **Filter** принимает аргумент variant. Это значение представляет один из трех методов использования свойства **Filter:** строку условия, константу **FilterGroupEnum** или массив закладок. Дополнительные сведения см. в разделах "Фильтрация со строкой условий", "Фильтрация с константой" и "Фильтрация с закладок" далее в этом разделе.

> [!NOTE]
> Если вы знаете данные, которые нужно выбрать, обычно  эффективнее открыть набор записей с помощью SQL, который эффективно фильтрует набор результатов, а не полагаться на свойство **Filter.**

Чтобы удалить фильтр из **recordset,** используйте константы **adFilterNone.** Установка для **свойства Filter** нулевой длины строки ("") имеет тот же эффект, что и использование константы **adFilterNone.**

### <a name="filtering-with-a-criteria-string"></a>Фильтрация со строкой условий

Строка условий состоит из предложений в виде Значения оператора *FieldName* (например, "LastName = 'Smith'"). Составные предложения можно создать, соединив отдельные предложения с И (например, "LastName = "Smith' AND FirstName = "John'") и OR (например, ). Составные предложения можно создать, соединив отдельные предложения с И (например, "LastName = 'Smith' AND FirstName = 'John'") и OR (например, "LastName = 'Smith' OR LastName = 'Jones'"). Используйте следующие рекомендации для строк условий:

- *FieldName* должно быть допустимым именем поля из **recordset.** Если имя поля содержит пробелы, его необходимо заключить в квадратные скобки.

- *Оператор* должен быть одним из следующих: \< , , \> \< =, \> =, , \< \> =, или LIKE.

- *Значение* — это значение, с которым будут сравниваться значения полей (например, "Smith", \# 8/24/95, \# 12.345 или $50.00). Используйте одиночные кавычка (') со строками и знаками с знаками с знаками \# () с датами. Для чисел можно использовать десятичных знаков, знаки доллара и научной нотации. Если *оператор* имеет значение LIKE, *value* может использовать под wildcards. Только знак звездочки \* () и знак процента (%) поддиаными знаками разрешено, и они должны быть последними символами в строке. *Значение* не может быть null.
    
  > [!NOTE]
  > Чтобы включить одиночная кавычка (') в значение *фильтра,* используйте два одиночных кавычка для представления одного. Например, для фильтрации *по O'Malley* строка условий должна быть "col1 = "O''Malley'". 
  > 
  > Чтобы включить одиночная кавычка в начале и конце значения фильтра, заключив строку в знаки с знаками знака (#). Например, для фильтрации по *"1"* строка условий должна быть "col1 = #'1'#".

Между AND и OR нет приоритета. Предложения можно сгруппить в скобки. Однако вы не можете сгруппить предложения, присоединимые к or, а затем присоединить группу к другому предложению с помощью И, например:

```vb 
 
(LastName = 'Smith' OR LastName = 'Jones') AND FirstName = 'John' 
```

Вместо этого этот фильтр будет создаваться как:

```vb 
 
(LastName = 'Smith' AND FirstName = 'John') OR (LastName = 'Jones' AND FirstName = 'John') 
```

В предложении LIKE можно использовать под шаблон в начале и конце шаблона (например, LastName Like ' mit ') или только в конце шаблона (например, ) или только в конце шаблона \* \* (например, LastName Like 'Smit \* ').

### <a name="filtering-with-a-constant"></a>Фильтрация с помощью константы

Для фильтрации записей доступны следующие **константы.**

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Константа</p></th>
<th><p>Описание</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><strong>adFilterAffectedRecords</strong></p></td>
<td><p>Фильтры для просмотра только записей, на которые влияет последний вызов <strong>Delete,</strong> <strong>Resync,</strong> <strong>UpdateBatch</strong>или <strong>CancelBatch.</strong></p></td>
</tr>
<tr class="even">
<td><p><strong>adFilterConflictingRecords</strong></p></td>
<td><p>Фильтры для просмотра записей, которые не удалось обновить последним пакетным обновлением.</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFilterFetchedRecords</strong></p></td>
<td><p>Фильтры для просмотра записей в текущем кэше, то есть результатов последнего вызова для получения записей из базы данных.</p></td>
</tr>
<tr class="even">
<td><p><strong>adFilterNone</strong></p></td>
<td><p>Удаляет текущий фильтр и восстанавливает все записи для просмотра.</p></td>
</tr>
<tr class="odd">
<td><p><strong>adFilterPendingRecords</strong></p></td>
<td><p>Фильтры для просмотра только тех записей, которые были изменены, но еще не отправлены на сервер. Применимо только для режима пакетного обновления.</p></td>
</tr>
</tbody>
</table>

<br/>

Константы фильтра упрощают разрешение конфликтов отдельных записей в режиме пакетного обновления, позволяя просматривать, например, только те записи, которые были зарегистрированы во время последнего вызова метода **UpdateBatch,** как показано в следующем примере:

```vb 
 
'BeginDeleteGroup 
    'add some bogus records 
    With objRs1 
        For i = 0 To 8 
            .AddNew 
            .Fields("CompanyName") = "Shipper Number " & i + 1 
            .Fields("Phone") = "(425) 555-000" & (i + 1) 
            .Update 
        Next i 
         
    're-connect & update 
        .ActiveConnection = GetNewConnection 
        .UpdateBatch 
         
    'filter on newly added records 
        .Filter = adFilterAffectedRecords 
        Debug.Print "Deleting the " & .RecordCount & _ 
                    " records you just added." 
         
    'delete the newly added bogus records 
        .Delete adAffectGroup 
        .Filter = adFilterNone 
        Debug.Print .RecordCount & " records remain." 
         
        .Close 
    End With 
'EndDeleteGroup 
```

### <a name="filtering-with-bookmarks"></a>Фильтрация с закладок

Наконец, можно передать массив вариантов закладок в свойство **Filter.** В результате курсор будет содержать только те записи, закладка которых была передана свойству. В следующем примере кода создается массив закладок из записей в **наборе recordset,** у которых в поле *ProductName* есть "B". Затем он передает массив в свойство **Filter** и отображает сведения о итоговом отфильтрованный **набор записей.**

```vb 
 
'BeginFilterBkmk 
    Dim vBkmkArray() As Variant 
    Dim i As Integer 
 
    'Recordset created using "SELECT * FROM Products" as command. 
    'So, we will check to see if ProductName has a capital B, and 
    'if so, add to the array. 
    i = 0 
    Do While Not objRs.EOF 
        If InStr(1, objRs("ProductName"), "B") Then 
            ReDim Preserve vBkmkArray(i) 
            vBkmkArray(i) = objRs.Bookmark 
            i = i + 1 
            Debug.Print objRs("ProductName") 
        End If 
        objRs.MoveNext 
    Loop 
     
    'Filter using the array of bookmarks. 
    objRs.Filter = vBkmkArray 
     
    objRs.MoveFirst 
    Do While Not objRs.EOF 
        Debug.Print objRs("ProductName") 
        objRs.MoveNext 
    Loop 
    'EndFilterBkmk 
```

## <a name="creating-a-clone-of-a-recordset"></a>Создание клона recordset

Используйте метод **Clone** для создания нескольких повторяюных объектов **Recordset,** особенно если вы хотите сохранить несколько текущих записей в заданный набор записей. Использование метода **Clone** более эффективно, чем создание и открытие объекта **Recordset** с тем же определением, что и у исходного объекта.

Текущая запись только что созданного клона изначально устанавливается как первая запись. Указатель текущей записи в клонированном наборе **записей** не синхронизируется с исходным или наоборот. Вы можете перемещаться независимо в каждом **наборе записей.**

Изменения, внесенные в один **объект Recordset,** видны во всех его клонах независимо от типа курсора. Однако после выполнения [Requery](requery-method-ado.md) в исходном наборе **записей** клоны больше не будут синхронизироваться с исходным набором.

Закрытие **исходного наборов записей** не закрывает его копии и не закрывает исходную или любую из других копий.

Клонировать объект **Recordset можно** только в том случае, если он поддерживает закладки. Значения закладок являются взаимозаменяемыми; то есть ссылка на закладку из одного объекта **Recordset** ссылается на ту же запись в любом из его клонов.

