---
title: Объект Field (Ссылка на настольные базы данных)
TOCTitle: The Field object
ms:assetid: 55531e04-d74f-6394-df64-1660e5d572ca
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249284(v=office.15)
ms:contentKeyID: 48544926
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 2cbd5752399e5a14f08b7eb944e3a028ba53f561
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32314023"
---
# <a name="field-object"></a>Объект Field

**Область применения**: Access 2013, Office 2013

Каждый **объект Field** обычно соответствует столбцу в таблице баз данных. Однако поле **также может** представлять указатель на другой Набор **записей,** называемый главой. Исключения, такие как столбцы глав, будут освещаться в этом руководстве позже.

Используйте **свойство Value** объектов **Field** для набора или возврата данных для текущей записи. В зависимости от функциональных возможностей, которые предоставляет поставщик, некоторые коллекции, методы или свойства объекта **Field** могут быть недоступны.

С помощью коллекций, методов и свойств объекта **Field** можно сделать следующее:

- Возвращаем имя поля с помощью свойства **Name.**

- Просмотр или изменение данных в поле с помощью свойства **Value.** **Значение** — это свойство по умолчанию объекта **Field.**

- Возвращаем основные характеристики поля с помощью свойств **Type,** **Precision** и **NumericScale.**

- Возврат объявленного размера поля с помощью свойства **DefinedSize.**

- Возврат фактического размера данных в заданное поле с помощью **свойства ActualSize.**

- Определите, какие типы функций поддерживаются для данного поля с помощью коллекции свойств и **свойств** **Attributes.**

- Манипулировать значениями полей, содержащих длинные двоичные или длинные данные символов, с помощью методов **AppendChunk** и **GetChunk.**

- Устранение несоответствий значений полей при пакетном обновлении с помощью свойств **OriginalValue** и **UnderlyingValue,** если поставщик поддерживает пакетные обновления.

## <a name="describing-a-field"></a>Описание поля

В последующих темах будут рассмотрены свойства объекта [Field,](field-object-ado.md) которые представляют информацию, описываемую сам объект **Field,** то есть метаданные о поле. Эти сведения можно использовать для определения схемы **наборов записей.** К этим свойствам относятся **Type,** **DefinedSize** и **ActualSize,** **Name** и **NumericScale** и **Precision.**

## <a name="discovering-the-data-type"></a>Обнаружение типа данных

Свойство **Type** указывает тип данных поля. Описанные константы типа данных, поддерживаемые ADO, описаны в [DataTypeEnum](datatypeenum.md) в ссылке *программиста ADO.*

Для числимые типы плавающей точки, такие **как adNumeric,** вы можете получить дополнительные сведения. Свойство **NumericScale** указывает, сколько цифр справа от десятичной точки будет использоваться для представления значений **для поля**. Свойство **Precision** указывает максимальное число цифр, используемых для представления значений **для поля.**

## <a name="determining-field-size"></a>Определение размера поля

Свойство **DefinedSize используется** для определения емкости данных объекта **Field.**

Используйте **свойство ActualSize,** чтобы вернуть фактическую длину значения **объекта Field.** Для всех полей свойство **ActualSize** является только для чтения. Если ADO не может определить длину значения **объекта Field,** свойство **ActualSize** возвращает **adUnknown.**

Свойства **DefinedSize** и **ActualSize** имеют разные цели. Например, рассмотрим объект **Field** с объявленным типом **adVarChar** и **свойством DefinedSize** 50, содержащим один символ. Возвращаемая значения **свойства ActualSize** — это длина в bytes одного символа.

## <a name="determining-field-contents"></a>Определение содержимого поля

Идентификатор столбца из источника данных представлен **свойством Name** **поля.** Свойство **Value** объекта **Field** возвращает или задает фактическое содержимое данных поля. Это свойство по умолчанию.

Чтобы изменить данные в поле, установите свойство **Value,** равное новому значению правильного типа. Тип курсора должен поддерживать обновления для изменения содержимого поля. Проверка базы данных здесь не проводится в пакетном режиме, поэтому при вызове **UpdateBatch** в таком случае необходимо проверить ошибки. Некоторые поставщики также поддерживают свойства **UnderlyingValue** объекта ADO **Field** и **OriginalValue,** чтобы помочь вам в разрешении конфликтов при попытке выполнения пакетных обновлений. Сведения о том, как разрешить такие конфликты, см. в главе [4. Редактирование данных.](chapter-4-editing-data.md)

> [!NOTE]
> **Значения поля Recordset** невозможно задать при добавлении новых **полей** к **набору записей.** Вместо этого новые **поля** можно примедить к закрытому **набору записей.** Затем **необходимо открыть набор** записей, и только после этого значения могут быть назначены этим **полям.**

## <a name="getting-more-field-information"></a>Получение дополнительных сведений о полях

Объекты ADO имеют два типа свойств: встроенный и динамический. До этого момента обсуждались только встроенные свойства объекта **Field.**

Встроенные свойства — это свойства, реализованные в ADO и сразу доступные любому новому объекту с помощью синтаксиса. Они не отображаются как **объекты Свойства** в коллекции **свойств** объекта.

Динамические свойства определяются поставщиком данных и отображаются в коллекции **Свойств** для соответствующего объекта ADO. Например, свойство, определенное поставщику, может указывать, поддерживает ли объект **Recordset** транзакции или обновление. Эти дополнительные свойства будут отображаться в качестве  **объектов Свойства** в коллекции Свойств объекта **Recordset.** Динамические свойства можно ссылаться только через коллекцию, используя синтаксис MyObject.Properties (0) или MyObject.Properties ("Имя").

Вы не можете удалить свойство любого типа.

**Динамический объект Property** имеет четыре встроенных свойства:

- Свойство **Name** — это строка, определяемая свойством.

- Свойство **Type** — это набор, который указывает тип данных свойства.

- Свойство **Value** — это вариант, содержащий параметр свойства. **Значение** — это свойство по умолчанию для **объекта Property.**

- Свойство **Attributes** — это **длинное** значение, которое указывает характеристики свойства, определенного поставщику.

Коллекция **свойств** для объекта **Field** содержит дополнительные метаданные о поле. Содержимое этой коллекции зависит от поставщика. В следующем примере кода рассматривается коллекция **свойств** образца **Recordset,** представленная в начале этой главы. Сначала он рассматривает содержимое коллекции. В этом коде используется [поставщик OLE DB](microsoft-ole-db-provider-for-sql-server.md)для SQL Server, поэтому коллекция **свойств** содержит сведения, соответствующие этому поставщику.

```vb 
 
'BeginFieldProps 
 Dim objProp As ADODB.Property 
 
 For intLoop = 0 To (objFields.Count - 1) 
 Debug.Print objFields.Item(intLoop).Name 
 
 For Each objProp In objFields(intLoop).Properties 
 Debug.Print vbTab & objProp.Name & " = " & objProp.Value 
 Next objProp 
 Next intLoop 
'EndFieldProps 
```

## <a name="dealing-with-binary-data"></a>Работа с двоичными данными

Используйте метод [AppendChunk](appendchunk-method-ado.md) на **объекте Field,** чтобы заполнить его длинными двоичными или характерными данными. В ситуациях, когда память системы ограничена, можно использовать метод **AppendChunk** для обработки длинных значений частями, а не целиком.

Если бит **adFldLong** в свойстве **Атрибуты** объекта **Field** задан для **True,** для этого поля можно использовать метод **AppendChunk.**

Первый вызов **AppendChunk на** объект **Field** записывает данные в поле, переописав все существующие данные. Последующие **вызовы AppendChunk** добавляются к существующим данным. Если вы примыкаете к одному полю, а затем задайте или считывая значение другого поля в текущей записи, ADO предполагает, что вы закончили приложение данных к первому полю. Если снова вызвать метод **AppendChunk** в первом поле, ADO интерпретирует вызов как новую операцию **AppendChunk** и переопределает существующие данные. Доступ к полям в других **объектах Recordset,** которые не являются клонами первого объекта **Recordset,** не будет нарушать операции **AppendChunk.**

Используйте метод **GetChunk** на **объекте Field,** чтобы получить часть или все его длинные двоичные или данные символов. В ситуациях, когда память системы ограничена, можно использовать метод **GetChunk** для обработки длинных значений частями, а не целиком.

Данные, **возвращаемые вызовом GetChunk,** назначены *переменной.* Если *размер* больше остальных данных, метод **GetChunk** возвращает только оставшиеся данные без переменной заполнения *пустыми* пробелами. Если поле пусто, метод **GetChunk** возвращает значение null.

Каждый **последующий вызов GetChunk** извлекает данные, начиная с того места, где был отключен предыдущий вызов **GetChunk.** Однако при сборе данных из одного поля, а затем задайте или считывайте значение другого поля в текущей записи, ADO предполагает, что вы закончили сбор данных из первого поля. Если снова вызвать метод **GetChunk** в первом поле, ADO интерпретирует вызов как новую операцию **GetChunk** и начинает чтение с самого начала данных. Доступ к полям в других **объектах Recordset,** которые не являются клонами первого объекта **Recordset,** не будет нарушать **операции GetChunk.**

Если бит **adFldLong** в свойстве **Атрибуты** объекта **Field** настроен на **True,** для этого поля можно использовать метод **GetChunk.**

Если нет текущей записи при использовании метода **GetChunk** или **AppendChunk** на объекте **Field,** возникает ошибка 3021 (без текущей записи).

Примеры использования этих методов для управления двоичными данными см. в примере [метода AppendChunk](appendchunk-method-ado.md) и [метода GetChunk](getchunk-method-ado.md) в ссылке на *программиста ADO.*

