---
title: Выполнение параметризованных команд
TOCTitle: Operation of parameterized commands
ms:assetid: 71edbd16-21db-7afa-356b-d8e7afb92b3a
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249456(v=office.15)
ms:contentKeyID: 48545596
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 145a2ee6c3d3c614eb9660350a0bb8a00d44d04c
ms.sourcegitcommit: d6695c94415fa47952ee7961a69660abc0904434
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/17/2019
ms.locfileid: "28717449"
---
# <a name="operation-of-parameterized-commands"></a>Выполнение параметризованных команд

**Применимо к**: Access 2013, Office 2013

Если работа с большой дочерних **записей**, особенно по сравнению с размерами родительского **набора записей**, но для доступа только несколько дочерних главы могут оказаться более эффективно использовать параметризованные команды.

*Без параметров командной* извлекает весь родительских и дочерних **наборов записей**, добавляет столбец с родительским и затем назначает ссылку на главы дочернюю для каждой строки родительского.

*Параметризованный команда* извлекает весь родительского **набора записей**, но извлекаются только главы **набора записей** при доступе к главе столбца. Разницы в стратегии извлечения может привести к значительным производительность.

Например можно указать следующее:

```vb 
 
SHAPE {SELECT * FROM customer} 
 APPEND ({SELECT * FROM orders WHERE cust_id = ?} 
 RELATE cust_id TO PARAMETER 0) 
```

Родительскими и дочерними таблицами иметь имя столбца в распространенных, клиент\_идентификатора *.* *Команда дочерних* имеет заполнитель «?», на который указывает ссылка предложения (то есть, «... ПАРАМЕТР, 0").

> [!NOTE]
> Предложение параметр относится исключительно к синтаксис команды фигуры. Не связан с объектом ADO [параметр](parameter-object-ado.md) или коллекцию [параметров](parameters-collection-ado.md) .

При выполнении команды параметризованный фигуры, происходит следующее:

1.  *Родительский команда* выполняется и возвращает родительский объект **набора записей** из таблицы Customers.

2.  Столбец используется в качестве родительского **набора записей**.

3.  При обращении к ним столбец главы родительской строки *дочерних команда* выполняется с использованием значения customer.cust\_код в качестве значения параметра.

4.  Все строки в наборе строк поставщика данных, созданный на шаге 3 используются для заполнения дочерних **записей**. В этом примере, являющегося все строки в таблице Orders, в котором окно\_идентификатор равен значение customer.cust\_идентификатор. По умолчанию дочерних **записей**s будут кэшироваться на стороне клиента, пока не будут отпущены все ссылки на родительский **набор записей** . Чтобы изменить это поведение, установите **набор записей** [динамического свойства](ado-dynamic-property-index.md)**Кэша дочерних строк** значение **False**.

5.  Ссылку на извлеченных дочерних строк (то есть, главы дочерних **записей**) переводится в столбце главы текущей строки родительского **набора записей**.

6.  Шаги 3 – 5 повторяются при доступе к главе столбец другой строки.

Свойство динамического **Кэша дочерние строки** имеет значение **True** по умолчанию. Поведение кэширования, может изменяться в зависимости от значения параметров запроса. В запросе с одним параметром дочерних **записей** значение данного параметра будут кэшироваться между запросами для дочерних с соответствующими значениями. Это демонстрируется в следующем коде:

```vb
... 
SCmd = "SHAPE {select * from customer} " & _ 
 "APPEND({select * from orders where cust_id = ?} " & _ 
 "RELATE cust_id TO PARAMETER 0) AS chpCustOrder" 
Rst1.Open sCmd, Cnn1 
Set RstChild = Rst1("chpCustOrder").Value 
Rst1.MoveNext ' Next cust_id passed to Param 0, & new rs fetched 
 ' into RstChild. 
Rst1.MovePrevious ' RstChild now holds cached rs, saving round trip. 
... 
```

В запросе с двумя или несколькими параметрами кэшированных дочерних используется только в том случае, если значение параметра соответствует кэшированных значений.

## <a name="parameterized-commands-and-complex-parent-child-relations"></a>Параметризованные команды и сложных родительского дочерние отношения

Для повышения эффективности иерархии типа эквивалентное соединение с помощью параметризованные команды, параметризованные команды можно использовать для поддержки более сложных родительских и дочерних элементов. Рассмотрим маленьким лига базы данных с двумя таблицами: один, состоящий из группы (группы\_код, группы\_имя), а другой игр (даты, домашняя страница\_группы, посетив\_группы).

С помощью иерархии без параметров, нет возможности для их связывания рабочих групп и игры таким образом, что дочерних **записей** для каждой группы содержит полный расписание. Вы можете создать главы (en), которые содержат Домашняя страница расписание или расписание дорогу, но не оба. Причина этого заключается в предложении ссылка ограничивается родительских и дочерних элементов формы (pc1 = cc1) AND (pc2 = pc2). Таким образом, если команда включает «team ссылка\_идентификатор кому домашней\_группы, группы\_код на странице веб-узла\_группы», можно получить только игры где группы самой воспроизведения. Необходимые является "(team\_идентификатор = Домашняя страница\_группы) или (группы\_идентификатор = посетив\_группы)», но поставщик фигура не поддерживает предложение OR.

Чтобы получить результат, можно использовать параметризованные команды. Пример:

```vb 
 
SHAPE {SELECT * FROM teams} 
APPEND ({SELECT * FROM games WHERE home_team = ? OR visiting_team = ?} 
 RELATE team_id TO PARAMETER 0, 
 team_id TO PARAMETER 1) 
```

В этом примере использует более высокий уровень гибкости предложения SQL WHERE для получения результатов.

