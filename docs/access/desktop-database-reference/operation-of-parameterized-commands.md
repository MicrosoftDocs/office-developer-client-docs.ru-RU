---
title: Выполнение параметризованных команд
TOCTitle: Operation of parameterized commands
ms:assetid: 71edbd16-21db-7afa-356b-d8e7afb92b3a
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249456(v=office.15)
ms:contentKeyID: 48545596
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 145a2ee6c3d3c614eb9660350a0bb8a00d44d04c
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32288289"
---
# <a name="operation-of-parameterized-commands"></a>Выполнение параметризованных команд

**Область применения**: Access 2013, Office 2013

Если вы работаете с большим набором записей, особенно по сравнению с размером родительского наборов записей, но вам нужно получить доступ только к нескольким потомков, возможно, будет эффективнее использовать параметризованную команду.

Неконфидентизированная команда извлекает весь родительский и родительский и родительские записи, привносимый столбец главы в родительский, а затем назначает ссылку на связанную родительную главу для каждой родительской строки.  

*Параметризованная команда* извлекает весь родительский набор **записей,** но только набор записей главы при доступе к столбце главы.  Это различие в стратегии ирисовки может дать значительные преимущества производительности.

Например, можно указать следующее:

```vb 
 
SHAPE {SELECT * FROM customer} 
 APPEND ({SELECT * FROM orders WHERE cust_id = ?} 
 RELATE cust_id TO PARAMETER 0) 
```

Родительские и родительские таблицы имеют общее имя столбца, cust \_ *id.* У *child-command* есть заметатель "?", на который ссылается предложение RELATE (то есть"... ПАРАМЕТР 0").

> [!NOTE]
> Предложение PARAMETER относится исключительно к синтаксис команды фигуры. Он не связан ни с объектом параметра [ADO,](parameter-object-ado.md) ни с [коллекцией Parameters.](parameters-collection-ado.md)

При выполнении команды с параметризованной фигурой происходит следующее:

1.  Родительская *команда* выполняется и возвращает родительский набор **записей** из таблицы Customers.

2.  Столбец главы примеется к родительскому **набору записей.**

3.  При доступе к столбцу главы родительской строки выполняется команда *child-command* с использованием значения customer.cust id в качестве значения \_ параметра.

4.  Все строки в наборе строк поставщика данных, созданном на шаге 3, используются для заполнения child **Recordset.** В этом примере это все строки в таблице "Заказы", в которой ид cust равен \_ значению customer.cust \_ id. По умолчанию набор **записей** будет кэшироваться на клиенте, пока не будут освобождены все ссылки на родительский **набор** записей. Чтобы изменить это поведение, установите для динамического свойства **Recordset** [](ado-dynamic-property-index.md)**child Rows кэша** **false.**

5.  Ссылка на полученные строки (то есть главу этого наборов записей) помещается в столбец главы текущей строки родительского **наборов записей.**

6.  Шаги 3–5 повторяются при доступе к столбце главы другой строки.

Динамическое **свойство Cache Child Rows** по умолчанию имеет значение **True.** Поведение кэшинга зависит от значений параметров запроса. В запросе с одним параметром будет кэшироваться набор записей для заданного значения параметра между запросами для детей с этим значением.  Следующий код демонстрирует следующее:

```vb
... 
SCmd = "SHAPE {select * from customer} " & _ 
 "APPEND({select * from orders where cust_id = ?} " & _ 
 "RELATE cust_id TO PARAMETER 0) AS chpCustOrder" 
Rst1.Open sCmd, Cnn1 
Set RstChild = Rst1("chpCustOrder").Value 
Rst1.MoveNext ' Next cust_id passed to Param 0, & new rs fetched 
 ' into RstChild. 
Rst1.MovePrevious ' RstChild now holds cached rs, saving round trip. 
... 
```

В запросе с двумя или более параметрами кэшный child используется только в том случае, если все значения параметров соответствуют кэшным значениям.

## <a name="parameterized-commands-and-complex-parent-child-relations"></a>Параметризованные команды и сложные родительские отношения

Помимо использования параметровных команд для повышения производительности иерархии эквивалентных типов, можно использовать параметризованные команды для поддержки более сложных родительских и родительских отношений. Например, рассмотрим базу данных Little League с двумя таблицами: одна состоит из команд (ид команды, имя команды) и других игр (дата, домашняя команда, команда для \_ \_ \_ \_ посещения).

При использовании иерархии без параметров нет способа связать таблицы команд и игр  таким образом, чтобы в наборе записей для каждой команды было полное расписание. Можно создавать главы, которые содержат домашнее расписание или расписание дороги, но не оба. Это связано с тем, что предложение RELATE ограничивает вас родительскими и родительскими отношениями формы (pc1=cc1) AND (pc2=pc2). Поэтому, если команда включала в себя "ОТносят ид команды к домашней \_ \_ команде, \_ ид команды to visiting team", вы получите только игры, в которых команда играет \_ сама. Вам нужно "(team \_ id=home \_ team) OR (team \_ id=visiting team)", но поставщик shape не поддерживает \_ предложение OR.

Чтобы получить нужный результат, можно использовать параметризованную команду. Например:

```vb 
 
SHAPE {SELECT * FROM teams} 
APPEND ({SELECT * FROM games WHERE home_team = ? OR visiting_team = ?} 
 RELATE team_id TO PARAMETER 0, 
 team_id TO PARAMETER 1) 
```

В этом примере используются более гибкие условия SQL WHERE, чтобы получить нужный результат.

