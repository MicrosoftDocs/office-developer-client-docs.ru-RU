---
title: Выполнение параметризованных команд
TOCTitle: Operation of parameterized commands
ms:assetid: 71edbd16-21db-7afa-356b-d8e7afb92b3a
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249456(v=office.15)
ms:contentKeyID: 48545596
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 145a2ee6c3d3c614eb9660350a0bb8a00d44d04c
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32288289"
---
# <a name="operation-of-parameterized-commands"></a>Выполнение параметризованных команд

**Область применения**: Access 2013, Office 2013

Если вы работаете с большим ребенком **Recordset**, особенно по сравнению с размером родительского **recordset,** но вам необходимо получить доступ только к нескольким детским главам, возможно, будет эффективнее использовать параметризованную команду.

*Непараметровная* команда извлекает все родительские и детские записи, придает столбец главы родительскому, а затем назначает ссылку на связанную детскую главу для каждой родительской строки. 

*Параметризованная команда* извлекает весь родительский набор **записей,** но извлекает только главу **Recordset** при доступе к столбце главы. Это различие в стратегии ирисовки может принести значительные преимущества производительности.

Например, можно указать следующее:

```vb 
 
SHAPE {SELECT * FROM customer} 
 APPEND ({SELECT * FROM orders WHERE cust_id = ?} 
 RELATE cust_id TO PARAMETER 0) 
```

Родительские и детские таблицы имеют общее имя столбца, cust \_ *id.* В *детской команде* есть местоодатель "?" , на который ссылается пункт RELATE (то есть "... PARAMETER 0").

> [!NOTE]
> Пункт PARAMETER относится исключительно к синтаксису командной фигуры. Он не связан ни с объектом ADO [Parameter,](parameter-object-ado.md) ни с коллекцией [Параметры.](parameters-collection-ado.md)

При выполнении команды заданной фигуры возникает следующее:

1.  Родительская *команда* выполняется и возвращает родительский **набор записей** из таблицы Клиенты.

2.  Столбец главы примыкает к родительскому **набору записей.**

3.  При доступе к столбцу главы родительской строки детская команда выполняется с использованием значения customer.cust id в качестве значения  \_ параметра.

4.  Все строки в строке поставщика данных, созданной в шаге 3, используются для заполнения детского **наборов записей.** В этом примере это все строки в таблице Orders, в которой cust id равен значению \_ customer.cust \_ id. По умолчанию ребенок **Recordset** s будет кэшироваться на клиенте до тех пор, пока не будут выпущены все ссылки на родительский **набор записей.** Чтобы изменить это поведение, установите динамическое свойство **Recordset** [](ado-dynamic-property-index.md)**Cache Child Rows** **false**.

5.  Ссылка на извлеченные детские строки (то есть главу детского набора записей) помещается в столбец главы текущего строки родительского **recordset**.

6.  Действия 3-5 повторяются при доступе к столбце главы другой строки.

Динамическое **свойство "Детские строки кэша"** по умолчанию настроено на **Значение True.** Поведение кэшинга зависит от значений параметров запроса. В запросе с одним параметром ребенок **Recordset** для заданного значения параметра будет кэшироваться между запросами для ребенка с этим значением. Следующий код демонстрирует следующее:

```vb
... 
SCmd = "SHAPE {select * from customer} " & _ 
 "APPEND({select * from orders where cust_id = ?} " & _ 
 "RELATE cust_id TO PARAMETER 0) AS chpCustOrder" 
Rst1.Open sCmd, Cnn1 
Set RstChild = Rst1("chpCustOrder").Value 
Rst1.MoveNext ' Next cust_id passed to Param 0, & new rs fetched 
 ' into RstChild. 
Rst1.MovePrevious ' RstChild now holds cached rs, saving round trip. 
... 
```

В запросе с двумя или несколькими параметрами кэшный ребенок используется только в том случае, если все значения параметров соответствуют кэшным значениям.

## <a name="parameterized-commands-and-complex-parent-child-relations"></a>Параметризированные команды и сложные родительские отношения с детьми

Помимо использования параметризированных команд для повышения производительности иерархии типов equi-join можно использовать параметризированные команды для поддержки более сложных отношений между родителями и детьми. Например, рассмотрим базу данных Little League с двумя таблицами: одну из команд (ид команды, имя команды) и другую из игр (дата, домашняя команда, команда \_ \_ \_ \_ посещения).

С помощью непараметровизированной иерархии не существует способа связать команды и таблицы  игр таким образом, чтобы детский набор записей для каждой команды содержит полное расписание. Можно создать главы, содержащие домашнее расписание или расписание дорог, но не оба. Это связано с тем, что пункт RELATE ограничивает отношения между родителями и детьми формы (pc1=cc1) и (pc2=pc2). Таким образом, если ваша команда включала "RELATE team \_ id TO home \_ team, team \_ id TO visiting team", вы получите только игры, в которых команда играла \_ сама. Требуется "(team \_ id=home \_ team) OR (team \_ id=visiting team)", но поставщик shape не поддерживает пункт \_ OR.

Чтобы получить нужный результат, можно использовать параметризованную команду. Пример.

```vb 
 
SHAPE {SELECT * FROM teams} 
APPEND ({SELECT * FROM games WHERE home_team = ? OR visiting_team = ?} 
 RELATE team_id TO PARAMETER 0, 
 team_id TO PARAMETER 1) 
```

В этом примере используются более гибкие положения SQL WHERE, чтобы получить необходимый результат.

