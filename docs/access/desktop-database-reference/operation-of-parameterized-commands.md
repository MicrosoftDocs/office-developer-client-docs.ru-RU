---
title: Выполнение параметризованных команд
TOCTitle: Operation of parameterized commands
ms:assetid: 71edbd16-21db-7afa-356b-d8e7afb92b3a
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249456(v=office.15)
ms:contentKeyID: 48545596
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 145a2ee6c3d3c614eb9660350a0bb8a00d44d04c
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32288289"
---
# <a name="operation-of-parameterized-commands"></a>Выполнение параметризованных команд

**Область применения**: Access 2013, Office 2013

При работе с большим дочерним **набором записей**, особенно по сравнению с размером родительского объекта **Recordset**, но при необходимости можно получить доступ только к нескольким дочерним главам, может оказаться более эффективным использовать параметризованную команду.

*Непараметризованная команда* извлекает и все родительские и дочерние **наборы записей**, добавляет столбец главы к родительскому элементу, а затем назначает ссылку на соответствующую дочернюю главу для каждой родительской строки.

*Параметризованная команда* извлекает весь родительский **набор записей**, но при обращении к столбцу главы извлекается только **набор записей** Chapter. Эта разница в стратегии извлечения может значительно повысить производительность.

Например, вы можете указать следующее:

```vb 
 
SHAPE {SELECT * FROM customer} 
 APPEND ({SELECT * FROM orders WHERE cust_id = ?} 
 RELATE cust_id TO PARAMETER 0) 
```

Родительская и дочерняя таблицы имеют имя столбца Common ID,\_идентификатор Cust *.* *Дочерняя команда* содержит заполнитель "?", к которому относится предложение Relate (то есть "... ПАРАМЕТР 0 ").

> [!NOTE]
> Предложение PARAMETER относится только к синтаксису команды Shape. Он не связан ни с одним объектом [параметров](parameter-object-ado.md) ADO, ни с коллекцией [Parameters](parameters-collection-ado.md) .

При выполнении команды с параметризованной фигурой происходит следующее:

1.  Выполняется *родительская команда* , которая возвращает родительский **набор записей** из таблицы Customers.

2.  Столбец Chapter добавляется к родительскому **набору записей**.

3.  При доступе к столбцу раздела в родительской строке выполняется *дочерняя команда* с использованием значения идентификатора Customer. cust\_в качестве значения параметра.

4.  Все строки в наборе строк поставщика данных, созданном на шаге 3, используются для заполнения дочернего объекта **Recordset**. В этом примере это все строки в таблице Orders, в которых идентификатор Cust\_равен значению идентификатора Customer. cust.\_ По умолчанию Дочерний **набор записей**кэшируется в клиенте до тех пор, пока не будут сняты все ссылки на родительский **набор записей** . Чтобы изменить это поведение, задайте для**дочерних строк в кэше** [динамических свойств](ado-dynamic-property-index.md) **Recordset** **значение false**.

5.  Ссылка на извлеченные дочерние строки (то есть главу дочернего объекта **Recordset**) помещается в столбец Chapter текущей строки родительского **набора записей**.

6.  Шаги 3 – 5 повторяются при доступе к столбцу Chapter другой строки.

Динамическое свойство **Cache дочерние строки** по умолчанию имеет значение **true** . Поведение кэширования зависит от значений параметров запроса. В запросе с одним параметром дочерний **набор записей** для данного значения параметра кэшируется между запросами для дочернего элемента с таким значением. Это показано в следующем коде:

```vb
... 
SCmd = "SHAPE {select * from customer} " & _ 
 "APPEND({select * from orders where cust_id = ?} " & _ 
 "RELATE cust_id TO PARAMETER 0) AS chpCustOrder" 
Rst1.Open sCmd, Cnn1 
Set RstChild = Rst1("chpCustOrder").Value 
Rst1.MoveNext ' Next cust_id passed to Param 0, & new rs fetched 
 ' into RstChild. 
Rst1.MovePrevious ' RstChild now holds cached rs, saving round trip. 
... 
```

В запросе с двумя или более параметрами кэшированный дочерний объект используется только в том случае, если все значения параметров совпадают с кэшированными значениями.

## <a name="parameterized-commands-and-complex-parent-child-relations"></a>Параметризованные команды и сложные родительские дочерние связи

В дополнение к использованию параметризованных команд для улучшения производительности иерархии типов с эквивалентным присоединением, параметризованные команды можно использовать для поддержки более сложных отношений "родитель — потомок". Например, рассмотрим несколько баз данных League с двумя таблицами: одна из которых состоит из групп (идентификатор\_группы, имя\_группы) и других игр (Дата, домашняя\_группа, посещение\_команды).

При использовании непараметризованной иерархии невозможно связать таблицы Teams и Games таким образом, чтобы дочерний **набор записей** для каждой команды содержал полное расписание. Вы можете создавать главы, содержащие расписание для домашнего или дорогого, но не оба. Это связано с тем, что предложение СВЯЗЫВАНИЯ позволяет ограничить связи между родительскими и дочерними элементами формы (PC1 = CC1) и (PC2 = PC2). Таким образом, если команда соотнесения идентификатора\_группы с домашней\_командой, идентификатор\_группы для посещения\_команды, вы получите только те игры, в которых команда воспроизводила себя. Вы хотите: "(идентификатор группы\_= Домашняя\_группа) или (код\_группы = посещение\_команды)", но поставщик фигур не поддерживает предложение OR.

Чтобы получить требуемый результат, можно использовать параметризованную команду. Например:

```vb 
 
SHAPE {SELECT * FROM teams} 
APPEND ({SELECT * FROM games WHERE home_team = ? OR visiting_team = ?} 
 RELATE team_id TO PARAMETER 0, 
 team_id TO PARAMETER 1) 
```

В этом примере показано, как использовать большую гибкость предложения WHERE в SQL, чтобы получить необходимый результат.

