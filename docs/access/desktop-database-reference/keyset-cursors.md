---
title: Курсоры keyset (ссылка на настольные базы данных)
TOCTitle: Keyset cursors
ms:assetid: 4b6e5f90-4413-4fb3-0a08-2cb89d3c61f7
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249236(v=office.15)
ms:contentKeyID: 48544690
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 200b10599683a5b5877952664c04e94b2523cfee
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32290717"
---
# <a name="keyset-cursors"></a>Курсоры наборов ключей

**Область применения**: Access 2013, Office 2013

Курсор наборов ключей обеспечивает функциональность между статическим и динамическим курсором в его способности обнаруживать изменения. Как и статический курсор, он не всегда обнаруживает изменения в составе и порядке набора результатов. Как и динамический курсор, он обнаруживает изменения значений строк в наборе результатов.

Курсоры, управляемые на основе ключей, управляются набором уникальных идентификаторов (клавиш), известных как набор ключей. Ключи построены из набора столбцов, которые однозначно определяют строки в наборе результатов. Набор ключей — это набор ключевых значений из всех строк, возвращаемого в заявлении запроса.

С помощью курсоров, управляемых ключами, ключ строится и сохраняется для каждой строки в курсоре и хранится на клиентской рабочей станции или на сервере. При доступе к каждой строке сохраненный ключ используется для получения текущих значений данных из источника данных. В курсоре, управляемом набором ключей, членство набора результатов замораживается при полной заполнении набора ключей. После этого добавления или обновления, влияющие на членство, не являются частью набора результатов до повторного открытия.

Изменения значений данных (сделанные владельцем набора ключей или другими процессами) видны при прокрутке пользователем набора результатов. Вставки, сделанные за пределами курсора (другими процессами), видны только в том случае, если курсор закрыт и открыт. Вставки, сделанные из курсора, видны в конце набора результатов.

Когда курсор, управляемый ключами, пытается получить удаленную строку, строка отображается как "дыра" в наборе результатов. Ключ для строки существует в наборе ключей, но строка больше не существует в наборе результатов. Если ключевые значения строки обновляются, строка считается удаляемой и вставленной, поэтому такие строки также отображаются как отверстия в наборе результатов. Курсор, управляемый ключами, всегда может обнаруживать строки, удаленные другими процессами, но при желании можно удалить ключи для строк, которые он сам удаляет. Курсоры, управляемые на основе ключей, не могут обнаруживать собственные удаления, так как данные удалены.

Обновление столбца ключей выполняется как удаление старого ключа, за которым следует вставка нового ключа. Новое ключевое значение не отображается, если обновление не было выполнено через курсор. Если обновление было выполнено с помощью курсора, новое ключевое значение отображается в конце набора результатов.

Существует вариант курсоров, управляемых ключами, называемых стандартными курсорами, управляемыми на основе ключей. В стандартном курсоре, управляемом набором ключей, членство строк в наборе результатов и порядок строк фиксируются во время открытия курсора, но при этом видны изменения значений, сделанных владельцем курсора, и совершенных изменений, внесенных другими процессами. Если изменение дисквалифицирует строку для членства или влияет на порядок строки, строка не исчезает и не перемещается, если курсор не закрыт и не открыт. Вставленные данные не отображаются, но изменения существующих данных отображаются по мере получения строк.

Курсор, управляемый на основе ключей, трудно правильно использовать, так как чувствительность к изменениям данных зависит от многих различных обстоятельств, как описано выше. Однако, если ваше приложение не связано с одновременной обновлениями, может программным образом обрабатывать плохие ключи и должно напрямую получать доступ к определенным строкам с ключами, курсор, управляемый ключами, может работать для вас. Используйте **курсор adOpenKeyset** **CursorTypeEnum,** чтобы указать, что вы хотите использовать курсор keyset в ADO.

