---
title: Курсоры Keyset (справочник по базам данных Access для настольных ПК)
TOCTitle: Keyset cursors
ms:assetid: 4b6e5f90-4413-4fb3-0a08-2cb89d3c61f7
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249236(v=office.15)
ms:contentKeyID: 48544690
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 200b10599683a5b5877952664c04e94b2523cfee
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32290717"
---
# <a name="keyset-cursors"></a><span data-ttu-id="e7d79-102">Курсоры наборов ключей</span><span class="sxs-lookup"><span data-stu-id="e7d79-102">Keyset cursors</span></span>

<span data-ttu-id="e7d79-103">**Область применения**: Access 2013, Office 2013</span><span class="sxs-lookup"><span data-stu-id="e7d79-103">**Applies to**: Access 2013, Office 2013</span></span>

<span data-ttu-id="e7d79-104">Курсор наборов клавиш обеспечивает функциональность между статическим и динамическим курсором в возможности обнаружения изменений.</span><span class="sxs-lookup"><span data-stu-id="e7d79-104">The keyset cursor provides functionality between a static and a dynamic cursor in its ability to detect changes.</span></span> <span data-ttu-id="e7d79-105">Как и статический курсор, он не всегда обнаруживает изменения членства и порядка набора результатов.</span><span class="sxs-lookup"><span data-stu-id="e7d79-105">Like a static cursor, it does not always detect changes to the membership and order of the result set.</span></span> <span data-ttu-id="e7d79-106">Как и динамический курсор, он обнаруживает изменения значений строк в наборе результатов.</span><span class="sxs-lookup"><span data-stu-id="e7d79-106">Like a dynamic cursor, it does detect changes to the values of rows in the result set.</span></span>

<span data-ttu-id="e7d79-107">Курсоры на основе набора клавиш управляются набором уникальных идентификаторов (ключей), известных как набор ключей.</span><span class="sxs-lookup"><span data-stu-id="e7d79-107">Keyset-driven cursors are controlled by a set of unique identifiers (keys) known as the keyset.</span></span> <span data-ttu-id="e7d79-108">Ключи построены из набора столбцов, которые уникальным образом идентифицируют строки в наборе результатов.</span><span class="sxs-lookup"><span data-stu-id="e7d79-108">The keys are built from a set of columns that uniquely identify the rows in the result set.</span></span> <span data-ttu-id="e7d79-109">Набор ключей — это набор ключевых значений из всех строк, возвращаемого в запросе.</span><span class="sxs-lookup"><span data-stu-id="e7d79-109">The keyset is the set of key values from all the rows returned by the query statement.</span></span>

<span data-ttu-id="e7d79-110">С помощью курсоров на основе наборов клавиш ключ строится и сохраняется для каждой строки курсора и сохраняется на клиентской рабочей станции или на сервере.</span><span class="sxs-lookup"><span data-stu-id="e7d79-110">With keyset-driven cursors, a key is built and saved for each row in the cursor and stored either on the client workstation or on the server.</span></span> <span data-ttu-id="e7d79-111">При доступе к каждой строке сохраненный ключ используется для получения текущих значений данных из источника данных.</span><span class="sxs-lookup"><span data-stu-id="e7d79-111">When you access each row, the stored key is used to fetch the current data values from the data source.</span></span> <span data-ttu-id="e7d79-112">В курсоре на основе набора клавиш членство в наборе результатов заморозкается, когда набор ключей заполняется полностью.</span><span class="sxs-lookup"><span data-stu-id="e7d79-112">In a keyset-driven cursor, result set membership is frozen when the keyset is fully populated.</span></span> <span data-ttu-id="e7d79-113">После этого добавления или обновления, влияющие на членство, не будут в составе набора результатов до повторного открытия.</span><span class="sxs-lookup"><span data-stu-id="e7d79-113">Thereafter, additions or updates that affect membership are not a part of the result set until it is reopened.</span></span>

<span data-ttu-id="e7d79-114">Изменения значений данных (сделанные владельцем набора ключей или другими процессами) видны, когда пользователь прокручивает набор результатов.</span><span class="sxs-lookup"><span data-stu-id="e7d79-114">Changes to data values (made either by the keyset owner or other processes) are visible as the user scrolls through the result set.</span></span> <span data-ttu-id="e7d79-115">Вставки, сделанные вне курсора (другими процессами), видны только в том случае, если курсор закрыт и открыт повторно.</span><span class="sxs-lookup"><span data-stu-id="e7d79-115">Inserts made outside the cursor (by other processes) are visible only if the cursor is closed and reopened.</span></span> <span data-ttu-id="e7d79-116">Вставки, сделанные из курсора, видны в конце набора результатов.</span><span class="sxs-lookup"><span data-stu-id="e7d79-116">Inserts made from inside the cursor are visible at the end of the result set.</span></span>

<span data-ttu-id="e7d79-117">Когда курсор на основе набора клавиш пытается получить удаленную строку, строка отображается в наборе результатов как "неверная".</span><span class="sxs-lookup"><span data-stu-id="e7d79-117">When a keyset-driven cursor attempts to retrieve a row that has been deleted, the row appears as a "hole" in the result set.</span></span> <span data-ttu-id="e7d79-118">Ключ для строки существует в наборе ключей, но строка больше не существует в наборе результатов.</span><span class="sxs-lookup"><span data-stu-id="e7d79-118">The key for the row exists in the keyset, but the row no longer exists in the result set.</span></span> <span data-ttu-id="e7d79-119">Если значения ключей в строке обновлены, считается, что строка была удалена, а затем вставлена, поэтому такие строки также отображаются в наборе результатов как вехи.</span><span class="sxs-lookup"><span data-stu-id="e7d79-119">If the key values in a row are updated, the row is considered to have been deleted and then inserted, so such rows also appear as holes in the result set.</span></span> <span data-ttu-id="e7d79-120">Курсор на основе наборов клавиш всегда может обнаруживать строки, удаленные другими процессами, но при желании он может удалить ключи для строк, которые он сам удаляет.</span><span class="sxs-lookup"><span data-stu-id="e7d79-120">While a keyset-driven cursor can always detect rows deleted by other processes, it can optionally remove the keys for rows it deletes itself.</span></span> <span data-ttu-id="e7d79-121">Курсоры на основе keyset, которые делают это, не могут обнаружить собственные удаления, так как свидетельство было удалено.</span><span class="sxs-lookup"><span data-stu-id="e7d79-121">Keyset-driven cursors that do this cannot detect their own deletes because the evidence has been removed.</span></span>

<span data-ttu-id="e7d79-122">Обновление ключевого столбца выполняется как удаление старого ключа и вставка нового ключа.</span><span class="sxs-lookup"><span data-stu-id="e7d79-122">An update to a key column operates like a delete of the old key followed by an insert of the new key.</span></span> <span data-ttu-id="e7d79-123">Новое значение ключа не отображается, если обновление не было выполнено с помощью курсора.</span><span class="sxs-lookup"><span data-stu-id="e7d79-123">The new key value is not visible if the update was not made through the cursor.</span></span> <span data-ttu-id="e7d79-124">Если обновление было выполнено с помощью курсора, новое значение клавиши отображается в конце набора результатов.</span><span class="sxs-lookup"><span data-stu-id="e7d79-124">If the update was made through the cursor, the new key value is visible at the end of the result set.</span></span>

<span data-ttu-id="e7d79-125">Существует вариант курсоров на основе наборов клавиш, называемых стандартными курсорами на основе наборов клавиш.</span><span class="sxs-lookup"><span data-stu-id="e7d79-125">There is a variation on keyset-driven cursors called keyset-driven standard cursors.</span></span> <span data-ttu-id="e7d79-126">В стандартном курсоре на основе набора клавиш членство строк в наборе результатов и порядок строк фиксируются во время открытия курсора, но изменения значений, сделанных владельцем курсора и внесенные другими процессами изменения видны.</span><span class="sxs-lookup"><span data-stu-id="e7d79-126">In a keyset-driven standard cursor, the membership of rows in the result set and the order of the rows are fixed at cursor open time, but changes to values that are made by the cursor owner and committed changes made by other processes are visible.</span></span> <span data-ttu-id="e7d79-127">Если изменение аннулирует членство в строке или влияет на порядок строки, она не исчезает и не перемещается, пока курсор не будет закрыт и повторно открыт.</span><span class="sxs-lookup"><span data-stu-id="e7d79-127">If a change disqualifies a row for membership or affects the order of a row, the row does not disappear or move unless the cursor is closed and reopened.</span></span> <span data-ttu-id="e7d79-128">Вставленные данные не отображаются, но изменения существующих данных отображаются при извлечении строк.</span><span class="sxs-lookup"><span data-stu-id="e7d79-128">Inserted data does not appear, but changes to existing data do appear as the rows are fetched.</span></span>

<span data-ttu-id="e7d79-129">Курсор, управляемый набором клавиш, сложно использовать правильно, так как чувствительность к изменениям данных зависит от множества различных условий, как описано выше.</span><span class="sxs-lookup"><span data-stu-id="e7d79-129">The keyset-driven cursor is difficult to use correctly because the sensitivity to data changes depends on many differing circumstances, as described above.</span></span> <span data-ttu-id="e7d79-130">Однако если ваше приложение не связано с одновременно обновляющимися данными, может программным образом обрабатывать неудачные ключи и должно получать прямой доступ к определенным строкам с ключами, курсор на основе наборов клавиш может вам помочь.</span><span class="sxs-lookup"><span data-stu-id="e7d79-130">However, if your application is not concerned with concurrent updates, can programmatically handle bad keys, and must directly access certain keyed rows, the keyset-driven cursor might work for you.</span></span> <span data-ttu-id="e7d79-131">Используйте **adOpenKeyset** **CursorTypeEnum,** чтобы указать, что вы хотите использовать курсор наборов клавиш в ADO.</span><span class="sxs-lookup"><span data-stu-id="e7d79-131">Use the **adOpenKeyset** **CursorTypeEnum** to indicate that you want to use a keyset cursor in ADO.</span></span>

