---
title: Взаимодействие обработчиков событий
TOCTitle: How event handlers work together
ms:assetid: 02122824-881e-0bb8-cba1-c963024790ae
ms:mtpsurl: https://msdn.microsoft.com/library/JJ248788(v=office.15)
ms:contentKeyID: 48542951
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: e772e93f27d6bb5f30d865e3435d4bde6bdc5e73
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32291924"
---
# <a name="how-event-handlers-work-together"></a><span data-ttu-id="8ea88-102">Взаимодействие обработчиков событий</span><span class="sxs-lookup"><span data-stu-id="8ea88-102">How event handlers work together</span></span>

<span data-ttu-id="8ea88-103">**Область применения**: Access 2013, Office 2013</span><span class="sxs-lookup"><span data-stu-id="8ea88-103">**Applies to**: Access 2013, Office 2013</span></span>

<span data-ttu-id="8ea88-104">Если вы не используете Visual Basic, все обработчики событий для событий **Connection** и **Recordset** должны быть реализованы независимо от того, обрабатываете ли вы все события.</span><span class="sxs-lookup"><span data-stu-id="8ea88-104">Unless you are programming in Visual Basic, all event handlers for **Connection** and **Recordset** events must be implemented, regardless of whether you actually process all of the events.</span></span> <span data-ttu-id="8ea88-105">Объем работ по реализации зависит от языка программирования.</span><span class="sxs-lookup"><span data-stu-id="8ea88-105">The amount of implementation work you have to do depends on your programming language.</span></span> <span data-ttu-id="8ea88-106">Более подробную информацию [можно узнать в статье Создание экземпляра события ADO по языку](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado).</span><span class="sxs-lookup"><span data-stu-id="8ea88-106">For more information, see [ADO Event Instantiation by Language](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado).</span></span>

## <a name="paired-event-handlers"></a><span data-ttu-id="8ea88-107">Связанные обработчики событий</span><span class="sxs-lookup"><span data-stu-id="8ea88-107">Paired event handlers</span></span>

<span data-ttu-id="8ea88-108">Каждый обработчик событий будет иметь связанный полный обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="8ea88-108">Each Will event handler has an associated Complete event handler.</span></span> <span data-ttu-id="8ea88-109">Например, когда приложение изменяет значение поля, вызывается обработчик событий **события willchangefield** .</span><span class="sxs-lookup"><span data-stu-id="8ea88-109">For example, when your application changes the value of a field, the **WillChangeField** event handler is called.</span></span> <span data-ttu-id="8ea88-110">Если изменение приемлемо, приложение оставляет параметр **адстатус** без изменений и выполняет операцию.</span><span class="sxs-lookup"><span data-stu-id="8ea88-110">If the change is acceptable, your application leaves the **adStatus** parameter unchanged and the operation is performed.</span></span> <span data-ttu-id="8ea88-111">По завершении операции событие **FieldChangeComplete** уведомляет ваше приложение о завершении операции.</span><span class="sxs-lookup"><span data-stu-id="8ea88-111">When the operation completes, a **FieldChangeComplete** event notifies your application that the operation has finished.</span></span> <span data-ttu-id="8ea88-112">В случае успешного выполнения **адстатус** содержит **адстатусок**; в противном случае **адстатус** содержит **адстатусеррорсоккурред** , и необходимо проверить объект **Error** , чтобы определить причину ошибки.</span><span class="sxs-lookup"><span data-stu-id="8ea88-112">If it completed successfully, **adStatus** contains **adStatusOK**; otherwise, **adStatus** contains **adStatusErrorsOccurred** and you must check the **Error** object to determine the cause of the error.</span></span>

<span data-ttu-id="8ea88-113">При вызове **события willchangefield** может быть определено, что изменение не должно выполняться.</span><span class="sxs-lookup"><span data-stu-id="8ea88-113">When **WillChangeField** is called, you might determine that the change should not be made.</span></span> <span data-ttu-id="8ea88-114">В этом случае задайте для параметра **адстатус** значение **адстатусканцел**.</span><span class="sxs-lookup"><span data-stu-id="8ea88-114">In that case, set **adStatus** to **adStatusCancel**.</span></span> <span data-ttu-id="8ea88-115">Операция отменяется, и событие **FieldChangeComplete** получает значение **адстатус** объекта **адстатусеррорсоккурред**.</span><span class="sxs-lookup"><span data-stu-id="8ea88-115">The operation is canceled and the **FieldChangeComplete** event receives an **adStatus** value of **adStatusErrorsOccurred**.</span></span> <span data-ttu-id="8ea88-116">Объект **Error** содержит **адерроператионканцеллед** , чтобы обработчик **FieldChangeComplete** знал, что операция была отменена.</span><span class="sxs-lookup"><span data-stu-id="8ea88-116">The **Error** object contains **adErrOperationCancelled** so that your **FieldChangeComplete** handler knows that the operation was canceled.</span></span> <span data-ttu-id="8ea88-117">Тем не менее, необходимо проверить значение параметра **адстатус** перед его изменением, так как установка **адстатус** в **адстатусканцел** не оказывает никакого действия, если параметру присвоено значение **адстатускантдени** при вводе в процедуру.</span><span class="sxs-lookup"><span data-stu-id="8ea88-117">However, you need to check the value of the **adStatus** parameter before changing it, because setting **adStatus** to **adStatusCancel** has no effect if the parameter was set to **adStatusCantDeny** on entry to the procedure.</span></span>

<span data-ttu-id="8ea88-118">Иногда операция может вызвать более одного события.</span><span class="sxs-lookup"><span data-stu-id="8ea88-118">Sometimes an operation can raise more than one event.</span></span> <span data-ttu-id="8ea88-119">Например, объект **Recordset** имеет связанные события для изменений **поля** и изменения **записей** .</span><span class="sxs-lookup"><span data-stu-id="8ea88-119">For example, the **Recordset** object has paired events for **Field** changes and **Record** changes.</span></span> <span data-ttu-id="8ea88-120">Когда приложение изменяет значение **поля**, вызывается обработчик событий **события willchangefield** .</span><span class="sxs-lookup"><span data-stu-id="8ea88-120">When your application changes the value of a **Field**, the **WillChangeField** event handler is called.</span></span> <span data-ttu-id="8ea88-121">Если он определяет, что операция может продолжаться, также вызывается обработчик события **события willchangerecord** .</span><span class="sxs-lookup"><span data-stu-id="8ea88-121">If it determines that the operation can continue, the **WillChangeRecord** event handler is also raised.</span></span> <span data-ttu-id="8ea88-122">Если этот обработчик также разрешает продолжение события, выполняется изменение и вызываются обработчики событий **FieldChangeComplete** и **RecordChangeComplete** .</span><span class="sxs-lookup"><span data-stu-id="8ea88-122">If this handler also allows the event to continue, the change is made and the **FieldChangeComplete** and **RecordChangeComplete** event handlers are called.</span></span> <span data-ttu-id="8ea88-123">Порядок, в котором вызываются обработчики событий для определенной операции, не определен, поэтому следует избегать написания кода, зависящего от обработчиков вызовов в определенной последовательности.</span><span class="sxs-lookup"><span data-stu-id="8ea88-123">The order in which the Will event handlers for a particular operation are called is not defined, so you should avoid writing code that depends on calling handlers in a particular sequence.</span></span>

<span data-ttu-id="8ea88-124">В случаях, когда вызывается несколько событий, одно из событий может отменить отложенную операцию.</span><span class="sxs-lookup"><span data-stu-id="8ea88-124">In instances when multiple Will events are raised, one of the events might cancel the pending operation.</span></span> <span data-ttu-id="8ea88-125">Например, если приложение изменяет значение **поля**, обработчики событий **события willchangefield** и **события willchangerecord** обычно вызываются.</span><span class="sxs-lookup"><span data-stu-id="8ea88-125">For example, when your application changes the value of a **Field**, both **WillChangeField** and **WillChangeRecord** event handlers would normally be called.</span></span> <span data-ttu-id="8ea88-126">Однако если операция отменяется в первом обработчике событий, соответствующий полный обработчик вызывается сразу с **адстатусоператионканцеллед**.</span><span class="sxs-lookup"><span data-stu-id="8ea88-126">However, if the operation is canceled in the first event handler, its associated Complete handler is immediately called with **adStatusOperationCancelled**.</span></span> <span data-ttu-id="8ea88-127">Второй обработчик никогда не вызывается.</span><span class="sxs-lookup"><span data-stu-id="8ea88-127">The second handler is never called.</span></span> <span data-ttu-id="8ea88-128">Тем не менее, если первый обработчик событий разрешает выполнение события, вызывается другой обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="8ea88-128">If, however, the first event handler allows the event to proceed, the other event handler will be called.</span></span> <span data-ttu-id="8ea88-129">Если затем эта операция отменяется, все события Complete будут вызываться, как в предыдущих примерах.</span><span class="sxs-lookup"><span data-stu-id="8ea88-129">If it then cancels the operation, both Complete events will be called as in the earlier examples.</span></span>

## <a name="unpaired-event-handlers"></a><span data-ttu-id="8ea88-130">Несвязанные обработчики событий</span><span class="sxs-lookup"><span data-stu-id="8ea88-130">Unpaired event handlers</span></span>

<span data-ttu-id="8ea88-131">Пока состояние, переданное событию, не **адстатускантдени**, вы можете отключить уведомления о событиях для любого события, возвращая **адстатусунвантедевент** в параметре *Status* .</span><span class="sxs-lookup"><span data-stu-id="8ea88-131">As long as the status passed to the event is not **adStatusCantDeny**, you can turn off event notifications for any event by returning **adStatusUnwantedEvent** in the *Status* parameter.</span></span> <span data-ttu-id="8ea88-132">Например, когда обработчик события Complete вызывается в первый раз, можно возвратить **адстатусунвантедевент**.</span><span class="sxs-lookup"><span data-stu-id="8ea88-132">For example, when your Complete event handler is called the first time, you can return **adStatusUnwantedEvent**.</span></span> <span data-ttu-id="8ea88-133">В дальнейшем будут получены только события.</span><span class="sxs-lookup"><span data-stu-id="8ea88-133">You will subsequently receive only Will events.</span></span> <span data-ttu-id="8ea88-134">Тем не менее, некоторые события можно запускать по более чем одной причине.</span><span class="sxs-lookup"><span data-stu-id="8ea88-134">However, some events can be triggered for more than one reason.</span></span> <span data-ttu-id="8ea88-135">В этом случае событие будет иметь параметр *Reason* .</span><span class="sxs-lookup"><span data-stu-id="8ea88-135">In that case, the event will have a *Reason* parameter.</span></span> <span data-ttu-id="8ea88-136">Когда вы возвращаете **адстатусунвантедевент**, вы перестанете получать уведомления для этого события только в том случае, если они появятся по конкретной причине.</span><span class="sxs-lookup"><span data-stu-id="8ea88-136">When you return **adStatusUnwantedEvent**, you will stop receiving notifications for that event only when they occur for that particular reason.</span></span> <span data-ttu-id="8ea88-137">Другими словами, потенциально вы получите уведомление о каждой возможной причине запуска события.</span><span class="sxs-lookup"><span data-stu-id="8ea88-137">In other words, you will potentially receive notification for each possible reason that the event could be triggered.</span></span>

<span data-ttu-id="8ea88-138">Один обработчик событий может быть полезен, если вы хотите изучить параметры, которые будут использоваться в операции.</span><span class="sxs-lookup"><span data-stu-id="8ea88-138">Single Will event handlers can be useful when you want to examine the parameters that will be used in an operation.</span></span> <span data-ttu-id="8ea88-139">Вы можете изменить параметры операции или отменить операцию.</span><span class="sxs-lookup"><span data-stu-id="8ea88-139">You can modify those operation parameters or cancel the operation.</span></span>

<span data-ttu-id="8ea88-140">В качестве альтернативного варианта оставьте уведомление о завершении события включено.</span><span class="sxs-lookup"><span data-stu-id="8ea88-140">Alternatively, leave Complete event notification enabled.</span></span> <span data-ttu-id="8ea88-141">При вызове первого обработчика событий возвратите **адстатусунвантедевент**.</span><span class="sxs-lookup"><span data-stu-id="8ea88-141">When your first Will event handler is called, return **adStatusUnwantedEvent**.</span></span> <span data-ttu-id="8ea88-142">В дальнейшем будут получены только полные события.</span><span class="sxs-lookup"><span data-stu-id="8ea88-142">You will subsequently receive only Complete events.</span></span>

<span data-ttu-id="8ea88-143">Для управления асинхронными операциями можно использовать отдельные полные обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="8ea88-143">Single Complete event handlers can be useful for managing asynchronous operations.</span></span> <span data-ttu-id="8ea88-144">У каждой асинхронной операции есть соответствующее событие Complete.</span><span class="sxs-lookup"><span data-stu-id="8ea88-144">Each asynchronous operation has an appropriate Complete event.</span></span>

<span data-ttu-id="8ea88-145">Например, может потребоваться много времени для заполнения объекта объекта [Recordset](recordset-object-ado.md) большого размера.</span><span class="sxs-lookup"><span data-stu-id="8ea88-145">For example, it can take a long time to populate a large [Recordset](recordset-object-ado.md) object.</span></span> <span data-ttu-id="8ea88-146">Если приложение является соответствующим образом записанным, можно запустить операцию и продолжить обработку.</span><span class="sxs-lookup"><span data-stu-id="8ea88-146">If your application is appropriately written, you can start a operation and continue with other processing.</span></span> <span data-ttu-id="8ea88-147">В конечном итоге будет выведено уведомление, когда **набор записей** заполняется событием **событие executecomplete** .</span><span class="sxs-lookup"><span data-stu-id="8ea88-147">You will eventually be notified when the **Recordset** is populated by an **ExecuteComplete** event.</span></span>

## <a name="single-event-handlers-and-multiple-objects"></a><span data-ttu-id="8ea88-148">Один обработчик событий и несколько объектов</span><span class="sxs-lookup"><span data-stu-id="8ea88-148">Single event handlers and multiple objects</span></span>

<span data-ttu-id="8ea88-149">Гибкость языка программирования, например Microsoft Visual C++, позволяет одному обработчику события обрабатывать несколько объектов.</span><span class="sxs-lookup"><span data-stu-id="8ea88-149">The flexibility of a programming language like Microsoft Visual C++ enables you to have one event handler process events from multiple objects.</span></span> <span data-ttu-id="8ea88-150">Например, можно использовать один обработчик события **Disconnect** для нескольких объектов **Connection** .</span><span class="sxs-lookup"><span data-stu-id="8ea88-150">For example, you could have one **Disconnect** event handler process events from several **Connection** objects.</span></span> <span data-ttu-id="8ea88-151">Если одно из подключений завершено, вызывается обработчик события **Disconnect** .</span><span class="sxs-lookup"><span data-stu-id="8ea88-151">If one of the connections ended, the **Disconnect** event handler would be called.</span></span> <span data-ttu-id="8ea88-152">Можно определить, какое подключение вызвало событие, так как параметр объекта обработчика событий будет задан для соответствующего объекта **подключения** .</span><span class="sxs-lookup"><span data-stu-id="8ea88-152">You could tell which connection caused the event because the event-handler object parameter would be set to the corresponding **Connection** object.</span></span>

> [!NOTE]
> <span data-ttu-id="8ea88-153">Этот метод невозможно использовать в Visual Basic, так как этот язык может сопоставлять только один объект с обработчиком событий.</span><span class="sxs-lookup"><span data-stu-id="8ea88-153">This technique cannot be used in Visual Basic because that language can correlate only one object to an event handler.</span></span>


