---
title: Взаимодействие обработчиков событий
TOCTitle: How event handlers work together
ms:assetid: 02122824-881e-0bb8-cba1-c963024790ae
ms:mtpsurl: https://msdn.microsoft.com/library/JJ248788(v=office.15)
ms:contentKeyID: 48542951
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: e772e93f27d6bb5f30d865e3435d4bde6bdc5e73
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32291924"
---
# <a name="how-event-handlers-work-together"></a><span data-ttu-id="6c534-102">Взаимодействие обработчиков событий</span><span class="sxs-lookup"><span data-stu-id="6c534-102">How event handlers work together</span></span>

<span data-ttu-id="6c534-103">**Область применения**: Access 2013, Office 2013</span><span class="sxs-lookup"><span data-stu-id="6c534-103">**Applies to**: Access 2013, Office 2013</span></span>

<span data-ttu-id="6c534-104">Если вы не программировали в Visual Basic, все обработчики событий для событий **Connection** и **Recordset** должны быть реализованы независимо от того, обрабатываете ли вы все события.</span><span class="sxs-lookup"><span data-stu-id="6c534-104">Unless you are programming in Visual Basic, all event handlers for **Connection** and **Recordset** events must be implemented, regardless of whether you actually process all of the events.</span></span> <span data-ttu-id="6c534-105">Объем работы по реализации зависит от языка программирования.</span><span class="sxs-lookup"><span data-stu-id="6c534-105">The amount of implementation work you have to do depends on your programming language.</span></span> <span data-ttu-id="6c534-106">Дополнительные сведения [см.](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado)в этой теме.</span><span class="sxs-lookup"><span data-stu-id="6c534-106">For more information, see [ADO Event Instantiation by Language](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado).</span></span>

## <a name="paired-event-handlers"></a><span data-ttu-id="6c534-107">Сопряженные обработчики событий</span><span class="sxs-lookup"><span data-stu-id="6c534-107">Paired event handlers</span></span>

<span data-ttu-id="6c534-108">Каждый обработок событий Will имеет связанный обработок события Complete.</span><span class="sxs-lookup"><span data-stu-id="6c534-108">Each Will event handler has an associated Complete event handler.</span></span> <span data-ttu-id="6c534-109">Например, когда ваше приложение изменяет значение поля, будет вызван обработок событий **WillChangeField.**</span><span class="sxs-lookup"><span data-stu-id="6c534-109">For example, when your application changes the value of a field, the **WillChangeField** event handler is called.</span></span> <span data-ttu-id="6c534-110">Если изменение допустимо, приложение оставляет параметр **adStatus** без изменений и выполняется операция.</span><span class="sxs-lookup"><span data-stu-id="6c534-110">If the change is acceptable, your application leaves the **adStatus** parameter unchanged and the operation is performed.</span></span> <span data-ttu-id="6c534-111">После завершения операции событие **FieldChangeComplete** сообщает приложению, что операция завершена.</span><span class="sxs-lookup"><span data-stu-id="6c534-111">When the operation completes, a **FieldChangeComplete** event notifies your application that the operation has finished.</span></span> <span data-ttu-id="6c534-112">Если оно успешно завершено, **adStatus** содержит **adStatusOK;** в **противном случае adStatus** содержит **adStatusErrorsOccurred,** и необходимо проверить объект **Error,** чтобы определить причину ошибки.</span><span class="sxs-lookup"><span data-stu-id="6c534-112">If it completed successfully, **adStatus** contains **adStatusOK**; otherwise, **adStatus** contains **adStatusErrorsOccurred** and you must check the **Error** object to determine the cause of the error.</span></span>

<span data-ttu-id="6c534-113">Когда **будет вызван WillChangeField,** можно определить, что изменение не следует внося.</span><span class="sxs-lookup"><span data-stu-id="6c534-113">When **WillChangeField** is called, you might determine that the change should not be made.</span></span> <span data-ttu-id="6c534-114">В этом случае установите **для adStatus** **adStatusCancel**.</span><span class="sxs-lookup"><span data-stu-id="6c534-114">In that case, set **adStatus** to **adStatusCancel**.</span></span> <span data-ttu-id="6c534-115">Операция отменяется, и событие **FieldChangeComplete** получает значение **adStatus** **adStatusErrorsOccurred.**</span><span class="sxs-lookup"><span data-stu-id="6c534-115">The operation is canceled and the **FieldChangeComplete** event receives an **adStatus** value of **adStatusErrorsOccurred**.</span></span> <span data-ttu-id="6c534-116">Объект **Error** содержит **adErrOperationCancelled,** чтобы обработщик **FieldChangeComplete** знал, что операция была отменена.</span><span class="sxs-lookup"><span data-stu-id="6c534-116">The **Error** object contains **adErrOperationCancelled** so that your **FieldChangeComplete** handler knows that the operation was canceled.</span></span> <span data-ttu-id="6c534-117">Однако перед изменением значения параметра **adStatus** необходимо проверить его, так как установка **значения adStatus** **в adStatusCancel** не действует, если для параметра было задано значение **adStatusCantDeny** при входе в процедуру.</span><span class="sxs-lookup"><span data-stu-id="6c534-117">However, you need to check the value of the **adStatus** parameter before changing it, because setting **adStatus** to **adStatusCancel** has no effect if the parameter was set to **adStatusCantDeny** on entry to the procedure.</span></span>

<span data-ttu-id="6c534-118">Иногда операция вызывает несколько событий.</span><span class="sxs-lookup"><span data-stu-id="6c534-118">Sometimes an operation can raise more than one event.</span></span> <span data-ttu-id="6c534-119">Например, объект **Recordset имеет** сопряженные события для **изменений полей** и **записей.**</span><span class="sxs-lookup"><span data-stu-id="6c534-119">For example, the **Recordset** object has paired events for **Field** changes and **Record** changes.</span></span> <span data-ttu-id="6c534-120">Когда приложение изменяет значение **поля,** будет вызван обработок событий **WillChangeField.**</span><span class="sxs-lookup"><span data-stu-id="6c534-120">When your application changes the value of a **Field**, the **WillChangeField** event handler is called.</span></span> <span data-ttu-id="6c534-121">Если он определяет, что операция может продолжиться, также вызывается обработок события **WillChangeRecord.**</span><span class="sxs-lookup"><span data-stu-id="6c534-121">If it determines that the operation can continue, the **WillChangeRecord** event handler is also raised.</span></span> <span data-ttu-id="6c534-122">Если этот обработчик также разрешает продолжение события, внося изменения, и будут вызваны обработчики событий **FieldChangeComplete** и **RecordChangeComplete.**</span><span class="sxs-lookup"><span data-stu-id="6c534-122">If this handler also allows the event to continue, the change is made and the **FieldChangeComplete** and **RecordChangeComplete** event handlers are called.</span></span> <span data-ttu-id="6c534-123">Порядок вызова обработчиков событий Will для определенной операции не определен, поэтому следует избегать написания кода, который зависит от обработчиков вызовов в определенной последовательности.</span><span class="sxs-lookup"><span data-stu-id="6c534-123">The order in which the Will event handlers for a particular operation are called is not defined, so you should avoid writing code that depends on calling handlers in a particular sequence.</span></span>

<span data-ttu-id="6c534-124">В случаях, когда вызывается несколько событий Will, одно из них может отменить ожидаемую операцию.</span><span class="sxs-lookup"><span data-stu-id="6c534-124">In instances when multiple Will events are raised, one of the events might cancel the pending operation.</span></span> <span data-ttu-id="6c534-125">Например, когда приложение изменяет значение **поля,** обычно будут вызваны обработчики событий **WillChangeField** и **WillChangeRecord.**</span><span class="sxs-lookup"><span data-stu-id="6c534-125">For example, when your application changes the value of a **Field**, both **WillChangeField** and **WillChangeRecord** event handlers would normally be called.</span></span> <span data-ttu-id="6c534-126">Однако если операция отменена в первом обработщике событий, связанный с ней обработок Complete немедленно вызван с **помощью adStatusOperationCancelled.**</span><span class="sxs-lookup"><span data-stu-id="6c534-126">However, if the operation is canceled in the first event handler, its associated Complete handler is immediately called with **adStatusOperationCancelled**.</span></span> <span data-ttu-id="6c534-127">Второй обработок никогда не будет вызван.</span><span class="sxs-lookup"><span data-stu-id="6c534-127">The second handler is never called.</span></span> <span data-ttu-id="6c534-128">Однако если первый обработок событий разрешает продолжить событие, будет вызван другой обработок событий.</span><span class="sxs-lookup"><span data-stu-id="6c534-128">If, however, the first event handler allows the event to proceed, the other event handler will be called.</span></span> <span data-ttu-id="6c534-129">Если после этого операция будет отменена, будут вызваны оба события Complete, как в предыдущих примерах.</span><span class="sxs-lookup"><span data-stu-id="6c534-129">If it then cancels the operation, both Complete events will be called as in the earlier examples.</span></span>

## <a name="unpaired-event-handlers"></a><span data-ttu-id="6c534-130">Обработчики неоплаченных событий</span><span class="sxs-lookup"><span data-stu-id="6c534-130">Unpaired event handlers</span></span>

<span data-ttu-id="6c534-131">Если состояние, переданное событию, не **adStatusCantDeny,** можно отключить уведомления о любом событии, возвращая **adStatusUnwantedEvent** в параметре *Status.*</span><span class="sxs-lookup"><span data-stu-id="6c534-131">As long as the status passed to the event is not **adStatusCantDeny**, you can turn off event notifications for any event by returning **adStatusUnwantedEvent** in the *Status* parameter.</span></span> <span data-ttu-id="6c534-132">Например, когда обработитель события Complete вызван в первый раз, вы можете вернуть **adStatusUnwantedEvent.**</span><span class="sxs-lookup"><span data-stu-id="6c534-132">For example, when your Complete event handler is called the first time, you can return **adStatusUnwantedEvent**.</span></span> <span data-ttu-id="6c534-133">В дальнейшем будут получаться только события Will.</span><span class="sxs-lookup"><span data-stu-id="6c534-133">You will subsequently receive only Will events.</span></span> <span data-ttu-id="6c534-134">Однако некоторые события могут быть вызваны несколькими причинами.</span><span class="sxs-lookup"><span data-stu-id="6c534-134">However, some events can be triggered for more than one reason.</span></span> <span data-ttu-id="6c534-135">В этом случае событие будет иметь параметр *Reason.*</span><span class="sxs-lookup"><span data-stu-id="6c534-135">In that case, the event will have a *Reason* parameter.</span></span> <span data-ttu-id="6c534-136">Когда вы вернетесь **adStatusUnwantedEvent,** вы перестанете получать уведомления об этом событии только в том случае, если они происходят по определенной причине.</span><span class="sxs-lookup"><span data-stu-id="6c534-136">When you return **adStatusUnwantedEvent**, you will stop receiving notifications for that event only when they occur for that particular reason.</span></span> <span data-ttu-id="6c534-137">Другими словами, вы можете получать уведомления по каждой возможной причине, по которой событие может быть инициировано.</span><span class="sxs-lookup"><span data-stu-id="6c534-137">In other words, you will potentially receive notification for each possible reason that the event could be triggered.</span></span>

<span data-ttu-id="6c534-138">Обработчики событий Single Will могут быть полезны при проверке параметров, которые будут использоваться в операции.</span><span class="sxs-lookup"><span data-stu-id="6c534-138">Single Will event handlers can be useful when you want to examine the parameters that will be used in an operation.</span></span> <span data-ttu-id="6c534-139">Вы можете изменить эти параметры операции или отменить операцию.</span><span class="sxs-lookup"><span data-stu-id="6c534-139">You can modify those operation parameters or cancel the operation.</span></span>

<span data-ttu-id="6c534-140">Кроме того, оставьте уведомление о завершении включенным.</span><span class="sxs-lookup"><span data-stu-id="6c534-140">Alternatively, leave Complete event notification enabled.</span></span> <span data-ttu-id="6c534-141">Когда будет вызван первый обработитель событий Will, **вернетесь adStatusUnwantedEvent.**</span><span class="sxs-lookup"><span data-stu-id="6c534-141">When your first Will event handler is called, return **adStatusUnwantedEvent**.</span></span> <span data-ttu-id="6c534-142">В дальнейшем будут получаться только события Complete.</span><span class="sxs-lookup"><span data-stu-id="6c534-142">You will subsequently receive only Complete events.</span></span>

<span data-ttu-id="6c534-143">Обработчики событий с одним завершением могут быть полезны для управления асинхронными операциями.</span><span class="sxs-lookup"><span data-stu-id="6c534-143">Single Complete event handlers can be useful for managing asynchronous operations.</span></span> <span data-ttu-id="6c534-144">Каждая асинхронная операция имеет соответствующее событие Complete.</span><span class="sxs-lookup"><span data-stu-id="6c534-144">Each asynchronous operation has an appropriate Complete event.</span></span>

<span data-ttu-id="6c534-145">Например, заполнение большого объекта [Recordset](recordset-object-ado.md) может занять много времени.</span><span class="sxs-lookup"><span data-stu-id="6c534-145">For example, it can take a long time to populate a large [Recordset](recordset-object-ado.md) object.</span></span> <span data-ttu-id="6c534-146">Если приложение написано надлежащим образом, можно запустить операцию и продолжить другую обработку.</span><span class="sxs-lookup"><span data-stu-id="6c534-146">If your application is appropriately written, you can start a operation and continue with other processing.</span></span> <span data-ttu-id="6c534-147">Со временем вы будете уведомлены, когда **набор записей** будет заполнен **событием ExecuteComplete.**</span><span class="sxs-lookup"><span data-stu-id="6c534-147">You will eventually be notified when the **Recordset** is populated by an **ExecuteComplete** event.</span></span>

## <a name="single-event-handlers-and-multiple-objects"></a><span data-ttu-id="6c534-148">Обработчики одного события и несколько объектов</span><span class="sxs-lookup"><span data-stu-id="6c534-148">Single event handlers and multiple objects</span></span>

<span data-ttu-id="6c534-149">Гибкость языка программирования, например Microsoft Visual C++, позволяет использовать одно событие обработки событий из нескольких объектов.</span><span class="sxs-lookup"><span data-stu-id="6c534-149">The flexibility of a programming language like Microsoft Visual C++ enables you to have one event handler process events from multiple objects.</span></span> <span data-ttu-id="6c534-150">Например, можно иметь одно событие **обработки обработки** события Disconnect из нескольких **объектов Connection.**</span><span class="sxs-lookup"><span data-stu-id="6c534-150">For example, you could have one **Disconnect** event handler process events from several **Connection** objects.</span></span> <span data-ttu-id="6c534-151">Если одно из подключений завершилось, будет вызван обработок события **Disconnect.**</span><span class="sxs-lookup"><span data-stu-id="6c534-151">If one of the connections ended, the **Disconnect** event handler would be called.</span></span> <span data-ttu-id="6c534-152">Можно было сообщить, какое подключение вызвало событие, так как для параметра объекта обработки событий будет задан соответствующий **объект Connection.**</span><span class="sxs-lookup"><span data-stu-id="6c534-152">You could tell which connection caused the event because the event-handler object parameter would be set to the corresponding **Connection** object.</span></span>

> [!NOTE]
> <span data-ttu-id="6c534-153">Этот метод нельзя использовать в Visual Basic так как этот язык может сопоставляет только один объект с обработом событий.</span><span class="sxs-lookup"><span data-stu-id="6c534-153">This technique cannot be used in Visual Basic because that language can correlate only one object to an event handler.</span></span>


