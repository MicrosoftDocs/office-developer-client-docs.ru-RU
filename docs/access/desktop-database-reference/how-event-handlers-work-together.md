---
title: Взаимодействие обработчиков событий
TOCTitle: How event handlers work together
ms:assetid: 02122824-881e-0bb8-cba1-c963024790ae
ms:mtpsurl: https://msdn.microsoft.com/library/JJ248788(v=office.15)
ms:contentKeyID: 48542951
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: e772e93f27d6bb5f30d865e3435d4bde6bdc5e73
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32291924"
---
# <a name="how-event-handlers-work-together"></a>Взаимодействие обработчиков событий

**Область применения**: Access 2013, Office 2013

Если вы не используете Visual Basic, все обработчики событий для событий **Connection** и **Recordset** должны быть реализованы независимо от того, обрабатываете ли вы все события. Объем работ по реализации зависит от языка программирования. Более подробную информацию [можно узнать в статье Создание экземпляра события ADO по языку](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado).

## <a name="paired-event-handlers"></a>Связанные обработчики событий

Каждый обработчик событий будет иметь связанный полный обработчик событий. Например, когда приложение изменяет значение поля, вызывается обработчик событий **события willchangefield** . Если изменение приемлемо, приложение оставляет параметр **адстатус** без изменений и выполняет операцию. По завершении операции событие **FieldChangeComplete** уведомляет ваше приложение о завершении операции. В случае успешного выполнения **адстатус** содержит **адстатусок**; в противном случае **адстатус** содержит **адстатусеррорсоккурред** , и необходимо проверить объект **Error** , чтобы определить причину ошибки.

При вызове **события willchangefield** может быть определено, что изменение не должно выполняться. В этом случае задайте для параметра **адстатус** значение **адстатусканцел**. Операция отменяется, и событие **FieldChangeComplete** получает значение **адстатус** объекта **адстатусеррорсоккурред**. Объект **Error** содержит **адерроператионканцеллед** , чтобы обработчик **FieldChangeComplete** знал, что операция была отменена. Тем не менее, необходимо проверить значение параметра **адстатус** перед его изменением, так как установка **адстатус** в **адстатусканцел** не оказывает никакого действия, если параметру присвоено значение **адстатускантдени** при вводе в процедуру.

Иногда операция может вызвать более одного события. Например, объект **Recordset** имеет связанные события для изменений **поля** и изменения **записей** . Когда приложение изменяет значение **поля**, вызывается обработчик событий **события willchangefield** . Если он определяет, что операция может продолжаться, также вызывается обработчик события **события willchangerecord** . Если этот обработчик также разрешает продолжение события, выполняется изменение и вызываются обработчики событий **FieldChangeComplete** и **RecordChangeComplete** . Порядок, в котором вызываются обработчики событий для определенной операции, не определен, поэтому следует избегать написания кода, зависящего от обработчиков вызовов в определенной последовательности.

В случаях, когда вызывается несколько событий, одно из событий может отменить отложенную операцию. Например, если приложение изменяет значение **поля**, обработчики событий **события willchangefield** и **события willchangerecord** обычно вызываются. Однако если операция отменяется в первом обработчике событий, соответствующий полный обработчик вызывается сразу с **адстатусоператионканцеллед**. Второй обработчик никогда не вызывается. Тем не менее, если первый обработчик событий разрешает выполнение события, вызывается другой обработчик событий. Если затем эта операция отменяется, все события Complete будут вызываться, как в предыдущих примерах.

## <a name="unpaired-event-handlers"></a>Несвязанные обработчики событий

Пока состояние, переданное событию, не **адстатускантдени**, вы можете отключить уведомления о событиях для любого события, возвращая **адстатусунвантедевент** в параметре *Status* . Например, когда обработчик события Complete вызывается в первый раз, можно возвратить **адстатусунвантедевент**. В дальнейшем будут получены только события. Тем не менее, некоторые события можно запускать по более чем одной причине. В этом случае событие будет иметь параметр *Reason* . Когда вы возвращаете **адстатусунвантедевент**, вы перестанете получать уведомления для этого события только в том случае, если они появятся по конкретной причине. Другими словами, потенциально вы получите уведомление о каждой возможной причине запуска события.

Один обработчик событий может быть полезен, если вы хотите изучить параметры, которые будут использоваться в операции. Вы можете изменить параметры операции или отменить операцию.

В качестве альтернативного варианта оставьте уведомление о завершении события включено. При вызове первого обработчика событий возвратите **адстатусунвантедевент**. В дальнейшем будут получены только полные события.

Для управления асинхронными операциями можно использовать отдельные полные обработчики событий. У каждой асинхронной операции есть соответствующее событие Complete.

Например, может потребоваться много времени для заполнения объекта объекта [Recordset](recordset-object-ado.md) большого размера. Если приложение является соответствующим образом записанным, можно запустить операцию и продолжить обработку. В конечном итоге будет выведено уведомление, когда **набор записей** заполняется событием **событие executecomplete** .

## <a name="single-event-handlers-and-multiple-objects"></a>Один обработчик событий и несколько объектов

Гибкость языка программирования, например Microsoft Visual C++, позволяет одному обработчику события обрабатывать несколько объектов. Например, можно использовать один обработчик события **Disconnect** для нескольких объектов **Connection** . Если одно из подключений завершено, вызывается обработчик события **Disconnect** . Можно определить, какое подключение вызвало событие, так как параметр объекта обработчика событий будет задан для соответствующего объекта **подключения** .

> [!NOTE]
> Этот метод невозможно использовать в Visual Basic, так как этот язык может сопоставлять только один объект с обработчиком событий.


