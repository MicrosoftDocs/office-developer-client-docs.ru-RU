---
title: Сведения HelloData (ссылка на настольные базы данных)
TOCTitle: HelloData details
ms:assetid: db51e15c-1b5b-c64a-2f84-34dd0e78c6cf
ms:mtpsurl: https://msdn.microsoft.com/library/JJ250105(v=office.15)
ms:contentKeyID: 48548103
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 78b04b74d4e2b8d9c215235d6e7ccebed4fa2ef2
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32292001"
---
# <a name="hellodata-details"></a>Сведения о HelloData


**Область применения**: Access 2013, Office 2013

Приложение HelloData проходит через основные операции типичного приложения ADO: получение, изучение, редактирование и обновление данных. При запуске приложения нажмите первую кнопку Get **Data**. В этом случае будет работать подраутин GetData().

## <a name="getdata"></a>GetData

GetData помещает допустимую строку подключения в переменную уровня модуля *m \_ sConnStr.* Дополнительные сведения о строках подключения см. в [строке Создание строки подключения.](creating-the-connection-string.md)

Назначьте обработчик ошибок с помощью Visual Basic **OnError.** Дополнительные сведения об обработке ошибок в ADO см. в главе [6. Обработка ошибок.](chapter-6-error-handling.md) Создается  новый объект Подключения, и свойство **CursorLocation** задано **для adUseClient,** так как в примере HelloData создается *отключенный набор записей.* Это означает, что после получения данных из источника данных физическое подключение к источнику данных будет нарушено, но вы все равно можете работать с данными, которые кэшироваться локально в объекте **Recordset.**

После открытия подключения назначьте строку SQL переменной (sSQL). Затем мгновенный доступ к новому **объекту Recordset** m \_ oRecordset1. В следующей строке кода откройте **набор записей** по существующему **подключению**, проходя. В следующей строке кода откройте **набор записей** по существующему подключению, передавая sSQL в качестве источника **recordset.** Вы помогаете ADO определить, что строка SQL, которую вы передали в качестве источника для **Recordset,** является текстовым определением команды, передав **adCmdText** в окончательном аргументе методу **Recordset** **Open.** Эта строка также задает **LockType** и **CursorType,** связанные с **Набором записей.**

Следующая строка кода задает свойство **MarshalOptions,** равное **adMarshalModifiedOnly.** **MarshalOptions указывает,** какие записи следует маршалить до среднего уровня (или веб-сервера). Дополнительные сведения о маршалинге см. в документации com. При использовании **adMarshalModifiedOnly** с клиентской стороной курсора [(CursorLocation](cursorlocation-property-ado.md)  =  **adUseClient)** на средний уровень записывают только записи, измененные на клиенте. Настройка **marshalOptions** **для adMarshalModifiedOnly** может повысить производительность, так как количество строк меньше.

Затем отключите **набор записей,** установив его свойство **ActiveConnection,** равное **Nothing**. Дополнительные сведения см. в раздел [Отключение](disconnecting-and-reconnecting-the-recordset.md) и подключение к набору записей в главе 5: Обновление и сохраняющиеся данные.

Закрой подключение к источнику данных и уничтожив существующий объект **Connection,** освободив тем самым потребляемых ресурсов.

На заключительном этапе  необходимо установить набор записей в качестве центра **dataSource** для управления сеткой  данных Майкрософт в форме, чтобы можно было легко отображать данные из набора записей в форме.

Щелкните вторую кнопку " **Изучите данные.** В этом случае выполняется субраутин ExamineData.

## <a name="examinedata"></a>ExamineData

ExamineData использует различные методы и свойства объекта **Recordset** для отображения сведений о данных в **Наборе записей.** Он сообщает о количестве записей с помощью свойства **RecordCount.** Он проходит циклы через **Набор записей** и печатает значение свойства **AbsolutePosition** в текстовом окне отображения формы. Кроме того, в цикле значение свойства **Bookmark** для третьей записи помещается в переменную варианта *vBookmark* для более позднего использования.

Обычно перемещается непосредственно к третьей записи с помощью переменной закладки, которую она хранила ранее. В обычной процедуре вызывается подпрограмма WalkFields, которая проходит циклы через коллекцию **Поля** в **Наборе** записей и отображает сведения о каждом **поле** в коллекции.

Наконец, в ExamineData используется свойство **Filter** в **наборе записей** для проверки только этих записей с помощью categoryId, равного 2. Результат применения этого фильтра сразу же отображается в сетке отображения на форме.

Дополнительные сведения о функциональных возможностях, показанных в субраутине ExamineData, см. в главе [3. Изучение данных.](chapter-3-examining-data.md)

Далее нажмите третью кнопку Изменить **данные**. При этом будет работать подраутин EditData.

## <a name="editdata"></a>EditData

Когда код входит в субраутин EditData, набор **Записей** по-прежнему фильтруется на categoryId, равном 2, поэтому видны только те элементы, которые соответствуют критериям фильтра. Он сначала проходит циклы через **Набор записей** и увеличивает цену каждого видимого элемента в **Наборе** записей на 10 процентов. Значение поля **Цена** меняется, установив свойство **Value** для этого поля, равное новой допустимой сумме.

Помните, что **набор Recordset** отключен от источника данных. Изменения, внесенные в EditData, внося только в локализованную кэшированную копию данных. Дополнительные сведения см. [в главе 4. Редактирование данных.](chapter-4-editing-data.md)

Изменения не будут внесены в источник данных, пока не нажмете четвертую кнопку Update **Data**. При этом будет работать подраутин UpdateData.

## <a name="updatedata"></a>UpdateData

UpdateData сначала удаляет фильтр, который был применен к **Набору записей.** Код удаляется и сбрасывается в виде **DataSource** для Microsoft Bound DataGrid в  форме, чтобы в сетке появился неотсортованный набор записей.

Затем код проверяет, можно ли двигаться назад в **Наборе** записей с помощью метода **Supports** с **аргументом adMovePrevious.**

Обычно перемещается к первой записи с помощью метода **MoveFirst** и отображает исходные и текущие значения поля с использованием свойств **OriginalValue** и **Value** объекта **Field.** Эти свойства, а также свойство **UnderlyingValue** (не используется здесь), обсуждаются в главе [5: Обновление и сохраняющиеся данные](chapter-5-updating-and-persisting-data.md).

Далее создается новый объект **Connection,** который используется для повторного подключения к источнику данных. Вы повторно подключили **набор записей** к  источнику данных, установив новое подключение в качестве **ActiveConnection** для **наборов записей.** Чтобы отправить обновления на сервер, код вызывает **UpdateBatch** в **Наборе записей.**

Если пакетное обновление будет успешным, переменная флага на уровне модуля будет настроена на значение True. Это напомнит вам позже, чтобы очистить все изменения, внесенные в базу данных.

Наконец, код возвращается к первой записи **в Recordset** и отображает исходные и текущие значения. Значения одинаковы после вызова в **UpdateBatch.**

Дополнительные сведения об обновлении данных, в том числе о  том, что делать, если данные на сервере меняются во время отключения вашего наборов записей, см. в главе [5: Обновление и сохраняющихся данных.](chapter-5-updating-and-persisting-data.md)

## <a name="form_unload"></a>\_Разгрузка формы

\_Субраутин разгрузки формы важен по нескольким причинам. Во-первых, так как это пример приложения, Form Unload очищает изменения, внесенные в базу данных перед \_ выходом приложения. Во-вторых, код показывает, как команда может выполняться непосредственно с открытого объекта **Подключения** с помощью **метода Execute.** Наконец, в нем показан пример выполнения запроса, не возвращаемого строками (запрос UPDATE) в отношении источника данных.

