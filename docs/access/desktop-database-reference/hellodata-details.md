---
title: Сведения о HelloData (справочник по базам данных Access для настольных ПК)
TOCTitle: HelloData details
ms:assetid: db51e15c-1b5b-c64a-2f84-34dd0e78c6cf
ms:mtpsurl: https://msdn.microsoft.com/library/JJ250105(v=office.15)
ms:contentKeyID: 48548103
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 78b04b74d4e2b8d9c215235d6e7ccebed4fa2ef2
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32292001"
---
# <a name="hellodata-details"></a>Сведения о HelloData


**Область применения**: Access 2013, Office 2013

Приложение HelloData по шагам проходит основные операции типичного приложения ADO: получение, изучение, редактирование и обновление данных. При запуске приложения нажмите первую кнопку **"Получить данные".** Будет запускаться подкатаута GetData().

## <a name="getdata"></a>GetData

GetData помещает допустимую строку подключения в переменную уровня модуля *m \_ sConnStr.* Дополнительные сведения о строках подключений см. в [подкассылке "Создание строки подключения".](creating-the-connection-string.md)

Назначьте обработчик ошибок с помощью Visual Basic **OnError.** Дополнительные сведения об обработке ошибок в ADO см. в главе [6" "Обработка ошибок".](chapter-6-error-handling.md) Создается **новый объект Connection,** свойство **CursorLocation** имеет свойство **adUseClient,** так как в примере HelloData создается отключенный *набор записей.* Это означает, что после извлечения данных из источника данных физическое подключение к источнику данных будет нарушено, но вы все равно сможете работать с данными, кэшными локально в **объекте Recordset.**

После открытия подключения назначьте строку SQL переменной (sSQL). Затем выдают новый объект **Recordset,** m \_ oRecordset1. В следующей строке кода откройте **набор записей** по существующему **подключению,** передав его. В следующей строке кода откройте набор **записей** по существующему **подключению,** передав sSQL в качестве источника **recordset.** ADO помогает определить, что строка SQL, переданная в качестве источника для **recordset,** является текстовым определением команды, передав **adCmdText** в последний аргумент методу **Recordset** **Open.** Эта строка также задает **LockType** и **CursorType,** связанные с **набором записей.**

Следующая строка кода задает свойство **MarshalOptions** равным **adMarshalModifiedOnly.** **MarshalOptions** указывает, какие записи следует маршалировать на средний уровень (или веб-сервер). Дополнительные сведения о маршалинге см. в документации COM. При использовании **adMarshalModifiedOnly** с курсором на стороне клиента [(CursorLocation](cursorlocation-property-ado.md)  =  **adUseClient)** только записи, измененные на клиенте, записывают обратно на средний уровень. Установка **для MarshalOptions** **параметра adMarshalModifiedOnly** может повысить производительность, так как маршалуется меньше строк.

Затем отключите **recordset,** установив для свойства **ActiveConnection** свойство **Nothing.** Дополнительные сведения см. в подключении [и](disconnecting-and-reconnecting-the-recordset.md) повторном подключении наборов записей в главе 5 "Обновление и сохраняемая информация".

Закроете подключение к источнику данных и уничтожите существующий объект **Connection,** тем самым освободив ресурсы, которые он потреблял.

Последний шаг — установить набор **записей** в качестве **DataSource** для microsoft DataBound Grid Control в форме, чтобы можно было легко отображать данные из набора **записей** в форме.

Нажмите вторую кнопку **"Проверить данные".** При этом выполняется подкатаута ExamineData.

## <a name="examinedata"></a>ExamineData

ExamineData использует различные методы и свойства объекта **Recordset** для отображения сведений о данных в **наборе записей.** Он сообщает количество записей с помощью свойства **RecordCount.** Он проходит по **набору записей** и печатает значение свойства **AbsolutePosition** в текстовом поле отображения формы. Кроме того, во время цикла значение свойства **Bookmark** для третьей записи помещается в переменную variant, *vBookmark,* для использования в дальнейшем.

Подпрограмма возвращается непосредственно к третьей записи с помощью сохраненной ранее переменной закладки. Подпрограмма вызывает подпрограмму WalkFields, которая проходит по коллекции **Fields** в **наборе Recordset** и отображает сведения о каждом **поле** в коллекции.

Наконец, ExamineData использует свойство **Filter** объекта **Recordset,** чтобы отфильтровать только те записи со свойством CategoryId, равным 2. Результат применения этого фильтра сразу же отображается в сетке отображения формы.

Дополнительные сведения о функциях, показанных в подкатаутах ExamineData, см. в главе [3 "Изучение данных".](chapter-3-examining-data.md)

Затем нажмите третью кнопку **"Изменить данные".** Будет запускаться подкатаута EditData.

## <a name="editdata"></a>EditData

Когда код входит в поднатуру EditData, набор записей по-прежнему фильтруется по CategoryId равным 2, поэтому видны только элементы, которые соответствуют условиям фильтра.  Сначала он просматривает набор **записей** и увеличивает цену каждого видимого элемента в **наборе записей** на 10 процентов. Значение поля **"Цена"** меняется путем установки свойства **Value** для этого поля на новую допустимую сумму.

Помните, **что набор записей** отключен от источника данных. Изменения, внесенные в EditData, внося только в локально кэшированную копию данных. Дополнительные сведения см. в [главе 4 "Изменение данных".](chapter-4-editing-data.md)

Изменения не будут внесены в источник данных, пока вы не нажмете четвертую кнопку **"Обновить данные".** Будет запускаться поднауть UpdateData.

## <a name="updatedata"></a>UpdateData

UpdateData сначала удаляет фильтр, примененный к **набору записей.** Код удаляет и сбрасывается в качестве **DataSource** для связанного с Microsoft DataGrid  в форме, чтобы в сетке появился неотформаметрованный набор записей.

Затем код проверяет, можно ли перемещаться назад в наборе **записей** с помощью метода **Supports** с аргументом **adMovePrevious.**

Процедура перемещается к первой записи с помощью метода **MoveFirst** и отображает исходные и текущие значения поля, используя свойства **OriginalValue** и **Value** объекта **Field.** Эти свойства, а также свойство **UnderlyingValue** (не используется здесь) обсуждаются в главе 5" "Обновление и [сохраняемая информация".](chapter-5-updating-and-persisting-data.md)

Затем создается новый **объект Connection,** который используется для повторной передачи подключения к источнику данных. Вы повторно подключили **набор записей** к источнику данных, установив новое **подключение** в качестве **ActiveConnection** для **recordset.** Чтобы отправить обновления на сервер, код вызывает **UpdateBatch** в **Наборе записей.**

Если пакетное обновление успешно, переменная флага на уровне модуля имеет значение True. Это напомню позже, что необходимо очистить все изменения, внесенные в базу данных.

Наконец, код возвращается к первой записи в **наборе записей** и отображает исходные и текущие значения. Значения одинаковы после вызова **UpdateBatch.**

Дополнительные сведения об обновлении данных, в том числе о  том, что делать, когда данные на сервере меняются, когда набор записей отключен, см. в главе 5 "Обновление и [сохраняемая информация".](chapter-5-updating-and-persisting-data.md)

## <a name="form_unload"></a>\_Выгрузка формы

\_Поднауть выгрузки формы важна по нескольким причинам. Во-первых, так как это пример приложения, выгрузка формы очищает изменения, внесенные в базу данных, перед \_ выходом приложения. Во-вторых, в коде показано, как можно выполнить команду непосредственно из открытого объекта **Connection** с помощью метода **Execute.** Наконец, в нем показан пример выполнения запроса, не возвращаемого строками (запрос UPDATE) для источника данных.

