---
title: HelloData Details (Справочник по базам данных Access на компьютере)
TOCTitle: HelloData details
ms:assetid: db51e15c-1b5b-c64a-2f84-34dd0e78c6cf
ms:mtpsurl: https://msdn.microsoft.com/library/JJ250105(v=office.15)
ms:contentKeyID: 48548103
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 78b04b74d4e2b8d9c215235d6e7ccebed4fa2ef2
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32292001"
---
# <a name="hellodata-details"></a>Сведения о HelloData


**Область применения**: Access 2013, Office 2013

Приложение HelloData пошаговое руководство по основным операциям типичного приложения ADO: "Просмотр", "Проверка", "Редактирование и обновление данных". При запуске приложения нажмите первую кнопку, **получить данные**. При этом будет запущена подпрограмма GetData ().

## <a name="getdata"></a>GetData

GetData помещает допустимую строку подключения в переменную уровня модуля, *m\_сконнстр*. Дополнительные сведения о строках подключения приведены [в разделе Создание строки подключения](creating-the-connection-string.md).

Назначьте обработчик ошибок с помощью оператора Visual Basic **OnError** . Дополнительные сведения об обработке ошибок в ADO содержатся в [главе 6: обработка ошибок](chapter-6-error-handling.md). Создается новый объект **Connection** , а для свойства **CursorLocation** задается значение **адусеклиент** , так как в примере HelloData создается *отключенный набор записей*. Это означает, что после получения данных из источника данных физическое подключение к источнику данных разорвано, но вы по-прежнему можете работать с данными, кэшированными локально в объекте **Recordset** .

После открытия подключения назначьте строку SQL переменной (Сскл). Затем создайте экземпляр нового объекта **Recordset** , m\_oRecordset1. В следующей строке кода откройте **набор записей** для существующего **подключения**, передав его. В следующей строке кода откройте **набор записей** для существующего **подключения**, передав в сскл в качестве источника объекта **Recordset**. Вы можете помочь ADO, чтобы определить, что строка SQL, которую вы передали в качестве источника для объекта **Recordset** , является текстовым определением команды, передав **адкмдтекст** в последнем аргументе методу Recordset для объекта **Recordset** **** . В этой строке также задаются **LockType** и **CursorType** , связанные с **набором записей**.

Следующая строка кода задает свойство **MarshalOptions** равным **адмаршалмодифиедонли**. **MarshalOptions** указывает, какие записи должны быть упакованы в средний уровень (или на веб-сервер). Для получения дополнительных сведений о маршалинге обратитесь к документации по COM. При использовании **адмаршалмодифиедонли** с клиентским курсором ([CursorLocation](cursorlocation-property-ado.md) = **адусеклиент**) только записи, которые были изменены в клиенте, записываются обратно на средний уровень. Установка **MarshalOptions** в **адмаршалмодифиедонли** может увеличить производительность, так как уменьшается число строк.

Затем отсоедините **набор записей** , задав для его свойства **ActiveConnection** значение **Nothing**. Дополнительную информацию можно узнать в статье [Отключение и повторное подключение набора записей](disconnecting-and-reconnecting-the-recordset.md) в главе 5: обновление и постоянное обновление данных.

Закройте подключение к источнику данных и уничтожайте существующий объект **Connection** , освобождая таким образом ресурсы, которые он использовал.

Завершающим шагом является установка объекта **Recordset** в качестве **источника данных** для элемента управления Grid Microsoft DataBound в форме, чтобы можно было легко отобразить данные из **набора записей** в форме.

Нажмите вторую кнопку, изУчите **данные**. При этом выполняется подпрограмма Ексаминедата.

## <a name="examinedata"></a>Ексаминедата

Ексаминедата использует различные методы и свойства объекта **Recordset** для отображения сведений о данных в **наборе записей**. Он отображает количество записей с помощью свойства **RecordCount** . Он выполняет цикл по **набору записей** и печатает значение свойства **AbsolutePosition** в текстовом поле Display формы. Кроме того, в цикле значение свойства **Bookmark** для третьей записи помещается в переменную типа Variant ( *вбукмарк*) для последующего использования.

Процедура непосредственно переходит к третьей записи с помощью переменной закладки, которая была сохранена ранее. Процедура вызывает подпрограмму Валкфиелдс, которая выполняет цикл по коллекции **Fields** **набора записей** и отображает сведения о каждом **поле** в коллекции.

Наконец, Ексаминедата использует свойство **Filter** объекта **Recordset** для отображения только тех записей, у которых значение CategoryID равно 2. Результат применения этого фильтра сразу отображается в сетке отображения на форме.

Дополнительные сведения о функциях, показанных в подпрограмме Ексаминедата, приведены в [главе 3: исследование данных](chapter-3-examining-data.md).

Затем нажмите третью кнопку, **измените данные**. При этом будет выполняться подпрограмма Едитдата.

## <a name="editdata"></a>Едитдата

Когда код вводит подпрограмму Едитдата, он по **** -прежнему фильтруется по значению CategoryID, равному 2, поэтому отображаются только те элементы, которые соответствуют условиям фильтра. Сначала он выполняет цикл по **набору записей** и увеличивает цену каждого видимого элемента в **наборе записей** на 10 процентов. Значение поля **Price** изменяется путем присвоения свойству Value этого поля **значения** , равного новой, допустимой сумме.

Помните, что **набор записей** отключен от источника данных. Изменения, внесенные в Едитдата, вносятся только в локально кэшированную копию данных. Дополнительные сведения приведены в [главе 4: Edit Data](chapter-4-editing-data.md).

Изменения не вносятся в источник данных, пока не будет нажата четвертая кнопка, **обновите данные**. При этом будет выполняться подпрограмма Упдатедата.

## <a name="updatedata"></a>Упдатедата

Упдатедата сначала удаляет фильтр, примененный к **набору записей**. Код удаляет и сбрасывает в качестве **источника данных** для связанной с Microsoft DataGrid в форме, чтобы в сетке отображался неФильтрованный **набор записей** .

Затем код проверяет, можно ли перемещаться в обратном наборе **записей** с помощью метода **** Supports с аргументом **адмовепревиаус** .

Процедура перемещается к первой записи с помощью метода **MoveFirst** и отображает исходные и текущие значения поля, используя свойства **originalValue** и **value** объекта **field** . Эти свойства вместе со свойством **UnderlyingValue** (не используется здесь) обсуждаются в [главе 5: обновление и постоянное обновление данных](chapter-5-updating-and-persisting-data.md).

Затем создается новый объект **Connection** , который используется для восстановления подключения к источнику данных. Необходимо повторно подключить объект **Recordset** к источнику данных, установив новое **Подключение** в качестве **ActiveConnection** для объекта **Recordset**. Чтобы отправить обновления на сервер, код вызывает **UpdateBatch** для объекта **Recordset**.

Если пакетное обновление выполнено успешно, переменная флага уровня модуля имеет значение true. В дальнейшем будет выдано напоминание об очистке всех изменений, внесенных в базу данных.

Наконец, код перемещается обратно в первую запись в **наборе записей** и отображает исходные и текущие значения. Значения совпадают после вызова **UpdateBatch**.

Для получения более подробных сведений об обновлении данных, в том числе действия, выполняемые при изменении данных на сервере, когда **набор записей** отключен, ознакомьтесь со статьей [глава 5: обновление и сохранение данных](chapter-5-updating-and-persisting-data.md).

## <a name="formunload"></a>Выгрузка формы\_

Подпрограмма\_выгрузки формы важна по нескольким причинам. Во-первых, так как это пример приложения,\_выгрузка формы очищает изменения, внесенные в базу данных до завершения работы приложения. Во вторых, код показывает, как можно выполнить команду непосредственно из открытого объекта **Connection** с помощью метода **EXECUTE** . В заключение показан пример выполнения запроса, не являющегося строкой (запрос на обновление), в источнике данных.

