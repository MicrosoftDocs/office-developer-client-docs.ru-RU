---
title: Сведения о HelloData (Справочник по для настольных баз данных Access)
TOCTitle: HelloData details
ms:assetid: db51e15c-1b5b-c64a-2f84-34dd0e78c6cf
ms:mtpsurl: https://msdn.microsoft.com/library/JJ250105(v=office.15)
ms:contentKeyID: 48548103
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 78b04b74d4e2b8d9c215235d6e7ccebed4fa2ef2
ms.sourcegitcommit: d6695c94415fa47952ee7961a69660abc0904434
ms.translationtype: Auto
ms.contentlocale: ru-RU
ms.lasthandoff: 01/17/2019
ms.locfileid: "28713389"
---
# <a name="hellodata-details"></a>Сведения о HelloData


**Применимо к**: Access 2013, Office 2013

Приложение HelloData проходит через базовых операций типичное приложение ADO: начало, проверки, изменение и обновление данных. При запуске приложения, щелкните первую кнопку **Получить данные**. Будет запущен подпрограмму GetData().

## <a name="getdata"></a>GetData

GetData помещает это допустимая строка подключения в переменной уровня модуля *m\_sConnStr*. Дополнительные сведения о строках подключения к [Строке подключения](creating-the-connection-string.md)см.

Назначьте обработчик ошибок с помощью оператора Visual Basic **OnError** . Дополнительные сведения об обработке ошибок в ADO можно [Глава 6: обработки ошибок](chapter-6-error-handling.md). Создается новый объект **подключения** , а свойство **CursorLocation** имеет значение **adUseClient** , так как HelloData создается *отключен набора записей*. Это означает, что после получило данных из источника данных физическое соединение с источником данных будет отключена, но пользователь может работать с данными, которые кэшированы локально в объекта **набора записей** .

После открытия подключения присвойте переменной (sSQL) строки SQL. Затем создайте экземпляр объекта **набора записей** , m\_oRecordset1. В следующей строке кода откройте через существующие **подключения**, передав в **набора записей** . В следующей строке кода откройте **записей** через существующие **подключения**, передав sSQL в качестве источника **записей**. ADO помочь в создании определение, что строка SQL, переданной в качестве источника для **набора записей** — текстовое определение команды, передав **adCmdText** в последний аргумент методу **записей** **Open** . Эта строка также задает **LockType для** и **CursorType** связана с **набора записей**.

Следующая строка кода задает свойство **MarshalOptions** равно **adMarshalModifiedOnly**. **MarshalOptions** указывает, какие записи маршалинга средний уровень (или веб-сервера). Дополнительные сведения о маршалинга COM см. При использовании **adMarshalModifiedOnly** с курсором со стороны клиента ([CursorLocation](cursorlocation-property-ado.md) = **adUseClient**), только записи, которые были изменены в клиенте записываются на среднем уровне. Установка **MarshalOptions** для **adMarshalModifiedOnly** могут улучшить производительность, так как упаковать меньшее число строк.

Затем отключите **записей** путем установки свойства **ActiveConnection** равна **Nothing**. Для получения дополнительных сведений см [Disconnecting и повторного подключения набора записей](disconnecting-and-reconnecting-the-recordset.md) в главе 5: обновления и сохранение данных.

Закройте подключение к источнику данных и удалите существующий объект **подключения** , тем самым освобождения ресурсов, которые его использования.

— Это последний этап установки **набора записей** как **источник данных** для элемента управления сетки с привязкой к данным Microsoft в форме, то можно легко отобразить данные из **записей** в форме.

Щелкните вторую кнопку **Проверки данных**. Это запускает подпрограмму ExamineData.

## <a name="examinedata"></a>ExamineData

ExamineData использует различные методы и свойства объекта **набора записей** для отображения сведений о данных в **набор записей**. Число записей его отчетов с помощью свойства **RecordCount** . Он циклически просматривает **записей** и печатает значение свойства **AbsolutePosition** в текстовом поле отображаемое в форме. Также в цикл, значение свойства **закладку** для третьего записи помещаются в переменную типа variant, *vBookmark*, для дальнейшего использования.

Процедура непосредственно переходит обратно на третий записи, с помощью переменной закладку, сохраненную ранее. Процедура вызывает подпрограмму WalkFields, который перебирает коллекцию **полей** **набора записей** и отображает сведения о каждом **поле** в коллекции.

И, наконец ExamineData использует свойство **фильтра** набора **записей** на экран только тех записей со идентификатор категории, равным 2. Результат применения этот фильтр видимым в отображение сетки на форме.

Дополнительные сведения о функциях, приведенные в подпрограмму ExamineData можно [Глава 3: проверка данных](chapter-3-examining-data.md).

Выберите третья кнопка **Изменить данные**. Будет запущен подпрограмму EditData.

## <a name="editdata"></a>EditData

Когда код переходит в подпрограмму EditData, **записей** по-прежнему фильтруется на идентификатор категории, равное 2, это так, только те элементы, которые соответствуют критериям фильтра являются видимыми. Сначала циклически просматривает **записей** и увеличивает цену каждого видимого элемента в наборе **записей** на 10 процентов. Путем установки свойства **значение** для этого поля равно новые, действительный сумма изменяется значение поля **Цена** .

Имейте в виду, что **записей** отключается от источника данных. Изменения, внесенные в EditData выполняются только на кэшированную копию данных. Дополнительные сведения можно [раздел 4: редактирование данных](chapter-4-editing-data.md).

Изменения не станут источника данных до щелчка Четвертая кнопка **Обновить данные**. Будет запущен подпрограмму UpdateData.

## <a name="updatedata"></a>UpdateData

UpdateData сначала удаляет фильтр, которая была применена к **набора записей**. Код удаляет и восстанавливаются значения по умолчанию как **источник данных** для привязанных DataGrid Microsoft на форме, чтобы в таблице появится неотфильтрованные **набора записей** .

Код затем проверяется ли вы можете перемещать назад в **набора записей** с помощью метода **поддерживает** с аргументом **adMovePrevious** .

Процедура переходит к первой записи, с помощью метода **MoveFirst** и отображает поле исходные и текущие значения с помощью свойства **OriginalValue** и **значение** объекта **поля** . Эти свойства, а также свойство **UnderlyingValue** (не используется здесь), подробно рассмотрены в [Глава 5: обновления и сохранение данных](chapter-5-updating-and-persisting-data.md).

После этого нового объекта **подключения** создается и используется чтобы восстановить подключение к источнику данных. Переподключение **набора записей** в источник данных, установка новое **подключение** в качестве **ActiveConnection** для **набора записей**. Чтобы отправлять обновления на сервере, код вызывает **UpdateBatch** **набора записей**.

Если пакет обновления завершается успешно, переменная уровня модуля флаг, имеет значение True. Это будет Напомнить позднее, чтобы очистить все изменения, внесенные в базу данных.

И, наконец код переход к первой записи в **набор записей** и отображает исходные и текущие значения. Значения совпадают с после вызова **UpdateBatch**.

Более подробные сведения об обновлении данных, в том числе возможные действия при изменении данных на сервере во время отключения набора **записей** см [Глава 5: обновления и сохранение данных](chapter-5-updating-and-persisting-data.md).

## <a name="formunload"></a>Форма\_Unload

Форма\_подпрограммы Unload важна по ряду причин. Во-первых, так как это пример приложения, формы\_Unload очищает изменений, внесенных в базу данных до завершения приложения. Во-вторых в коде показано, как команда может быть выполнена непосредственно из open объекта **подключения** с помощью метода **Execute** . И, наконец он показан пример выполнения запроса, не являющиеся – возвращающие строки (запрос на обновление), в источнике данных.

