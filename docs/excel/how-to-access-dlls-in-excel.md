---
title: Доступа к библиотекам DLL в Excel
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
ms.topic: overview
keywords:
- доступ к библиотекам DLL [excel 2007], [Excel 2007] библиотеки DLL доступ к в Excel
localization_priority: Normal
ms.assetid: e2bfd6ea-efa3-45c1-a5b8-2ccb8650c6ab
description: '������� ����������: Excel 2013�| Office 2013�| Visual Studio'
ms.openlocfilehash: bfb562b6bbe824124c6b5a691745d076720ee004
ms.sourcegitcommit: 9d60cd82b5413446e5bc8ace2cd689f683fb41a7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/11/2018
ms.locfileid: "19807261"
---
# <a name="access-dlls-in-excel"></a><span data-ttu-id="fd6ac-104">Доступа к библиотекам DLL в Excel</span><span class="sxs-lookup"><span data-stu-id="fd6ac-104">Access DLLs in Excel</span></span>

<span data-ttu-id="fd6ac-105">**Применимо к**: Excel 2013 | Office 2013 | Visual Studio</span><span class="sxs-lookup"><span data-stu-id="fd6ac-105">**Applies to**: Excel 2013 | Office 2013 | Visual Studio</span></span> 
  
<span data-ttu-id="fd6ac-106">Доступ к функции или команде DLL в Microsoft Excel можно получить несколькими способами:</span><span class="sxs-lookup"><span data-stu-id="fd6ac-106">You can access a DLL function or command in Microsoft Excel in several ways:</span></span>
  
- <span data-ttu-id="fd6ac-107">Через Microsoft Visual Basic для приложений (VBA) модуль кода, в котором функции или команды были сделаны доступными с помощью оператора **Declare** .</span><span class="sxs-lookup"><span data-stu-id="fd6ac-107">Through a Microsoft Visual Basic for Applications (VBA) code module in which the function or command has been made available using a **Declare** statement.</span></span> 
    
- <span data-ttu-id="fd6ac-108">Через лист макросов XLM с помощью функции **звонков** или **регистрации** .</span><span class="sxs-lookup"><span data-stu-id="fd6ac-108">Through an XLM macro sheet by using the **CALL** or **REGISTER** functions.</span></span> 
    
- <span data-ttu-id="fd6ac-109">Непосредственно с листа или из настроенного элемента пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-109">Directly from the worksheet or from a customized item in the user interface (UI).</span></span>
    
<span data-ttu-id="fd6ac-p101">В этой документации не рассматриваются функции XLM. Рекомендуется использовать любой из двух остальных подходов.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-p101">This documentation does not cover XLM functions. It is recommended that you use either of the other two approaches.</span></span>
  
<span data-ttu-id="fd6ac-112">Возможен непосредственно из таблицы или из настраиваемого элемента в пользовательском Интерфейсе, функции или команды необходимо сначала быть зарегистрированы в Excel.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-112">To be accessed directly from the worksheet or from a customized item in the UI, the function or command must first be registered with Excel.</span></span> <span data-ttu-id="fd6ac-113">Сведения о регистрации команд и функций видеть [Доступ к XLL-коду в Excel](accessing-xll-code-in-excel.md).</span><span class="sxs-lookup"><span data-stu-id="fd6ac-113">For information about registering commands and functions, see [Accessing XLL Code in Excel](accessing-xll-code-in-excel.md).</span></span>
  
## <a name="calling-dll-functions-and-commands-from-vba"></a><span data-ttu-id="fd6ac-114">Вызов функции DLL-Библиотеку и команды из VBA</span><span class="sxs-lookup"><span data-stu-id="fd6ac-114">Calling DLL functions and commands from VBA</span></span>

<span data-ttu-id="fd6ac-115">С помощью оператора **Declare** , можно получить доступ к функции DLL-Библиотеку и команды в VBA.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-115">You can access DLL functions and commands in VBA by using the **Declare** statement.</span></span> <span data-ttu-id="fd6ac-116">Этот оператор имеет один синтаксис команд, другая — для функций.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-116">This statement has one syntax for commands and one for functions.</span></span> 
  
- <span data-ttu-id="fd6ac-117">**Синтаксис 1 - команды**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-117">**Syntax 1 - commands**</span></span>
    
  ```vb
  [Public | Private] Declare Sub name Lib "libname" [Alias "aliasname"] [([arglist])]
  ```

- <span data-ttu-id="fd6ac-118">**Синтаксис 2 - функции**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-118">**Syntax 2 - functions**</span></span>
    
  ```vb
  [Public | Private] Declare Function name Lib "libname" [Alias "aliasname"] [([arglist])] [As type]
  ```

<span data-ttu-id="fd6ac-119">Дополнительные ключевые слова **Общие** и **частные** указать область импортированной функции: всего проекта Visual Basic или модуль Visual Basic, соответственно.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-119">The optional **Public** and **Private** keywords specify the scope of the imported function: the entire Visual Basic project or just the Visual Basic module, respectively.</span></span> <span data-ttu-id="fd6ac-120">Имя — это имя, которое будет использоваться в коде VBA.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-120">The name is the name that you want to use in the VBA code.</span></span> <span data-ttu-id="fd6ac-121">Если это отличается от имени в библиотеке DLL, необходимо использовать описателя «aliasname» псевдоним, и следует присвоить имя функции, как экспортировать с библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-121">If this differs from the name in the DLL, you must use the Alias "aliasname" specifier, and you should give the name of the function as exported by the DLL.</span></span> <span data-ttu-id="fd6ac-122">Если вы хотите получить доступ функции DLL, ссылку на библиотеку DLL порядковый номер, необходимо указать имя псевдонима, который является порядковый номер с префиксом **#**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-122">If you want to access a DLL function by reference to a DLL ordinal number, you must provide an alias name, which is the ordinal prefixed by **#**.</span></span>
  
<span data-ttu-id="fd6ac-123">Команды должен возвращать **значение void**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-123">Commands should return **void**.</span></span> <span data-ttu-id="fd6ac-124">Функции должен возвращать типы, VBA может распознать **ByVal**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-124">Functions should return types that VBA can recognize **ByVal**.</span></span> <span data-ttu-id="fd6ac-125">Это означает, что некоторые типы проще возвращаются путем изменения аргументов на месте: строки, массивы, пользовательские типы и объекты.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-125">This means that some types are more easily returned by modifying arguments in place: strings, arrays, user-defined types, and objects.</span></span>
  
> [!NOTE]
> <span data-ttu-id="fd6ac-p106">VBA не может проверить совпадение списка аргументов и возвращаемого значения в модуле Visual Basic со значениями, закодированными в DLL. Это необходимо внимательно проверить самостоятельно, поскольку ошибка может привести к сбою Excel.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-p106">VBA cannot check that the argument list and return stated in the Visual Basic module are the same as coded in the DLL. You should check this yourself very carefully, because a mistake could cause Excel to crash.</span></span> 
  
<span data-ttu-id="fd6ac-128">Если функция или команды аргументы не передаются по или указателя, они должен предшествовать ключевое слово **ByVal** в объявлении **arglist** .</span><span class="sxs-lookup"><span data-stu-id="fd6ac-128">When the function or command's arguments are not passed by reference or pointer, they must be preceded by the **ByVal** keyword in the **arglist** declaration.</span></span> <span data-ttu-id="fd6ac-129">Когда C/C++ функция принимает аргументы указателя или C++ функция принимает аргументы ссылку, должен быть передан **ByRef**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-129">When a C/C++ function takes pointer arguments, or a C++ function takes reference arguments, they should be passed **ByRef**.</span></span> <span data-ttu-id="fd6ac-130">Ключевое слово, которое позволяет пропустить аргумента **ByRef** список, так как он используется по умолчанию в VBA.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-130">The keyword **ByRef** can be omitted from argument lists because it is the default in VBA.</span></span> 
  
### <a name="argument-types-in-cc-and-vba"></a><span data-ttu-id="fd6ac-131">Типы аргументов в C/C++ и VBA</span><span class="sxs-lookup"><span data-stu-id="fd6ac-131">Argument types in C/C++ and VBA</span></span>

<span data-ttu-id="fd6ac-132">При сравнении объявлений типов аргументов в C/C++ и VBA следует учитывать следующее.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-132">You should note the following when you compare the declarations of argument types in C/C++ and VBA.</span></span>
  
- <span data-ttu-id="fd6ac-133">VBA **строка** передается как указатель на структуру BSTR строка байтов при передаче ByVal, а также как указатель указатель при передаче **ByRef**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-133">A VBA **String** is passed as a pointer to a byte-string BSTR structure when passed ByVal, and as a pointer to a pointer when passed **ByRef**.</span></span>
    
- <span data-ttu-id="fd6ac-134">VBA **Variant** , содержащего строку передается как указатель Юникод, строка Юникода BSTR структурировать при передаче **ByVal**, а также как указатель указатель при передаче **ByRef**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-134">A VBA **Variant** that contains a string is passed as a pointer to a Unicode wide-character string BSTR structure when passed **ByVal**, and as a pointer to a pointer when passed **ByRef**.</span></span>
    
- <span data-ttu-id="fd6ac-135">VBA **целое число** — это 16-разрядный лежат подписанных short в C/C++.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-135">The VBA **Integer** is a 16-bit type equivalent to a signed short in C/C++.</span></span> 
    
- <span data-ttu-id="fd6ac-136">VBA **длинный** — это 32-разрядная версия лежат подписанных int в C/C++.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-136">The VBA **Long** is a 32-bit type equivalent to a signed int in C/C++.</span></span> 
    
- <span data-ttu-id="fd6ac-137">VBA и C/C++ разрешить определения типов пользовательских данных с помощью операторов **типа** и **структуры** соответственно.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-137">Both VBA and C/C++ allow the definition of user-defined data types, using the **Type** and **struct** statements respectively.</span></span> 
    
- <span data-ttu-id="fd6ac-138">VBA и C/C++ поддерживают тип данных **Variant** , определенных для C/C++ в файлы заголовков Windows OLE/COM как VARIANT.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-138">Both VBA and C/C++ support the **Variant** data type, defined for C/C++ in the Windows OLE/COM header files as VARIANT.</span></span> 
    
- <span data-ttu-id="fd6ac-139">Массивы VBA, OLE **объекты SAFEARRAY**, определенных для C/C++, файлы заголовков Windows OLE/COM в качестве **SAFEARRAY**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-139">VBA arrays are OLE **SafeArrays**, defined for C/C++ in the Windows OLE/COM header files as **SAFEARRAY**.</span></span>
    
- <span data-ttu-id="fd6ac-140">Тип данных VBA **валюты** передается как структура типа **кг**, определенные в файле wtypes.h файл заголовка Windows, когда передается **ByVal**и как указатель в этом случае, если передается **ByRef**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-140">The VBA **Currency** data type is passed as a structure of type **CY**, defined in the Windows header file wtypes.h, when passed **ByVal**, and as a pointer to this when passed **ByRef**.</span></span>
    
<span data-ttu-id="fd6ac-141">В VBA элементы данных в типы пользовательских данных упакованы к границам 4-байтных, в то время как в Visual Studio по умолчанию они упакованы к границам 8 байтов.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-141">In VBA, data elements in user-defined data types are packed to 4-byte boundaries, whereas in Visual Studio, by default, they are packed to 8-byte boundaries.</span></span> <span data-ttu-id="fd6ac-142">Поэтому необходимо заключить определение структуры C/C++ в `#pragma pack(4) … #pragma pack()` блока, чтобы избежать невыравненности элементы.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-142">Therefore you must enclose the C/C++ structure definition in a `#pragma pack(4) … #pragma pack()` block to avoid elements being misaligned.</span></span> 
  
<span data-ttu-id="fd6ac-143">Ниже приводится пример определений эквивалентных пользовательских типов.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-143">The following is an example of equivalent user type definitions.</span></span>
  
```vb
Type VB_User_Type
    i As Integer
    d As Double
    s As String
End Type

```

```cpp
#pragma pack(4)
struct C_user_type
{
    short iVal;
    double dVal;
    BSTR bstr; // VBA String type is a byte string
}
#pragma pack() // restore default

```

<span data-ttu-id="fd6ac-144">VBA поддерживает больше диапазону значений в некоторых случаях не поддерживает Excel.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-144">VBA supports a greater range of values in some cases than Excel supports.</span></span> <span data-ttu-id="fd6ac-145">Двойная VBA — IEEE совместимым, поддерживающие subnormal номера, который в данный момент округляются нуль в рабочем листе.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-145">The VBA double is IEEE compliant, supporting subnormal numbers that are currently rounded down to zero on the worksheet.</span></span> <span data-ttu-id="fd6ac-146">Тип VBA **даты** может представлять даты как 1-янв-0100 с отрицательным сериализованных датами.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-146">The VBA **Date** type can represent dates as early as 1-Jan-0100 using negative serialized dates.</span></span> <span data-ttu-id="fd6ac-147">Excel позволяет только сериализованных даты, большее или равное нулю.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-147">Excel only allows serialized dates greater than or equal to zero.</span></span> <span data-ttu-id="fd6ac-148">Тип VBA **валюты** — масштабируемого 64-разрядное целое число, можно достичь точность не поддерживается в тип Double 8 байтов и поэтому не соответствует в рабочем листе.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-148">The VBA **Currency** type—a scaled 64-bit integer—can achieve accuracy not supported in 8-byte doubles, and so is not matched in the worksheet.</span></span> 
  
<span data-ttu-id="fd6ac-149">Excel передает в пользовательскую функцию VBA только аргументы Variant указанных ниже типов.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-149">Excel only passes Variants of the following types to a VBA user-defined function.</span></span>
  
|<span data-ttu-id="fd6ac-150">**Тип данных VBA**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-150">**VBA data type**</span></span>|<span data-ttu-id="fd6ac-151">**Тип Variant C/C++ двоичных флагов**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-151">**C/C++ Variant type bit flags**</span></span>|<span data-ttu-id="fd6ac-152">**Описание**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-152">**Description**</span></span>|
|:-----|:-----|:-----|
|<span data-ttu-id="fd6ac-153">Double</span><span class="sxs-lookup"><span data-stu-id="fd6ac-153">Double</span></span>  <br/> |<span data-ttu-id="fd6ac-154">**VT_R8**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-154">**VT_R8**</span></span> <br/> ||
|<span data-ttu-id="fd6ac-155">Логический</span><span class="sxs-lookup"><span data-stu-id="fd6ac-155">Boolean</span></span>  <br/> |<span data-ttu-id="fd6ac-156">**VT_BOOL**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-156">**VT_BOOL**</span></span> <br/> ||
|<span data-ttu-id="fd6ac-157">Date</span><span class="sxs-lookup"><span data-stu-id="fd6ac-157">Date</span></span>  <br/> |<span data-ttu-id="fd6ac-158">**VT_DATE**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-158">**VT_DATE**</span></span> <br/> ||
|<span data-ttu-id="fd6ac-159">Строка</span><span class="sxs-lookup"><span data-stu-id="fd6ac-159">String</span></span>  <br/> |<span data-ttu-id="fd6ac-160">**VT_BSTR**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-160">**VT_BSTR**</span></span> <br/> |<span data-ttu-id="fd6ac-161">Байтовая строка Bstr OLE</span><span class="sxs-lookup"><span data-stu-id="fd6ac-161">OLE Bstr byte string</span></span>  <br/> |
|<span data-ttu-id="fd6ac-162">Диапазон</span><span class="sxs-lookup"><span data-stu-id="fd6ac-162">Range</span></span>  <br/> |<span data-ttu-id="fd6ac-163">**VT_DISPATCH**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-163">**VT_DISPATCH**</span></span> <br/> |<span data-ttu-id="fd6ac-164">Ссылки на диапазоны и ячейки</span><span class="sxs-lookup"><span data-stu-id="fd6ac-164">Range and cell references</span></span>  <br/> |
|<span data-ttu-id="fd6ac-165">Аргумент Variant, содержащий массив</span><span class="sxs-lookup"><span data-stu-id="fd6ac-165">Variant containing an array</span></span>  <br/> |<span data-ttu-id="fd6ac-166">**VT_ARRAY**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-166">**VT_ARRAY**</span></span> | <span data-ttu-id="fd6ac-167">**VT_VARIANT**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-167">**VT_VARIANT**</span></span> <br/> |<span data-ttu-id="fd6ac-168">Массивы литералов</span><span class="sxs-lookup"><span data-stu-id="fd6ac-168">Literal arrays</span></span>  <br/> |
|<span data-ttu-id="fd6ac-169">Ccy</span><span class="sxs-lookup"><span data-stu-id="fd6ac-169">Ccy</span></span>  <br/> |<span data-ttu-id="fd6ac-170">**VT_CY**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-170">**VT_CY**</span></span> <br/> |<span data-ttu-id="fd6ac-171">64-разрядное целое число, масштабируемое до 4 десятичных знаков.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-171">64-bit integer scaled to permit 4 decimal places of accuracy.</span></span>  <br/> |
|<span data-ttu-id="fd6ac-172">Аргумент Variant, содержащий ошибку</span><span class="sxs-lookup"><span data-stu-id="fd6ac-172">Variant containing an error</span></span>  <br/> |<span data-ttu-id="fd6ac-173">**VT_ERROR**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-173">**VT_ERROR**</span></span> <br/> ||
||<span data-ttu-id="fd6ac-174">**VT_EMPTY**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-174">**VT_EMPTY**</span></span> <br/> |<span data-ttu-id="fd6ac-175">Пустые ячейки или пропущенные аргументы</span><span class="sxs-lookup"><span data-stu-id="fd6ac-175">Empty cells or omitted arguments</span></span>  <br/> |
   
<span data-ttu-id="fd6ac-176">Можно проверить тип Variant переданное в VBA с помощью **VarType**, за исключением того, что функция возвращает тип диапазон значений при вызове с ссылки.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-176">You can check the type of a passed-in Variant in VBA using the **VarType**, except that the function returns the type of the range's values when called with references.</span></span> <span data-ttu-id="fd6ac-177">Для определения **типа Variant** — это объект reference **диапазона** , можно использовать функцию **IsObject** .</span><span class="sxs-lookup"><span data-stu-id="fd6ac-177">To determine if a **Variant** is a **Range** reference object, you can use the **IsObject** function.</span></span> 
  
<span data-ttu-id="fd6ac-178">Вы можете создать **варианты** , содержащие массивов вариантов в VBA из **диапазона** путем присвоения свойству **значение** **Variant**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-178">You can create **Variants** that contain arrays of variants in VBA from a **Range** by assigning its **Value** property to a **Variant**.</span></span> <span data-ttu-id="fd6ac-179">Все ячейки в диапазоне от источника, отформатированные с помощью стандартного формата валюты для региональных параметров в силе во время преобразуются в элементы массива типа **Currency**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-179">Any cells in the source range that are formatted using the standard currency format for the regional settings in force at the time are converted to array elements of type **Currency**.</span></span> <span data-ttu-id="fd6ac-180">Ячейки в формате даты преобразуются в элементы массива типа **Date**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-180">Any cells formatted as dates are converted to array elements of type **Date**.</span></span> <span data-ttu-id="fd6ac-181">Ячейки, содержащие строки преобразуются в варианты **BSTR** Юникода.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-181">Cells containing strings are converted to wide-character **BSTR** Variants.</span></span> <span data-ttu-id="fd6ac-182">Ячейки, содержащие ошибки преобразуются в **варианты** типа **VT_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-182">Cells containing errors are converted to **Variants** of type **VT_ERROR**.</span></span> <span data-ttu-id="fd6ac-183">Ячейки, содержащие **логическое** **значение True** или **False** преобразуется в **варианты** типа **VT_BOOL**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-183">Cells containing **Boolean** **True** or **False** are converted to **Variants** of type **VT_BOOL**.</span></span> 
  
> [!NOTE]
> <span data-ttu-id="fd6ac-184">**Варианта** хранит **значение True,** как значение -1 и **значение False,** как 0.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-184">The **Variant** stores **True** as -1 and **False** as 0.</span></span> <span data-ttu-id="fd6ac-185">Числа не в формате даты или сумм в валюте преобразуются в варианты типа **VT_R8**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-185">Numbers not formatted as dates or currency amounts are converted to Variants of type **VT_R8**.</span></span> 
  
### <a name="variant-and-string-arguments"></a><span data-ttu-id="fd6ac-186">Тип Variant и строковые аргументы</span><span class="sxs-lookup"><span data-stu-id="fd6ac-186">Variant and string arguments</span></span>

<span data-ttu-id="fd6ac-187">Excel работает внутри Юникода строк в формате Юникод.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-187">Excel works internally with wide-character Unicode strings.</span></span> <span data-ttu-id="fd6ac-188">Когда пользовательскую функцию VBA объявлен как принимающий **строковый** аргумент, Excel преобразует указанную строку в строку байтов в зависимости от языкового стандарта.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-188">When a VBA user-defined function is declared as taking a **String** argument, Excel converts the supplied string to a byte-string in a locale-specific way.</span></span> <span data-ttu-id="fd6ac-189">Если вы хотите функции передаваемых строки Юникод, должен принимать **Variant** вместо **строковый** аргумент VBA пользовательской функции.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-189">If you want your function to be passed a Unicode string, your VBA user-defined function should accept a **Variant** instead of a **String** argument.</span></span> <span data-ttu-id="fd6ac-190">Функция DLL затем может принимать этого **варианта** строку Юникода BSTR из VBA.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-190">Your DLL function can then accept that **Variant** BSTR wide-character string from VBA.</span></span> 
  
<span data-ttu-id="fd6ac-191">Чтобы получить строки Юникод VBA из библиотеки DLL, следует изменить **Variant** строковый аргумент на месте.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-191">To return Unicode strings to VBA from a DLL, you should modify a **Variant** string argument in place.</span></span> <span data-ttu-id="fd6ac-192">Для работы необходимо объявить функции DLL как принимающий указатель для **Variant** и в коде C/C++ и объявить аргумент в коде VBA как `ByRef varg As Variant`.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-192">For this to work, you must declare the DLL function as taking a pointer to the **Variant** and in your C/C++ code, and declare the argument in the VBA code as  `ByRef varg As Variant`.</span></span> <span data-ttu-id="fd6ac-193">Необходимо освободить старые строки памяти и новое значение строки, созданные с помощью функции строку OLE Bstr только в DLL-Библиотеке.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-193">The old string memory should be released, and the new string value created by using the OLE Bstr string functions only in the DLL.</span></span>
  
<span data-ttu-id="fd6ac-194">Чтобы получить строку байтов VBA из библиотеки DLL, следует изменить байтов строковый аргумент BSTR на месте.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-194">To return a byte string to VBA from a DLL, you should modify a byte-string BSTR argument in place.</span></span> <span data-ttu-id="fd6ac-195">Для этого необходимо объявить функции DLL как принимающий указатель на указатель в строку BSTR и в коде C/C++ и объявить аргумент в коде VBA как « **ByRef varg как строка**».</span><span class="sxs-lookup"><span data-stu-id="fd6ac-195">For this to work, you must declare the DLL function as taking a pointer to a pointer to the BSTR and in your C/C++ code, and declare the argument in the VBA code as ' **ByRef varg As String**'.</span></span>
  
<span data-ttu-id="fd6ac-196">Следует обрабатывать только строк, которые передаются в этих способов из VBA с помощью функции строка OLE BSTR во избежание проблем, связанных с памяти.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-196">You should only handle strings that are passed in these ways from VBA using the OLE BSTR string functions to avoid memory-related problems.</span></span> <span data-ttu-id="fd6ac-197">Например необходимо вызвать **SysFreeString** , чтобы освободить память перед перезаписью переданную в строку и **SysAllocStringByteLen** или **SysAllocStringLen** для выделения пространства для новой строки.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-197">For example, you must call **SysFreeString** to free the memory before overwriting the passed in string, and **SysAllocStringByteLen** or **SysAllocStringLen** to allocate space for a new string.</span></span> 
  
<span data-ttu-id="fd6ac-198">Можно создать ошибки рабочего листа Excel как **вариантов** на языке VBA с помощью функция **CVerr** с аргументы, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-198">You can create Excel worksheet errors as **Variants** in VBA by using the **CVerr** function with arguments as shown in the following table.</span></span> <span data-ttu-id="fd6ac-199">Таблица ошибки могут быть возвращены для VBA из библиотеки DLL с использованием **вариантов** типа **VT_ERROR**и со следующими значениями в поле **ulVal** .</span><span class="sxs-lookup"><span data-stu-id="fd6ac-199">Worksheet errors can also be returned to VBA from a DLL using **Variants** of type **VT_ERROR**, and with the following values in the **ulVal** field.</span></span> 
  
|<span data-ttu-id="fd6ac-200">**Error**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-200">**Error**</span></span>|<span data-ttu-id="fd6ac-201">**Значение типа Variant ulVal**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-201">**Variant ulVal value**</span></span>|<span data-ttu-id="fd6ac-202">**Аргумент CVerr**</span><span class="sxs-lookup"><span data-stu-id="fd6ac-202">**CVerr argument**</span></span>|
|:-----|:-----|:-----|
|<span data-ttu-id="fd6ac-203">#ПУСТО!</span><span class="sxs-lookup"><span data-stu-id="fd6ac-203">#NULL!</span></span>  <br/> |<span data-ttu-id="fd6ac-204">2148141008</span><span class="sxs-lookup"><span data-stu-id="fd6ac-204">2148141008</span></span>  <br/> |<span data-ttu-id="fd6ac-205">2000</span><span class="sxs-lookup"><span data-stu-id="fd6ac-205">2000</span></span>  <br/> |
|<span data-ttu-id="fd6ac-206">#ДЕЛ/0!</span><span class="sxs-lookup"><span data-stu-id="fd6ac-206">#DIV/0!</span></span>  <br/> |<span data-ttu-id="fd6ac-207">2148141015</span><span class="sxs-lookup"><span data-stu-id="fd6ac-207">2148141015</span></span>  <br/> |<span data-ttu-id="fd6ac-208">2007</span><span class="sxs-lookup"><span data-stu-id="fd6ac-208">2007</span></span>  <br/> |
|<span data-ttu-id="fd6ac-209">#ЗНАЧ!</span><span class="sxs-lookup"><span data-stu-id="fd6ac-209">#VALUE!</span></span>  <br/> |<span data-ttu-id="fd6ac-210">2148141023</span><span class="sxs-lookup"><span data-stu-id="fd6ac-210">2148141023</span></span>  <br/> |<span data-ttu-id="fd6ac-211">2015</span><span class="sxs-lookup"><span data-stu-id="fd6ac-211">2015</span></span>  <br/> |
|<span data-ttu-id="fd6ac-212">#ССЫЛКА!</span><span class="sxs-lookup"><span data-stu-id="fd6ac-212">#REF!</span></span>  <br/> |<span data-ttu-id="fd6ac-213">2148141031</span><span class="sxs-lookup"><span data-stu-id="fd6ac-213">2148141031</span></span>  <br/> |<span data-ttu-id="fd6ac-214">2023</span><span class="sxs-lookup"><span data-stu-id="fd6ac-214">2023</span></span>  <br/> |
|<span data-ttu-id="fd6ac-215">#ИМЯ?</span><span class="sxs-lookup"><span data-stu-id="fd6ac-215">#NAME?</span></span>  <br/> |<span data-ttu-id="fd6ac-216">2148141037</span><span class="sxs-lookup"><span data-stu-id="fd6ac-216">2148141037</span></span>  <br/> |<span data-ttu-id="fd6ac-217">2029</span><span class="sxs-lookup"><span data-stu-id="fd6ac-217">2029</span></span>  <br/> |
|<span data-ttu-id="fd6ac-218">#ЧИСЛО!</span><span class="sxs-lookup"><span data-stu-id="fd6ac-218">#NUM!</span></span>  <br/> |<span data-ttu-id="fd6ac-219">2148141044</span><span class="sxs-lookup"><span data-stu-id="fd6ac-219">2148141044</span></span>  <br/> |<span data-ttu-id="fd6ac-220">2036</span><span class="sxs-lookup"><span data-stu-id="fd6ac-220">2036</span></span>  <br/> |
|<span data-ttu-id="fd6ac-221">#Н/Д</span><span class="sxs-lookup"><span data-stu-id="fd6ac-221">#N/A</span></span>  <br/> |<span data-ttu-id="fd6ac-222">2148141050</span><span class="sxs-lookup"><span data-stu-id="fd6ac-222">2148141050</span></span>  <br/> |<span data-ttu-id="fd6ac-223">2042</span><span class="sxs-lookup"><span data-stu-id="fd6ac-223">2042</span></span>  <br/> |
   
<span data-ttu-id="fd6ac-224">Обратите внимание, что значением типа Variant, **ulVal** эквивалентен **CVerr** значение аргумента, а также x800A0000 шестнадцатеричные.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-224">Note that the Variant **ulVal** value given is equivalent to the **CVerr** argument value plus x800A0000 hexadecimal.</span></span> 
  
## <a name="calling-dll-functions-directly-from-the-worksheet"></a><span data-ttu-id="fd6ac-225">Вызов функции DLL непосредственно из листа</span><span class="sxs-lookup"><span data-stu-id="fd6ac-225">Calling DLL functions directly from the worksheet</span></span>

<span data-ttu-id="fd6ac-226">Недоступны функций Win32 DLL из таблицы без, например, с помощью VBA или XLM как интерфейсы или не сообщив Excel заранее знаете о функцию, аргументы и его возвращаемый тип.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-226">You cannot access Win32 DLL functions from the worksheet without, for example, using VBA or XLM as interfaces, or without letting Excel know about the function, its arguments, and its return type in advance.</span></span> <span data-ttu-id="fd6ac-227">Это процесс называется регистрации.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-227">The process of doing this is called registration.</span></span>
  
<span data-ttu-id="fd6ac-228">Получать доступ к функциям DLL на листе можно следующими способами:</span><span class="sxs-lookup"><span data-stu-id="fd6ac-228">The ways in which the functions of a DLL can be accessed in the worksheet are as follows:</span></span>
  
- <span data-ttu-id="fd6ac-229">Объявите функцию в VBA, как показано выше, и получите доступ к ней через пользовательскую функцию VBA.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-229">Declare the function in VBA as described previously and access it via a VBA user-defined function.</span></span>
    
- <span data-ttu-id="fd6ac-230">Вызовите функцию DLL с помощью команды CALL или листа макросов XLM и получите доступ к ней через пользовательскую функцию XLM.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-230">Call the DLL function using CALL on an XLM macro sheet, and access it via an XLM user-defined function.</span></span>
    
- <span data-ttu-id="fd6ac-231">Используйте команду XLM или VBA для вызова функции XLM **регистрации** , которая содержит сведения, который необходимо определить функцию при вводе в ячейку листа Excel.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-231">Use an XLM or VBA command to call the XLM **REGISTER** function, which provides the information that Excel needs to recognize the function when it is entered into a worksheet cell.</span></span> 
    
- <span data-ttu-id="fd6ac-232">Перевод библиотеки DLL в надстройке XLL и зарегистрировать функцию, с помощью функции интерфейса API для C **xlfRegister** при активации XLL.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-232">Turn the DLL into an XLL and register the function using the C API **xlfRegister** function when the XLL is activated.</span></span> 
    
<span data-ttu-id="fd6ac-p119">Четвертый подход изолированный: код, регистрирующий функции, и код функций хранятся в одном объекте кода. Изменение надстройки не включает изменение листа XLM или модуля кода VBA. Чтобы сделать это с широкими возможностями управления, оставаясь в рамках возможностей API C, необходимо преобразовать DLL в XLL и загрузить получившуюся надстройку с помощью диспетчера настроек. Это позволяет Excel вызывать функцию, предоставленную библиотекой DLL, при загрузке или активации надстройки, из которой затем можно зарегистрировать все функции, которые содержит XLL, и выполнять другие задачи инициализации DLL.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-p119">The fourth approach is self-contained: the code that registers the functions and the function code are both contained in the same code project. Making changes to the add-in does not involve making changes to an XLM sheet or to a VBA code module. To do this in a well-managed way while still staying within the capabilities of the C API, you must turn your DLL into an XLL and load the resulting add-in by using the Add-in Manager. This enables Excel to call a function that your DLL exposes when the add-in is loaded or activated, from which you can register all of the functions your XLL contains, and carry out any other DLL initialization.</span></span>
  
## <a name="calling-dll-commands-directly-from-excel"></a><span data-ttu-id="fd6ac-237">Вызов DLL-Библиотека команды непосредственно из Excel</span><span class="sxs-lookup"><span data-stu-id="fd6ac-237">Calling DLL commands directly from Excel</span></span>

<span data-ttu-id="fd6ac-238">Команды DLL Win32 недоступны напрямую из диалоговых окон и меню Excel без интерфейса, например VBA, или без предварительной регистрации команд.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-238">Win32 DLL commands are not accessible directly from Excel dialog boxes and menus without there being an interface, such as VBA, or without the commands being registered in advance.</span></span>
  
<span data-ttu-id="fd6ac-239">Получать доступ к командам DLL можно следующими способами:</span><span class="sxs-lookup"><span data-stu-id="fd6ac-239">The ways in which you can access the commands of a DLL are as follows:</span></span>
  
- <span data-ttu-id="fd6ac-240">Объявите команду в VBA, как описано выше, и получите доступ к ней через макрос VBA.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-240">Declare the command in VBA as described previously and access it via a VBA macro.</span></span>
    
- <span data-ttu-id="fd6ac-241">Вызовите команду DLL-Библиотеку, с помощью **ВЫЗОВА** на листе макросов XLM и получить к нему доступ с помощью макросов XLM.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-241">Call the DLL command using **CALL** on an XLM macro sheet, and access it via an XLM macro.</span></span> 
    
- <span data-ttu-id="fd6ac-242">Используйте XLM или команды VBA для вызова функции XLM **регистрации** , которая предоставляет сведения о Excel необходимо распознавать команда при вводе в диалоговое окно, которое требуется имя макроса.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-242">Use an XLM or VBA command to call the XLM **REGISTER** function, which provides the information Excel needs to recognize the command when it is entered into a dialog box that expects the name of a macro command.</span></span> 
    
- <span data-ttu-id="fd6ac-243">Перевод библиотеки DLL в надстройке XLL и зарегистрировать команды, с помощью функции интерфейса API для C **xlfRegister** .</span><span class="sxs-lookup"><span data-stu-id="fd6ac-243">Turn the DLL into an XLL and register the command using the C API **xlfRegister** function.</span></span> 
    
<span data-ttu-id="fd6ac-p120">Как упоминалось ранее в контексте функций DLL, четвертый подход является самым изолированным, так как код регистрации хранится наряду с кодом команд. Для этого необходимо преобразовать DLL в XLL и загрузить получившуюся надстройку с помощью диспетчера надстроек. Регистрация команд таким способом также позволяет присоединить команду к элементу пользовательского интерфейса, например пользовательскому меню, или настроить перехват события с вызовом команды по нажатию определенной клавиши или другому событию.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-p120">As discussed earlier in the context of DLL functions, the fourth approach is the most self-contained, keeping the registration code close to the command code. To do this, you must turn your DLL into an XLL and load the resulting add-in using the Add-in Manager. Registering commands in this way also lets you attach the command to an element of the user interface, such as a custom menu, or to set up an event trap that calls the command on a given keystroke or other event.</span></span>
  
<span data-ttu-id="fd6ac-247">Предполагается, что все команды XLL, зарегистрированные в Excel, имеют указанную ниже форму.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-247">All XLL commands that are registered with Excel are assumed by Excel to be of the following form.</span></span>
  
```cpp
int WINAPI my_xll_cmd(void)
{
// Function code...
    return 1;
}
```

> [!NOTE]
> <span data-ttu-id="fd6ac-248">Excel возвращаемое значение игнорируется, если не вызывается из листа макросов XLM, в котором случае возвращаемое значение преобразуется в значение **TRUE** или **FALSE**.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-248">Excel ignores the return value unless it is called from an XLM macro sheet, in which case the return value is converted to **TRUE** or **FALSE**.</span></span> <span data-ttu-id="fd6ac-249">Следует таким образом возвращает 1, если команда выполнена успешно, а 0, если он не удалась или отменена пользователем.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-249">You should therefore return 1 if your command executed successfully, and 0 if it failed or was canceled by the user.</span></span> 
  
## <a name="dll-memory-and-multiple-dll-instances"></a><span data-ttu-id="fd6ac-250">Память DLL-Библиотеку и несколько экземпляров DLL</span><span class="sxs-lookup"><span data-stu-id="fd6ac-250">DLL memory and multiple DLL instances</span></span>

<span data-ttu-id="fd6ac-251">Когда приложение загружает библиотеку DLL, DLL-Библиотека исполняемый код загружается в глобальной кучи, чтобы его можно было выполнить, а пространства, выделяемого на глобальной кучи для его структуры данных.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-251">When an application loads a DLL, the DLL's executable code is loaded into the global heap so that it can be run, and space is allocated on the global heap for its data structures.</span></span> <span data-ttu-id="fd6ac-252">Windows использует сопоставления памяти, чтобы эти области памяти отображаются, как если бы они находятся в процессе приложения, чтобы доступ к их приложения.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-252">Windows uses memory mapping to make these areas of memory appear as if they are in the application's process so that the application can access them.</span></span>
  
<span data-ttu-id="fd6ac-253">Если второй приложения затем загружает библиотеку DLL, Windows не выполняет еще одну копию исполняемый код библиотеки DLL, как памяти доступен только для чтения.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-253">If a second application then loads the DLL, Windows does not make another copy of the DLL executable code, as that memory is read-only.</span></span> <span data-ttu-id="fd6ac-254">Windows сопоставляет памяти исполняемый код DLL процессов оба приложения.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-254">Windows maps the DLL executable code memory to the processes of both applications.</span></span> <span data-ttu-id="fd6ac-255">Его does, тем не менее, выделите второй пространства для закрытого копию структуры данных библиотеки DLL и сопоставляется второй процесс только эту копию.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-255">It does, however, allocate a second space for a private copy of the DLL's data structures and maps this copy to the second process only.</span></span> <span data-ttu-id="fd6ac-256">Это гарантирует, что ни один из приложения могут мешать данных библиотеки DLL из другой.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-256">This ensures that neither application can interfere with the DLL data of the other.</span></span>
  
<span data-ttu-id="fd6ac-257">Это означает, что разработчикам библиотеки DLL необходимо касается о статических и глобальные переменные и структуры данных к которым получают доступ приложения более одного или нескольких экземпляров одного приложения.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-257">This means that DLL developers do not have to be concerned about static and global variables and data structures being accessed by more than one application, or more than one instance of the same application.</span></span> <span data-ttu-id="fd6ac-258">Каждый экземпляр каждое приложение получает собственную копию данных DLL.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-258">Every instance of every application gets its own copy of the DLL's data.</span></span>
  
<span data-ttu-id="fd6ac-259">DLL-Библиотека следует разработчикам беспокоит тот же экземпляр приложения вызов количество раз их DLL из различных потоков, так как это может привести к конкуренции за этот экземпляр данных.</span><span class="sxs-lookup"><span data-stu-id="fd6ac-259">DLL developers do need to be concerned about the same instance of an application calling their DLL many times from different threads, because this can result in contention for that instance's data.</span></span> <span data-ttu-id="fd6ac-260">Дополнительные сведения содержатся в разделе [Управление памятью в Excel](memory-management-in-excel.md).</span><span class="sxs-lookup"><span data-stu-id="fd6ac-260">For more information, see [Memory Management in Excel](memory-management-in-excel.md).</span></span>
  
## <a name="see-also"></a><span data-ttu-id="fd6ac-261">См. также</span><span class="sxs-lookup"><span data-stu-id="fd6ac-261">See also</span></span>

- [<span data-ttu-id="fd6ac-262">Разработка библиотеки DLL</span><span class="sxs-lookup"><span data-stu-id="fd6ac-262">Developing DLLs</span></span>](developing-dlls.md) 
- [<span data-ttu-id="fd6ac-263">����� � Excel �� DLL ��� XLL</span><span class="sxs-lookup"><span data-stu-id="fd6ac-263">Calling into Excel from the DLL or XLL</span></span>](calling-into-excel-from-the-dll-or-xll.md)

