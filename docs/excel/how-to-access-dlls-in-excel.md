---
title: Доступ к библиотекам DLL в Excel
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
ms.topic: overview
keywords:
- доступ к библиотекам DLL [Excel 2007], библиотеки DLL [Excel 2007], доступ в Excel
ms.assetid: e2bfd6ea-efa3-45c1-a5b8-2ccb8650c6ab
description: 'Относится к: Excel 2013 | Office 2013 | Visual Studio'
localization_priority: Priority
ms.openlocfilehash: fac4ad30048aa1bf3879009bc97ea46a112a9ce5
ms.sourcegitcommit: d6695c94415fa47952ee7961a69660abc0904434
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/17/2019
ms.locfileid: "28701377"
---
# <a name="access-dlls-in-excel"></a>Доступ к библиотекам DLL в Excel

**Относится к**: Excel 2013 | Office 2013 | Visual Studio 
  
Вы можете получить доступ к функции или команде DLL в Microsoft Excel несколькими способами:
  
- с помощью модуля кода Microsoft Visual Basic для приложений (VBA), в котором функция или команда была сделана доступной с помощью выражения **Declare**; 
    
- через лист макросов XLM, используя функции **CALL** или **REGISTER**; 
    
- непосредственно с листа или из настроенного элемента в пользовательском интерфейсе.
    
В этой документации не рассматриваются функции XLM. Рекомендуем использовать один из двух других подходов.
  
Для непосредственного доступа с листа или из настроенного элемента пользовательского интерфейса функцию или команду необходимо сначала зарегистрировать в Excel. Сведения о регистрации команд и функций см. в статье [Accessing XLL Code in Excel](accessing-xll-code-in-excel.md).
  
## <a name="calling-dll-functions-and-commands-from-vba"></a>Вызов функций и команд DLL из VBA

Вы можете получать доступ к функциям и командам DLL в VBA с помощью выражения **Declare**. Это выражение имеет один синтаксис для команд и другой — для функций. 
  
- **Синтаксис 1: команды**
    
  ```vb
  [Public | Private] Declare Sub name Lib "libname" [Alias "aliasname"] [([arglist])]
  ```

- **Синтаксис 2: функции**
    
  ```vb
  [Public | Private] Declare Function name Lib "libname" [Alias "aliasname"] [([arglist])] [As type]
  ```

Необязательные ключевые слова **Public** и **Private** определяют область импортированной функции (весь проект Visual Basic и модуль Visual Basic соответственно). Имя — это имя, которое вы хотите использовать в коде VBA. Если оно отличается от имени в библиотеке DLL, необходимо использовать указатель Alias "aliasname" и предоставить имя функции, экспортируемое библиотекой DLL. Для доступа к функции DLL с помощью ссылки на порядковый номер DLL необходимо предоставить псевдоним, который является порядковым номером с префиксом **#**.
  
Команды должны возвращать тип **void**. Функции должны возвращать типы, которые VBA может распознавать **ByVal**. Это означает, что некоторые типы легче возвращать путем изменения аргументов: строк, массивов, пользовательских типов и объектов.
  
> [!NOTE]
> VBA не может проверить совпадение списка аргументов и возвращаемого значения в модуле Visual Basic со значениями, закодированными в DLL. Это необходимо внимательно проверить самостоятельно, поскольку ошибка может привести к сбою Excel. 
  
Если аргументы команды или функции не передаются с помощью ссылки или указателя, они должны стоять после ключевого слова **ByVal** в объявлении **arglist**. Когда функция C/C++ принимает аргументы указателя или функция C++ принимает аргументы ссылки, они должны передаваться **ByRef**. Ключевое слово **ByRef** можно пропустить в списке аргументов, так как оно используется по умолчанию в VBA. 
  
### <a name="argument-types-in-cc-and-vba"></a>Типы аргументов в C/C++ и VBA

Следует помнить об указанных ниже фактах при сравнении объявлений типов аргументов в C/C++ и VBA.
  
- Тип **String** в VBA передается как указатель на структуру BSTR байтовых строк в режиме ByVal и как указатель на указатель в режиме **ByRef**.
    
- Тип **Variant** в VBA, содержащий строку, передается как указатель на структуру BSTR строк Юникода из двухбайтовых знаков при передаче в режиме **ByVal** и как указатель на указатель в режиме **ByRef**.
    
- **Integer** VBA — это 16-битный тип, эквивалентный signed short в C/C++. 
    
- **Long** VBA — это 32-битный тип, эквивалентный signed int в C/C++. 
    
- VBA и C/C++ допускают определяемые пользователем типы данных (применяются операторы **Type** и **struct** соответственно). 
    
- VBA и C/C++ поддерживают тип данных **Variant**, заданный для C/C++ в файлах заголовка Windows OLE/COM как VARIANT. 
    
- Массивы VBA — это объекты OLE **SafeArrays**, определенные для C/C++ в файлах заголовка Windows OLE/COM как **SAFEARRAY**.
    
- Тип данных **Currency** в VBA передается как структура типа **CY**, определенная в файле заголовка Windows wtypes.h, в режиме **ByVal** и как указатель на него в режиме **ByRef**.
    
В VBA элементы данных в определяемых пользователем типах данных упаковываются с учетом 4-байтовых границ, тогда как в Visual Studio по умолчанию они упаковываются с учетом 8-байтовых границ. Поэтому необходимо заключить определение структуры C/C++ в блок `#pragma pack(4) … #pragma pack()`, чтобы избежать несовпадения элементов. 
  
Ниже приведен пример определений эквивалентных пользовательских типов.
  
```vb
Type VB_User_Type
    i As Integer
    d As Double
    s As String
End Type

```

```cpp
#pragma pack(4)
struct C_user_type
{
    short iVal;
    double dVal;
    BSTR bstr; // VBA String type is a byte string
}
#pragma pack() // restore default

```

В некоторых случаях VBA поддерживает больший диапазон значений, чем Excel. Тип Double в VBA соответствует стандарту IEEE и поддерживает поднормальные числа, которые в настоящий момент округляются до нуля на листе. Тип **Date** в VBA может представлять даты с 1-Jan-0100 с помощью отрицательных сериализованных дат. Excel поддерживает только нулевые или положительные сериализованные даты. Тип **Currency** в VBA — масштабируемое 64-разрядное целое число — может достигать точности, не поддерживаемой 8-байтовыми числами двойной точности, поэтому не он сопоставляется на листе. 
  
Excel передает только значения Variant указанных ниже типов в определяемую пользователем функцию VBA.
  
|**Тип данных VBA**|**Битовые флаги типа Variant C/C++**|**Описание**|
|:-----|:-----|:-----|
|Double  <br/> |**VT_R8** <br/> ||
|Boolean  <br/> |**VT_BOOL** <br/> ||
|Date  <br/> |**VT_DATE** <br/> ||
|String  <br/> |**VT_BSTR** <br/> |Строка байтов OLE Bstr  <br/> |
|Диапазон  <br/> |**VT_DISPATCH** <br/> |Ссылки на ячейку и диапазон  <br/> |
|Переменная, содержащая массив  <br/> |**VT_ARRAY** | **VT_VARIANT** <br/> |Литеральные массивы  <br/> |
|Ccy  <br/> |**VT_CY** <br/> |64-битное целое число, масштабированное для достижения точности 4 знака после запятой.  <br/> |
|Переменная, содержащая ошибку  <br/> |**VT_ERROR** <br/> ||
||**VT_EMPTY** <br/> |Пустые ячейки или пропущенные аргументы  <br/> |
   
Вы можете проверить тип переданного значения Variant в VBA с помощью **VarType**, если функция не возвращает тип значений диапазона при вызове с использованием ссылок. Чтобы определить, является ли **Variant** объектом ссылки **Range**, используйте функцию **IsObject**. 
  
Вы можете создавать **Variants**, которые содержат массивы variant в VBA, из объекта **Range**, назначив его свойство **Value** для **Variant**. Все ячейки в исходном диапазоне, отформатированные с помощью стандартного формата валюты для действующих региональных параметров, будут преобразованы в элементы массива типа **Currency**. Все ячейки, отформатированные как даты, преобразуются в элементы массива типа **Date**. Ячейки, содержащие строки, преобразуются в Variant типа **BSTR** с расширенными символами. Ячейки с ошибками преобразуются в объекты **Variants** типа **VT_ERROR**. Ячейки, содержащие значения **True или ** **False** типа **Boolean**, преобразуются в объекты **Variants** типа **VT_BOOL**. 
  
> [!NOTE]
> В **Variant** значение **True** сохраняется как -1, а **False** — как 0. Числа, не отформатированные как даты или денежные суммы, преобразуются в Variant типа **VT_R8**. 
  
### <a name="variant-and-string-arguments"></a>Аргументы строк и переменных

Excel внутренне работает со строками Юникода из расширенных символов. Когда пользовательская функция VBA объявляется как принимающая аргумент **String**, Excel преобразует предоставленную строку в байтовую строку в соответствии с региональными стандартами. Если вам нужно, чтобы функции передавалась строка Юникода, пользовательская функция VBA должна принимать **Variant** вместо аргумента **String**. Тогда функция DLL сможет принять эту строку BSTR из расширенных символов типа **Variant** из VBA. 
  
Чтобы из DLL возвращались строки Юникода в VBA, следует изменить имеющийся аргумент строки **Variant**. Для этого следует объявить функцию DLL как принимающую указатель на **Variant** в коде C/C++, а также объявить аргумент в коде VBA как `ByRef varg As Variant`. Память предыдущей строки следует освободить, а значение новой строки, созданное с использованием строки OLE Bstr, работает только в DLL.
  
Чтобы байтовая строка возвращалась в VBA из DLL, следует изменить имеющийся аргумент BSTR байтовой строки. Для этого следует объявить функцию DLL как принимающую указатель на BSTR в коде C/C++, а также объявить аргумент в коде VBA как **ByRef varg As String**.
  
Строки, переданные такими способами из VBA, следует обрабатывать только с помощью строковых функций BSTR OLE. Это позволит избежать проблем, связанных с памятью. Например, необходимо вызывать функцию **SysFreeString**, чтобы освободить память, прежде чем перезаписывать переданную строку, и функцию **SysAllocStringByteLen** или **SysAllocStringLen**, чтобы выделить место для новой строки. 
  
Вы можете создавать ошибки листов Excel как **Variants** в VBA с помощью функции **CVerr** с аргументами, показанными в следующей таблице. Ошибки листов также можно возвращать в VBA из DLL с помощью объектов **Variants** типа **VT_ERROR** со следующими значениями в поле **ulVal**. 
  
|**Ошибка**|**Значение Variant ulVal**|**Аргумент CVerr**|
|:-----|:-----|:-----|
|#NULL!  <br/> |2148141008  <br/> |2000  <br/> |
|#ДЕЛ/0!  <br/> |2148141015  <br/> |2007  <br/> |
|#ЗНАЧ!  <br/> |2148141023  <br/> |2015  <br/> |
|#ССЫЛКА!  <br/> |2148141031  <br/> |2023  <br/> |
|#ИМЯ?  <br/> |2148141037  <br/> |2029  <br/> |
|#ЧИСЛО!  <br/> |2148141044  <br/> |2036  <br/> |
|#Н/Д  <br/> |2148141050  <br/> |2042  <br/> |
   
Обратите внимание на то, что значение Variant **ulVal** эквивалентно значению аргумента **CVerr** с шестнадцатеричным значением x800A0000. 
  
## <a name="calling-dll-functions-directly-from-the-worksheet"></a>Вызов функций DLL непосредственно с листа

Вы не сможете получить доступ к функциям DLL Win32 с листа, если не используете, к примеру, интерфейсы VBA или XLM либо не сообщите Excel заранее о функции, ее аргументах и типе возвращаемого значения. Этот процесс называется регистрацией.
  
Ниже приведены способы, которыми можно получить доступ к функциям DLL на листе.
  
- Объявите функцию в VBA, как показано выше, и получите доступ к ней через пользовательскую функцию VBA.
    
- Сначала обеспечьте вызов функции DLL с помощью CALL на листе макросов XLM, а затем — доступ к ней с помощью определяемой пользователем функции XLM.
    
- Используйте команду XLM или VBA, чтобы вызвать функцию XLM **REGISTER**, которая предоставляет сведения, необходимые Excel для опознания функции при ее вводе в ячейке листа. 
    
- Преобразуйте DLL в XLL и зарегистрируйте функцию с помощью функции **xlfRegister** C API после активации XLL. 
    
Четвертый подход изолированный: код, регистрирующий функции, и код функций хранятся в одном объекте кода. Изменение надстройки не включает изменение листа XLM или модуля кода VBA. Чтобы сделать это с широкими возможностями управления, оставаясь в рамках возможностей API C, необходимо преобразовать DLL в XLL и загрузить получившуюся надстройку с помощью диспетчера настроек. Это позволяет Excel вызывать функцию, предоставленную библиотекой DLL, при загрузке или активации надстройки, из которой затем можно зарегистрировать все функции, которые содержит XLL, и выполнять другие задачи инициализации DLL.
  
## <a name="calling-dll-commands-directly-from-excel"></a>Вызов команд DLL непосредственно из Excel

Команды DLL Win32 недоступны напрямую из диалоговых окон и меню Excel без интерфейса, например VBA, или без предварительной регистрации команд.
  
Получать доступ к командам DLL можно следующими способами:
  
- Объявите команду в VBA так, как описано выше, и получите к ней доступ с помощью макроса VBA.
    
- Сначала обеспечьте вызов команды DLL с помощью **CALL** на листе макросов XLM, а затем — доступ к ней с помощью макроса XLM. 
    
- Используйте команду XLM или VBA, чтобы вызвать функцию XLM **REGISTER**, которая предоставляет сведения, необходимые Excel для опознания команды при ее вводе в диалоговом окне, которое запрашивает имя команды макроса. 
    
- Преобразуйте DLL в XLL и зарегистрируйте команду с помощью функции **xlfRegister** C API. 
    
Как упоминалось ранее в контексте функций DLL, четвертый подход является самым изолированным, так как код регистрации хранится наряду с кодом команд. Для этого необходимо преобразовать DLL в XLL и загрузить получившуюся надстройку с помощью диспетчера надстроек. Регистрация команд таким способом также позволяет присоединить команду к элементу пользовательского интерфейса, например пользовательскому меню, или настроить перехват события с вызовом команды по нажатию определенной клавиши или другому событию.
  
Приложение Excel обрабатывает все команды XLL, зарегистрированные в нем, как имеющие такой вид:
  
```cpp
int WINAPI my_xll_cmd(void)
{
// Function code...
    return 1;
}
```

> [!NOTE]
> Excel игнорирует возвращаемое значение, если оно не вызывается с листа макросов XLM. В этом случае возвращаемое значение преобразуется в значение **TRUE** или **FALSE**. Таким образом, следует возвращать значение 1, если команда выполнена успешно, и 0, если она завершилась с ошибкой или была отменена пользователем. 
  
## <a name="dll-memory-and-multiple-dll-instances"></a>Память DLL и многочисленные экземпляры DLL

Когда приложение загружает DLL, исполняемый код DLL загружается в глобальную кучу для выполнения, а для его структур данных назначается место в глобальной куче. Windows использует сопоставление памяти, чтобы эти области памяти отображались, как в процессе приложения. Таким образом приложение может получать к ним доступ.
  
Если второе приложение загружает эту библиотеку DLL, Windows не создает дополнительную копию исполняемого кода DLL, так как эта память доступна только для чтения. Windows сопоставляет память исполняемого кода DLL с процессами обоих приложений. Но при этом Windows выделяет другое место для частной копии структур данных DLL и сопоставляет эту копию только со вторым процессом. Благодаря этому одно приложение не может конфликтовать с данными DLL другого.
  
Это означает, что разработчикам DLL не следует беспокоиться, что несколько приложений (или несколько экземпляров одного приложения) будут получать доступ к статическим и глобальным переменным и структурам данных. Каждый экземпляр всех приложений получает собственную копию данных DLL.
  
Разработчикам DLL следует позаботиться о том, чтобы один и тот же экземпляр приложения не вызывал DLL много раз из разных потоков, так как это может привести к состязанию за данные этого экземпляра. Дополнительные сведения см. в статье [Управление памятью в Excel](memory-management-in-excel.md).
  
## <a name="see-also"></a>См. также

- [Разработка библиотек DLL](developing-dlls.md) 
- [Вызов Excel из библиотеки DLL или XLL](calling-into-excel-from-the-dll-or-xll.md)

