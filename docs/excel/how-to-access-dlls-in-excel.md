---
title: Доступ к библиотекам DLL в Excel
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
ms.topic: overview
keywords:
- доступ к библиотекам DLL [Excel 2007], библиотеки DLL [Excel 2007], доступ в Excel
localization_priority: Normal
ms.assetid: e2bfd6ea-efa3-45c1-a5b8-2ccb8650c6ab
description: 'Относится к: Excel 2013 | Office 2013 | Visual Studio'
ms.openlocfilehash: bfb562b6bbe824124c6b5a691745d076720ee004
ms.sourcegitcommit: 9d60cd82b5413446e5bc8ace2cd689f683fb41a7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/11/2018
ms.locfileid: "19807261"
---
# <a name="access-dlls-in-excel"></a>Доступ к библиотекам DLL в Excel

**Относится к**: Excel 2013 | Office 2013 | Visual Studio 
  
Вы можете получить доступ к функции или команде DLL в Microsoft Excel несколькими способами:
  
- с помощью модуля кода Microsoft Visual Basic для приложений (VBA), в котором функция или команда была сделана доступной с помощью выражения **Declare**; 
    
- через лист макросов XLM, используя функции **CALL** или **REGISTER**; 
    
- непосредственно с листа или из настроенного элемента в пользовательском интерфейсе.
    
В этой документации не рассматриваются функции XLM. Рекомендуем использовать один из двух других подходов.
  
Для доступа к функции или команде непосредственно с листа или из настроенного элемента в пользовательском интерфейсе необходимо сначала зарегистрировать ее в Excel. Сведения о регистрации команд и функций см. в статье [Доступ к коду XLL в Excel](accessing-xll-code-in-excel.md).
  
## <a name="calling-dll-functions-and-commands-from-vba"></a>Вызов функций и команд DLL из VBA

Вы можете получать доступ к функциям и командам DLL в VBA с помощью оператора **Declare**. В случае этого оператора предусмотрен один синтаксис для команд, а другой — для функций. 
  
- **Синтаксис 1: команды**
    
  ```vb
  [Public | Private] Declare Sub name Lib "libname" [Alias "aliasname"] [([arglist])]
  ```

- **Синтаксис 2: функции**
    
  ```vb
  [Public | Private] Declare Function name Lib "libname" [Alias "aliasname"] [([arglist])] [As type]
  ```

Необязательные ключевые слова **Public** и **Private** определяют область импортированной функции (весь проект Visual Basic и модуль Visual Basic соответственно). Имя — это имя, которое вы хотите использовать в коде VBA. Если оно отличается от имени в библиотеке DLL, необходимо использовать указатель Alias "aliasname" и предоставить имя функции, экспортируемое библиотекой DLL. Для доступа к функции DLL с помощью ссылки на порядковый номер DLL необходимо предоставить псевдоним, который является порядковым номером с префиксом **#**.
  
Команды должны возвратить **void**. Функции должны возвращать типы, которые VBA может распознавать с помощью **ByVal**. Это означает, что некоторые типы легче возвращаются за счет изменения имеющихся аргументов (строк, массивов, определяемых пользователем типов и объектов).
  
> [!NOTE]
> VBA не может проверить совпадение списка аргументов и возвращаемого значения в модуле Visual Basic со значениями, закодированными в DLL. Это необходимо внимательно проверить самостоятельно, поскольку ошибка может привести к сбою Excel. 
  
Если аргументы команды или функции не передаются с помощью ссылки или указателя, они должны стоять после ключевого слова **ByVal** в объявлении **arglist**. Когда функция C/C++ принимает аргументы указателя или функция C++ принимает аргументы ссылки, они должны передаваться **ByRef**. Ключевое слово **ByRef** можно пропустить в списке аргументов, так как оно используется по умолчанию в VBA. 
  
### <a name="argument-types-in-cc-and-vba"></a>Типы аргументов в C/C++ и VBA

Следует помнить об указанных ниже фактах при сравнении объявлений типов аргументов в C/C++ и VBA.
  
- Тип **String** в VBA передается как указатель на структуру BSTR байтовых строк в режиме ByVal и как указатель на указатель в режиме **ByRef**.
    
- Тип **Variant** в VBA, содержащий строку, передается как указатель на структуру BSTR строк Юникода из двухбайтовых знаков при передаче в режиме **ByVal** и как указатель на указатель в режиме **ByRef**.
    
- **Integer** VBA — это 16-битный тип, эквивалентный signed short в C/C++. 
    
- **Long** VBA — это 32-битный тип, эквивалентный signed int в C/C++. 
    
- VBA и C/C++ допускают определяемые пользователем типы данных (применяются операторы **Type** и **struct** соответственно). 
    
- VBA и C/C++ поддерживают тип данных **Variant**, заданный для C/C++ в файлах заголовка Windows OLE/COM как VARIANT. 
    
- Массивы VBA — это объекты OLE **SafeArrays**, определенные для C/C++ в файлах заголовка Windows OLE/COM как **SAFEARRAY**.
    
- Тип данных **Currency** в VBA передается как структура типа **CY**, определенная в файле заголовка Windows wtypes.h, в режиме **ByVal** и как указатель на него в режиме **ByRef**.
    
В VBA элементы данных в определяемых пользователем типах данных упаковываются с учетом 4-байтовых границ, тогда как в Visual Studio по умолчанию они упаковываются с учетом 8-байтовых границ. Поэтому необходимо заключить определение структуры C/C++ в блок `#pragma pack(4) … #pragma pack()`, чтобы избежать несовпадения элементов. 
  
Ниже приведен пример определений эквивалентных пользовательских типов.
  
```vb
Type VB_User_Type
    i As Integer
    d As Double
    s As String
End Type

```

```cpp
#pragma pack(4)
struct C_user_type
{
    short iVal;
    double dVal;
    BSTR bstr; // VBA String type is a byte string
}
#pragma pack() // restore default

```

В некоторых случаях VBA поддерживает более широкий диапазон значений, чем Excel. Тип данных Double в VBA соответствует требованиям IEEE и поддерживает субнормальные числа, которые в настоящее время на листе округляются до нуля. Тип **Date** в VBA представляет даты от 1 января 0100 года, которые можно задать с помощью отрицательных сериализованных значений дат. Excel поддерживает сериализованные даты не меньше нуля. Тип **Currency** в VBA (64-битное масштабированное целое число) позволяет добиться точности, не поддерживаемой 8-байтовыми значениями Double, и поэтому не имеет совпадений на листе. 
  
Excel передает только значения Variant указанных ниже типов в определяемую пользователем функцию VBA.
  
|**Тип данных VBA**|**Битовые флаги типа Variant C/C++**|**Описание**|
|:-----|:-----|:-----|
|Double  <br/> |**VT_R8** <br/> ||
|Boolean  <br/> |**VT_BOOL** <br/> ||
|Date  <br/> |**VT_DATE** <br/> ||
|String  <br/> |**VT_BSTR** <br/> |Строка байтов OLE Bstr  <br/> |
|Диапазон  <br/> |**VT_DISPATCH** <br/> |Ссылки на ячейку и диапазон  <br/> |
|Переменная, содержащая массив  <br/> |**VT_ARRAY** | **VT_VARIANT** <br/> |Литеральные массивы  <br/> |
|Ccy  <br/> |**VT_CY** <br/> |64-битное целое число, масштабированное для достижения точности 4 знака после запятой.  <br/> |
|Переменная, содержащая ошибку  <br/> |**VT_ERROR** <br/> ||
||**VT_EMPTY** <br/> |Пустые ячейки или пропущенные аргументы  <br/> |
   
Вы можете проверить тип переданного значения Variant в VBA с помощью **VarType**, если функция не возвращает тип значений диапазона при вызове с использованием ссылок. Чтобы определить, является ли **Variant** объектом ссылки **Range**, используйте функцию **IsObject**. 
  
В VBA можно создавать **Variant**, содержащие массивы переменных, назначая свойство **Value** **Range** для **Variant**. Ячейки в исходном диапазоне, отформатированные с использованием стандартного денежного формата для действующих региональных параметров, преобразуются в элементы массива типа **Currency**. Ячейки, отформатированные как даты, преобразуются в элементы массива типа **Date**. Ячейки, содержащие строки, преобразуются в Variant **BSTR** с расширенными символами. Ячейки, содержащие ошибки, преобразуются в **Variant** типа **VT_ERROR**. Ячейки, содержащие значения **True** или **False** типа **Boolean**, преобразуются в **Variant** типа **VT_BOOL**. 
  
> [!NOTE]
> В **Variant** значение **True** сохраняется как -1, а **False** — как 0. Числа, не отформатированные как даты или денежные суммы, преобразуются в Variant типа **VT_R8**. 
  
### <a name="variant-and-string-arguments"></a>Аргументы строк и переменных

Excel поддерживает внутреннюю работу со строками Юникода с расширенными символами. Когда определяемая пользователем функция в VBA объявлена как принимающая аргумент **String**, Excel преобразует передаваемую строку в байтовую строку в соответствии с языковым стандартом. Чтобы функции передавалась строка Юникода, определяемая пользователем функция в VBA должна принимать **Variant** вместо аргумента **String**. При выполнении этого условия функция DLL сможет принимать строку **Variant** BSTR с расширенными символами VBA. 
  
Чтобы из DLL возвращались строки Юникода в VBA, следует изменить имеющийся аргумент строки **Variant**. Для этого следует объявить функцию DLL как принимающую указатель на **Variant** в коде C/C++, а также объявить аргумент в коде VBA как `ByRef varg As Variant`. Память предыдущей строки следует освободить, а значение новой строки, созданное с использованием строки OLE Bstr, работает только в DLL.
  
Чтобы байтовая строка возвращалась в VBA из DLL, следует изменить имеющийся аргумент BSTR байтовой строки. Для этого следует объявить функцию DLL как принимающую указатель на BSTR в коде C/C++, а также объявить аргумент в коде VBA как **ByRef varg As String**.
  
Чтобы избежать проблем, связанных с памятью, необходимо обеспечить обработку только строк, которые передаются этими способами из VBA, используя функции строки OLE BSTR. Например, необходимо обеспечить вызов **SysFreeString** для освобождения памяти перед перезаписью переданной строки, а также **SysAllocStringByteLen** или **SysAllocStringLen**, чтобы назначить место для новой строки. 
  
Вы можете обеспечить создание сообщений об ошибках на листе Excel как **Variant** в VBA при помощи функции **CVerr** с аргументами, как показано в приведенной ниже таблице. Ошибки на листе также могут быть возвращены в VBA из DLL при помощи **Variant** типа **VT_ERROR**, а также с указанными ниже значениями в поле **ulVal**. 
  
|**Ошибка**|**Значение Variant ulVal**|**Аргумент CVerr**|
|:-----|:-----|:-----|
|#NULL!  <br/> |2148141008  <br/> |2000  <br/> |
|#ДЕЛ/0!  <br/> |2148141015  <br/> |2007  <br/> |
|#ЗНАЧ!  <br/> |2148141023  <br/> |2015  <br/> |
|#ССЫЛКА!  <br/> |2148141031  <br/> |2023  <br/> |
|#ИМЯ?  <br/> |2148141037  <br/> |2029  <br/> |
|#ЧИСЛО!  <br/> |2148141044  <br/> |2036  <br/> |
|#Н/Д  <br/> |2148141050  <br/> |2042  <br/> |
   
Обратите внимание на то, что значение Variant **ulVal** эквивалентно значению аргумента **CVerr** с шестнадцатеричным значением x800A0000. 
  
## <a name="calling-dll-functions-directly-from-the-worksheet"></a>Вызов функций DLL непосредственно с листа

Вы не сможете получить доступ к функциям DLL Win32 с листа, если не используете, к примеру, интерфейсы VBA или XLM либо не сообщите Excel заранее о функции, ее аргументах и типе возвращаемого значения. Этот процесс называется регистрацией.
  
Ниже приведены способы, которыми можно получить доступ к функциям DLL на листе.
  
- Объявите функцию в VBA, как показано выше, и получите доступ к ней через пользовательскую функцию VBA.
    
- Сначала обеспечьте вызов функции DLL с помощью CALL на листе макросов XLM, а затем — доступ к ней с помощью определяемой пользователем функции XLM.
    
- Используйте команду XLM или VBA, чтобы вызвать функцию XLM **REGISTER**, которая предоставляет сведения, необходимые Excel для опознания функции при ее вводе в ячейке листа. 
    
- Преобразуйте DLL в XLL и зарегистрируйте функцию с помощью функции **xlfRegister** C API после активации XLL. 
    
Четвертый подход изолированный: код, регистрирующий функции, и код функций хранятся в одном объекте кода. Изменение надстройки не включает изменение листа XLM или модуля кода VBA. Чтобы сделать это с широкими возможностями управления, оставаясь в рамках возможностей API C, необходимо преобразовать DLL в XLL и загрузить получившуюся надстройку с помощью диспетчера настроек. Это позволяет Excel вызывать функцию, предоставленную библиотекой DLL, при загрузке или активации надстройки, из которой затем можно зарегистрировать все функции, которые содержит XLL, и выполнять другие задачи инициализации DLL.
  
## <a name="calling-dll-commands-directly-from-excel"></a>Вызов команд DLL непосредственно из Excel

Команды DLL Win32 недоступны напрямую из диалоговых окон и меню Excel без интерфейса, например VBA, или без предварительной регистрации команд.
  
Получать доступ к командам DLL можно следующими способами:
  
- Объявите команду в VBA так, как описано выше, и получите к ней доступ с помощью макроса VBA.
    
- Сначала обеспечьте вызов команды DLL с помощью **CALL** на листе макросов XLM, а затем — доступ к ней с помощью макроса XLM. 
    
- Используйте команду XLM или VBA, чтобы вызвать функцию XLM **REGISTER**, которая предоставляет сведения, необходимые Excel для опознания команды при ее вводе в диалоговом окне, которое запрашивает имя команды макроса. 
    
- Преобразуйте DLL в XLL и зарегистрируйте команду с помощью функции **xlfRegister** C API. 
    
Как упоминалось ранее в контексте функций DLL, четвертый подход является самым изолированным, так как код регистрации хранится наряду с кодом команд. Для этого необходимо преобразовать DLL в XLL и загрузить получившуюся надстройку с помощью диспетчера надстроек. Регистрация команд таким способом также позволяет присоединить команду к элементу пользовательского интерфейса, например пользовательскому меню, или настроить перехват события с вызовом команды по нажатию определенной клавиши или другому событию.
  
Приложение Excel обрабатывает все команды XLL, зарегистрированные в нем, как имеющие такой вид:
  
```cpp
int WINAPI my_xll_cmd(void)
{
// Function code...
    return 1;
}
```

> [!NOTE]
> Excel игнорирует возвращаемое значение, если оно не было вызвано с листа макросов XLM. Если оно было вызвано так, возвращаемое значение преобразуется в **TRUE** или **FALSE**. Поэтому следует обеспечить возвращение 1 при успешном выполнении команды и 0 при ошибке или отмене команды. 
  
## <a name="dll-memory-and-multiple-dll-instances"></a>Память DLL и многочисленные экземпляры DLL

Когда приложение загружает DLL, исполняемый код DLL загружается в глобальную кучу для выполнения, а для его структур данных назначается место в глобальной куче. Windows использует сопоставление памяти, чтобы эти области памяти отображались, как в процессе приложения. Таким образом приложение может получать к ним доступ.
  
Если второе приложение загружает эту библиотеку DLL, Windows не создает дополнительную копию исполняемого кода DLL, так как эта память доступна только для чтения. Windows сопоставляет память исполняемого кода DLL с процессами обоих приложений. Но при этом Windows выделяет другое место для частной копии структур данных DLL и сопоставляет эту копию только со вторым процессом. Благодаря этому одно приложение не может конфликтовать с данными DLL другого.
  
Это означает, что разработчикам DLL не следует беспокоиться, что несколько приложений (или несколько экземпляров одного приложения) будут получать доступ к статическим и глобальным переменным и структурам данных. Каждый экземпляр всех приложений получает собственную копию данных DLL.
  
Разработчикам DLL следует позаботиться о том, чтобы один и тот же экземпляр приложения не вызывал DLL много раз из разных потоков, так как это может привести к состязанию за данные этого экземпляра. Дополнительные сведения см. в статье [Управление памятью в Excel](memory-management-in-excel.md).
  
## <a name="see-also"></a>См. также

- [Разработка библиотек DLL](developing-dlls.md) 
- [Вызов Excel из библиотеки DLL или XLL](calling-into-excel-from-the-dll-or-xll.md)

