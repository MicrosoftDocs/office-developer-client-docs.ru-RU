---
title: Доступ к библиотекам DLL в Excel
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
ms.topic: overview
keywords:
- доступ к библиотекам DLL [Excel 2007], библиотеки DLL [Excel 2007], доступ в Excel
ms.assetid: e2bfd6ea-efa3-45c1-a5b8-2ccb8650c6ab
description: 'Относится к: Excel 2013 | Office 2013 | Visual Studio'
localization_priority: Priority
ms.openlocfilehash: fac4ad30048aa1bf3879009bc97ea46a112a9ce5
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32304013"
---
# <a name="access-dlls-in-excel"></a><span data-ttu-id="7e4c6-104">Доступ к библиотекам DLL в Excel</span><span class="sxs-lookup"><span data-stu-id="7e4c6-104">Access DLLs in Excel</span></span>

<span data-ttu-id="7e4c6-105">**Относится к**: Excel 2013 | Office 2013 | Visual Studio</span><span class="sxs-lookup"><span data-stu-id="7e4c6-105">**Applies to**: Excel 2013 | Office 2013 | Visual Studio</span></span> 
  
<span data-ttu-id="7e4c6-106">Вы можете получить доступ к функции или команде DLL в Microsoft Excel несколькими способами:</span><span class="sxs-lookup"><span data-stu-id="7e4c6-106">You can access a DLL function or command in Microsoft Excel in several ways:</span></span>
  
- <span data-ttu-id="7e4c6-107">с помощью модуля кода Microsoft Visual Basic для приложений (VBA), в котором функция или команда была сделана доступной с помощью выражения **Declare**;</span><span class="sxs-lookup"><span data-stu-id="7e4c6-107">Through a Microsoft Visual Basic for Applications (VBA) code module in which the function or command has been made available using a **Declare** statement.</span></span> 
    
- <span data-ttu-id="7e4c6-108">через лист макросов XLM, используя функции **CALL** или **REGISTER**;</span><span class="sxs-lookup"><span data-stu-id="7e4c6-108">Through an XLM macro sheet by using the **CALL** or **REGISTER** functions.</span></span> 
    
- <span data-ttu-id="7e4c6-109">непосредственно с листа или из настроенного элемента в пользовательском интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-109">Directly from the worksheet or from a customized item in the user interface (UI).</span></span>
    
<span data-ttu-id="7e4c6-p101">В этой документации не рассматриваются функции XLM. Рекомендуем использовать один из двух других подходов.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-p101">This documentation does not cover XLM functions. It is recommended that you use either of the other two approaches.</span></span>
  
<span data-ttu-id="7e4c6-112">Для доступа к функции или команде непосредственно с листа или из настроенного элемента в пользовательском интерфейсе необходимо сначала зарегистрировать ее в Excel.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-112">To be accessed directly from the worksheet or from a customized item in the UI, the function or command must first be registered with Excel.</span></span> <span data-ttu-id="7e4c6-113">Сведения о регистрации команд и функций см. в статье [Доступ к коду XLL в Excel](accessing-xll-code-in-excel.md).</span><span class="sxs-lookup"><span data-stu-id="7e4c6-113">For information about registering commands and functions, see [Accessing XLL Code in Excel](accessing-xll-code-in-excel.md).</span></span>
  
## <a name="calling-dll-functions-and-commands-from-vba"></a><span data-ttu-id="7e4c6-114">Вызов функций и команд DLL из VBA</span><span class="sxs-lookup"><span data-stu-id="7e4c6-114">Calling DLL functions and commands from VBA</span></span>

<span data-ttu-id="7e4c6-115">Вы можете получать доступ к функциям и командам DLL в VBA с помощью оператора **Declare**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-115">You can access DLL functions and commands in VBA by using the **Declare** statement.</span></span> <span data-ttu-id="7e4c6-116">В случае этого оператора предусмотрен один синтаксис для команд, а другой — для функций.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-116">This statement has one syntax for commands and one for functions.</span></span> 
  
- <span data-ttu-id="7e4c6-117">**Синтаксис 1: команды**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-117">**Syntax 1 - commands**</span></span>
    
  ```vb
  [Public | Private] Declare Sub name Lib "libname" [Alias "aliasname"] [([arglist])]
  ```

- <span data-ttu-id="7e4c6-118">**Синтаксис 2: функции**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-118">**Syntax 2 - functions**</span></span>
    
  ```vb
  [Public | Private] Declare Function name Lib "libname" [Alias "aliasname"] [([arglist])] [As type]
  ```

<span data-ttu-id="7e4c6-119">Необязательные ключевые слова **Public** и **Private** определяют область импортированной функции (весь проект Visual Basic и модуль Visual Basic соответственно).</span><span class="sxs-lookup"><span data-stu-id="7e4c6-119">The optional **Public** and **Private** keywords specify the scope of the imported function: the entire Visual Basic project or just the Visual Basic module, respectively.</span></span> <span data-ttu-id="7e4c6-120">Имя — это имя, которое вы хотите использовать в коде VBA.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-120">The name is the name that you want to use in the VBA code.</span></span> <span data-ttu-id="7e4c6-121">Если оно отличается от имени в библиотеке DLL, необходимо использовать указатель Alias "aliasname" и предоставить имя функции, экспортируемое библиотекой DLL.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-121">If this differs from the name in the DLL, you must use the Alias "aliasname" specifier, and you should give the name of the function as exported by the DLL.</span></span> <span data-ttu-id="7e4c6-122">Для доступа к функции DLL с помощью ссылки на порядковый номер DLL необходимо предоставить псевдоним, который является порядковым номером с префиксом **#**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-122">If you want to access a DLL function by reference to a DLL ordinal number, you must provide an alias name, which is the ordinal prefixed by **#**.</span></span>
  
<span data-ttu-id="7e4c6-123">Команды должны возвратить **void**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-123">Commands should return **void**.</span></span> <span data-ttu-id="7e4c6-124">Функции должны возвращать типы, которые VBA может распознавать с помощью **ByVal**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-124">Functions should return types that VBA can recognize **ByVal**.</span></span> <span data-ttu-id="7e4c6-125">Это означает, что некоторые типы легче возвращаются за счет изменения имеющихся аргументов (строк, массивов, определяемых пользователем типов и объектов).</span><span class="sxs-lookup"><span data-stu-id="7e4c6-125">This means that some types are more easily returned by modifying arguments in place: strings, arrays, user-defined types, and objects.</span></span>
  
> [!NOTE]
> <span data-ttu-id="7e4c6-p106">VBA не может проверить совпадение списка аргументов и возвращаемого значения в модуле Visual Basic со значениями, закодированными в DLL. Это необходимо внимательно проверить самостоятельно, поскольку ошибка может привести к сбою Excel.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-p106">VBA cannot check that the argument list and return stated in the Visual Basic module are the same as coded in the DLL. You should check this yourself very carefully, because a mistake could cause Excel to crash.</span></span> 
  
<span data-ttu-id="7e4c6-128">Если аргументы команды или функции не передаются с помощью ссылки или указателя, они должны стоять после ключевого слова **ByVal** в объявлении **arglist**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-128">When the function or command's arguments are not passed by reference or pointer, they must be preceded by the **ByVal** keyword in the **arglist** declaration.</span></span> <span data-ttu-id="7e4c6-129">Когда функция C/C++ принимает аргументы указателя или функция C++ принимает аргументы ссылки, они должны передаваться **ByRef**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-129">When a C/C++ function takes pointer arguments, or a C++ function takes reference arguments, they should be passed **ByRef**.</span></span> <span data-ttu-id="7e4c6-130">Ключевое слово **ByRef** можно пропустить в списке аргументов, так как оно используется по умолчанию в VBA.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-130">The keyword **ByRef** can be omitted from argument lists because it is the default in VBA.</span></span> 
  
### <a name="argument-types-in-cc-and-vba"></a><span data-ttu-id="7e4c6-131">Типы аргументов в C/C++ и VBA</span><span class="sxs-lookup"><span data-stu-id="7e4c6-131">Argument types in C/C++ and VBA</span></span>

<span data-ttu-id="7e4c6-132">Следует помнить об указанных ниже фактах при сравнении объявлений типов аргументов в C/C++ и VBA.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-132">You should note the following when you compare the declarations of argument types in C/C++ and VBA.</span></span>
  
- <span data-ttu-id="7e4c6-133">Тип **String** в VBA передается как указатель на структуру BSTR байтовых строк в режиме ByVal и как указатель на указатель в режиме **ByRef**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-133">A VBA **String** is passed as a pointer to a byte-string BSTR structure when passed ByVal, and as a pointer to a pointer when passed **ByRef**.</span></span>
    
- <span data-ttu-id="7e4c6-134">Тип **Variant** в VBA, содержащий строку, передается как указатель на структуру BSTR строк Юникода из двухбайтовых знаков при передаче в режиме **ByVal** и как указатель на указатель в режиме **ByRef**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-134">A VBA **Variant** that contains a string is passed as a pointer to a Unicode wide-character string BSTR structure when passed **ByVal**, and as a pointer to a pointer when passed **ByRef**.</span></span>
    
- <span data-ttu-id="7e4c6-135">**Integer** VBA — это 16-битный тип, эквивалентный signed short в C/C++.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-135">The VBA **Integer** is a 16-bit type equivalent to a signed short in C/C++.</span></span> 
    
- <span data-ttu-id="7e4c6-136">**Long** VBA — это 32-битный тип, эквивалентный signed int в C/C++.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-136">The VBA **Long** is a 32-bit type equivalent to a signed int in C/C++.</span></span> 
    
- <span data-ttu-id="7e4c6-137">VBA и C/C++ допускают определяемые пользователем типы данных (применяются операторы **Type** и **struct** соответственно).</span><span class="sxs-lookup"><span data-stu-id="7e4c6-137">Both VBA and C/C++ allow the definition of user-defined data types, using the **Type** and **struct** statements respectively.</span></span> 
    
- <span data-ttu-id="7e4c6-138">VBA и C/C++ поддерживают тип данных **Variant**, заданный для C/C++ в файлах заголовка Windows OLE/COM как VARIANT.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-138">Both VBA and C/C++ support the **Variant** data type, defined for C/C++ in the Windows OLE/COM header files as VARIANT.</span></span> 
    
- <span data-ttu-id="7e4c6-139">Массивы VBA — это объекты OLE **SafeArrays**, определенные для C/C++ в файлах заголовка Windows OLE/COM как **SAFEARRAY**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-139">VBA arrays are OLE **SafeArrays**, defined for C/C++ in the Windows OLE/COM header files as **SAFEARRAY**.</span></span>
    
- <span data-ttu-id="7e4c6-140">Тип данных **Currency** в VBA передается как структура типа **CY**, определенная в файле заголовка Windows wtypes.h, в режиме **ByVal** и как указатель на него в режиме **ByRef**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-140">The VBA **Currency** data type is passed as a structure of type **CY**, defined in the Windows header file wtypes.h, when passed **ByVal**, and as a pointer to this when passed **ByRef**.</span></span>
    
<span data-ttu-id="7e4c6-141">В VBA элементы данных в определяемых пользователем типах данных упаковываются с учетом 4-байтовых границ, тогда как в Visual Studio по умолчанию они упаковываются с учетом 8-байтовых границ.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-141">In VBA, data elements in user-defined data types are packed to 4-byte boundaries, whereas in Visual Studio, by default, they are packed to 8-byte boundaries.</span></span> <span data-ttu-id="7e4c6-142">Поэтому необходимо заключить определение структуры C/C++ в блок `#pragma pack(4) … #pragma pack()`, чтобы избежать несовпадения элементов.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-142">Therefore you must enclose the C/C++ structure definition in a `#pragma pack(4) … #pragma pack()` block to avoid elements being misaligned.</span></span> 
  
<span data-ttu-id="7e4c6-143">Ниже приведен пример определений эквивалентных пользовательских типов.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-143">The following is an example of equivalent user type definitions.</span></span>
  
```vb
Type VB_User_Type
    i As Integer
    d As Double
    s As String
End Type

```

```cpp
#pragma pack(4)
struct C_user_type
{
    short iVal;
    double dVal;
    BSTR bstr; // VBA String type is a byte string
}
#pragma pack() // restore default

```

<span data-ttu-id="7e4c6-144">В некоторых случаях VBA поддерживает более широкий диапазон значений, чем Excel.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-144">VBA supports a greater range of values in some cases than Excel supports.</span></span> <span data-ttu-id="7e4c6-145">Тип данных Double в VBA соответствует требованиям IEEE и поддерживает субнормальные числа, которые в настоящее время на листе округляются до нуля.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-145">The VBA double is IEEE compliant, supporting subnormal numbers that are currently rounded down to zero on the worksheet.</span></span> <span data-ttu-id="7e4c6-146">Тип **Date** в VBA представляет даты от 1 января 0100 года, которые можно задать с помощью отрицательных сериализованных значений дат.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-146">The VBA **Date** type can represent dates as early as 1-Jan-0100 using negative serialized dates.</span></span> <span data-ttu-id="7e4c6-147">Excel поддерживает сериализованные даты не меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-147">Excel only allows serialized dates greater than or equal to zero.</span></span> <span data-ttu-id="7e4c6-148">Тип **Currency** в VBA (64-битное масштабированное целое число) позволяет добиться точности, не поддерживаемой 8-байтовыми значениями Double, и поэтому не имеет совпадений на листе.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-148">The VBA **Currency** type—a scaled 64-bit integer—can achieve accuracy not supported in 8-byte doubles, and so is not matched in the worksheet.</span></span> 
  
<span data-ttu-id="7e4c6-149">Excel передает только значения Variant указанных ниже типов в определяемую пользователем функцию VBA.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-149">Excel only passes Variants of the following types to a VBA user-defined function.</span></span>
  
|<span data-ttu-id="7e4c6-150">**Тип данных VBA**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-150">**VBA data type**</span></span>|<span data-ttu-id="7e4c6-151">**Битовые флаги типа Variant C/C++**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-151">**C/C++ Variant type bit flags**</span></span>|<span data-ttu-id="7e4c6-152">**Описание**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-152">**Description**</span></span>|
|:-----|:-----|:-----|
|<span data-ttu-id="7e4c6-153">Double</span><span class="sxs-lookup"><span data-stu-id="7e4c6-153">Double</span></span>  <br/> |<span data-ttu-id="7e4c6-154">**VT_R8**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-154">**VT_R8**</span></span> <br/> ||
|<span data-ttu-id="7e4c6-155">Boolean</span><span class="sxs-lookup"><span data-stu-id="7e4c6-155">Boolean</span></span>  <br/> |<span data-ttu-id="7e4c6-156">**VT_BOOL**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-156">**VT_BOOL**</span></span> <br/> ||
|<span data-ttu-id="7e4c6-157">Date</span><span class="sxs-lookup"><span data-stu-id="7e4c6-157">Date</span></span>  <br/> |<span data-ttu-id="7e4c6-158">**VT_DATE**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-158">**VT_DATE**</span></span> <br/> ||
|<span data-ttu-id="7e4c6-159">String</span><span class="sxs-lookup"><span data-stu-id="7e4c6-159">String</span></span>  <br/> |<span data-ttu-id="7e4c6-160">**VT_BSTR**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-160">**VT_BSTR**</span></span> <br/> |<span data-ttu-id="7e4c6-161">Строка байтов OLE Bstr</span><span class="sxs-lookup"><span data-stu-id="7e4c6-161">OLE Bstr byte string</span></span>  <br/> |
|<span data-ttu-id="7e4c6-162">Диапазон</span><span class="sxs-lookup"><span data-stu-id="7e4c6-162">Range</span></span>  <br/> |<span data-ttu-id="7e4c6-163">**VT_DISPATCH**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-163">**VT_DISPATCH**</span></span> <br/> |<span data-ttu-id="7e4c6-164">Ссылки на ячейку и диапазон</span><span class="sxs-lookup"><span data-stu-id="7e4c6-164">Range and cell references</span></span>  <br/> |
|<span data-ttu-id="7e4c6-165">Переменная, содержащая массив</span><span class="sxs-lookup"><span data-stu-id="7e4c6-165">Variant containing an array</span></span>  <br/> |<span data-ttu-id="7e4c6-166">**VT_ARRAY**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-166">**VT_ARRAY**</span></span> | <span data-ttu-id="7e4c6-167">**VT_VARIANT**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-167">**VT_VARIANT**</span></span> <br/> |<span data-ttu-id="7e4c6-168">Литеральные массивы</span><span class="sxs-lookup"><span data-stu-id="7e4c6-168">Literal arrays</span></span>  <br/> |
|<span data-ttu-id="7e4c6-169">Ccy</span><span class="sxs-lookup"><span data-stu-id="7e4c6-169">Ccy</span></span>  <br/> |<span data-ttu-id="7e4c6-170">**VT_CY**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-170">**VT_CY**</span></span> <br/> |<span data-ttu-id="7e4c6-171">64-битное целое число, масштабированное для достижения точности 4 знака после запятой.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-171">64-bit integer scaled to permit 4 decimal places of accuracy.</span></span>  <br/> |
|<span data-ttu-id="7e4c6-172">Переменная, содержащая ошибку</span><span class="sxs-lookup"><span data-stu-id="7e4c6-172">Variant containing an error</span></span>  <br/> |<span data-ttu-id="7e4c6-173">**VT_ERROR**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-173">**VT_ERROR**</span></span> <br/> ||
||<span data-ttu-id="7e4c6-174">**VT_EMPTY**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-174">**VT_EMPTY**</span></span> <br/> |<span data-ttu-id="7e4c6-175">Пустые ячейки или пропущенные аргументы</span><span class="sxs-lookup"><span data-stu-id="7e4c6-175">Empty cells or omitted arguments</span></span>  <br/> |
   
<span data-ttu-id="7e4c6-176">Вы можете проверить тип переданного значения Variant в VBA с помощью **VarType**, если функция не возвращает тип значений диапазона при вызове с использованием ссылок.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-176">You can check the type of a passed-in Variant in VBA using the **VarType**, except that the function returns the type of the range's values when called with references.</span></span> <span data-ttu-id="7e4c6-177">Чтобы определить, является ли **Variant** объектом ссылки **Range**, используйте функцию **IsObject**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-177">To determine if a **Variant** is a **Range** reference object, you can use the **IsObject** function.</span></span> 
  
<span data-ttu-id="7e4c6-178">В VBA можно создавать **Variant**, содержащие массивы переменных, назначая свойство **Value** **Range** для **Variant**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-178">You can create **Variants** that contain arrays of variants in VBA from a **Range** by assigning its **Value** property to a **Variant**.</span></span> <span data-ttu-id="7e4c6-179">Ячейки в исходном диапазоне, отформатированные с использованием стандартного денежного формата для действующих региональных параметров, преобразуются в элементы массива типа **Currency**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-179">Any cells in the source range that are formatted using the standard currency format for the regional settings in force at the time are converted to array elements of type **Currency**.</span></span> <span data-ttu-id="7e4c6-180">Ячейки, отформатированные как даты, преобразуются в элементы массива типа **Date**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-180">Any cells formatted as dates are converted to array elements of type **Date**.</span></span> <span data-ttu-id="7e4c6-181">Ячейки, содержащие строки, преобразуются в Variant **BSTR** с расширенными символами.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-181">Cells containing strings are converted to wide-character **BSTR** Variants.</span></span> <span data-ttu-id="7e4c6-182">Ячейки, содержащие ошибки, преобразуются в **Variant** типа **VT_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-182">Cells containing errors are converted to **Variants** of type **VT_ERROR**.</span></span> <span data-ttu-id="7e4c6-183">Ячейки, содержащие значения **True** или **False** типа **Boolean**, преобразуются в **Variant** типа **VT_BOOL**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-183">Cells containing **Boolean** **True** or **False** are converted to **Variants** of type **VT_BOOL**.</span></span> 
  
> [!NOTE]
> <span data-ttu-id="7e4c6-184">В **Variant** значение **True** сохраняется как -1, а **False** — как 0.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-184">The **Variant** stores **True** as -1 and **False** as 0.</span></span> <span data-ttu-id="7e4c6-185">Числа, не отформатированные как даты или денежные суммы, преобразуются в Variant типа **VT_R8**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-185">Numbers not formatted as dates or currency amounts are converted to Variants of type **VT_R8**.</span></span> 
  
### <a name="variant-and-string-arguments"></a><span data-ttu-id="7e4c6-186">Аргументы строк и переменных</span><span class="sxs-lookup"><span data-stu-id="7e4c6-186">Variant and string arguments</span></span>

<span data-ttu-id="7e4c6-187">Excel поддерживает внутреннюю работу со строками Юникода с расширенными символами.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-187">Excel works internally with wide-character Unicode strings.</span></span> <span data-ttu-id="7e4c6-188">Когда определяемая пользователем функция в VBA объявлена как принимающая аргумент **String**, Excel преобразует передаваемую строку в байтовую строку в соответствии с языковым стандартом.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-188">When a VBA user-defined function is declared as taking a **String** argument, Excel converts the supplied string to a byte-string in a locale-specific way.</span></span> <span data-ttu-id="7e4c6-189">Чтобы функции передавалась строка Юникода, определяемая пользователем функция в VBA должна принимать **Variant** вместо аргумента **String**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-189">If you want your function to be passed a Unicode string, your VBA user-defined function should accept a **Variant** instead of a **String** argument.</span></span> <span data-ttu-id="7e4c6-190">При выполнении этого условия функция DLL сможет принимать строку **Variant** BSTR с расширенными символами VBA.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-190">Your DLL function can then accept that **Variant** BSTR wide-character string from VBA.</span></span> 
  
<span data-ttu-id="7e4c6-191">Чтобы из DLL возвращались строки Юникода в VBA, следует изменить имеющийся аргумент строки **Variant**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-191">To return Unicode strings to VBA from a DLL, you should modify a **Variant** string argument in place.</span></span> <span data-ttu-id="7e4c6-192">Для этого следует объявить функцию DLL как принимающую указатель на **Variant** в коде C/C++, а также объявить аргумент в коде VBA как `ByRef varg As Variant`.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-192">For this to work, you must declare the DLL function as taking a pointer to the **Variant** and in your C/C++ code, and declare the argument in the VBA code as  `ByRef varg As Variant`.</span></span> <span data-ttu-id="7e4c6-193">Память предыдущей строки следует освободить, а значение новой строки, созданное с использованием строки OLE Bstr, работает только в DLL.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-193">The old string memory should be released, and the new string value created by using the OLE Bstr string functions only in the DLL.</span></span>
  
<span data-ttu-id="7e4c6-194">Чтобы байтовая строка возвращалась в VBA из DLL, следует изменить имеющийся аргумент BSTR байтовой строки.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-194">To return a byte string to VBA from a DLL, you should modify a byte-string BSTR argument in place.</span></span> <span data-ttu-id="7e4c6-195">Для этого следует объявить функцию DLL как принимающую указатель на BSTR в коде C/C++, а также объявить аргумент в коде VBA как **ByRef varg As String**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-195">For this to work, you must declare the DLL function as taking a pointer to a pointer to the BSTR and in your C/C++ code, and declare the argument in the VBA code as ' **ByRef varg As String**'.</span></span>
  
<span data-ttu-id="7e4c6-196">Чтобы избежать проблем, связанных с памятью, необходимо обеспечить обработку только строк, которые передаются этими способами из VBA, используя функции строки OLE BSTR.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-196">You should only handle strings that are passed in these ways from VBA using the OLE BSTR string functions to avoid memory-related problems.</span></span> <span data-ttu-id="7e4c6-197">Например, необходимо обеспечить вызов **SysFreeString** для освобождения памяти перед перезаписью переданной строки, а также **SysAllocStringByteLen** или **SysAllocStringLen**, чтобы назначить место для новой строки.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-197">For example, you must call **SysFreeString** to free the memory before overwriting the passed in string, and **SysAllocStringByteLen** or **SysAllocStringLen** to allocate space for a new string.</span></span> 
  
<span data-ttu-id="7e4c6-198">Вы можете обеспечить создание сообщений об ошибках на листе Excel как **Variant** в VBA при помощи функции **CVerr** с аргументами, как показано в приведенной ниже таблице.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-198">You can create Excel worksheet errors as **Variants** in VBA by using the **CVerr** function with arguments as shown in the following table.</span></span> <span data-ttu-id="7e4c6-199">Ошибки на листе также могут быть возвращены в VBA из DLL при помощи **Variant** типа **VT_ERROR**, а также с указанными ниже значениями в поле **ulVal**.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-199">Worksheet errors can also be returned to VBA from a DLL using **Variants** of type **VT_ERROR**, and with the following values in the **ulVal** field.</span></span> 
  
|<span data-ttu-id="7e4c6-200">**Ошибка**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-200">**Error**</span></span>|<span data-ttu-id="7e4c6-201">**Значение Variant ulVal**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-201">**Variant ulVal value**</span></span>|<span data-ttu-id="7e4c6-202">**Аргумент CVerr**</span><span class="sxs-lookup"><span data-stu-id="7e4c6-202">**CVerr argument**</span></span>|
|:-----|:-----|:-----|
|<span data-ttu-id="7e4c6-203">#NULL!</span><span class="sxs-lookup"><span data-stu-id="7e4c6-203">#NULL!</span></span>  <br/> |<span data-ttu-id="7e4c6-204">2148141008</span><span class="sxs-lookup"><span data-stu-id="7e4c6-204">2148141008</span></span>  <br/> |<span data-ttu-id="7e4c6-205">2000</span><span class="sxs-lookup"><span data-stu-id="7e4c6-205">2,000</span></span>  <br/> |
|<span data-ttu-id="7e4c6-206">#ДЕЛ/0!</span><span class="sxs-lookup"><span data-stu-id="7e4c6-206">#DIV/0!</span></span>  <br/> |<span data-ttu-id="7e4c6-207">2148141015</span><span class="sxs-lookup"><span data-stu-id="7e4c6-207">2148141015</span></span>  <br/> |<span data-ttu-id="7e4c6-208">2007</span><span class="sxs-lookup"><span data-stu-id="7e4c6-208">Word 2007</span></span>  <br/> |
|<span data-ttu-id="7e4c6-209">#ЗНАЧ!</span><span class="sxs-lookup"><span data-stu-id="7e4c6-209">#VALUE!</span></span>  <br/> |<span data-ttu-id="7e4c6-210">2148141023</span><span class="sxs-lookup"><span data-stu-id="7e4c6-210">2148141023</span></span>  <br/> |<span data-ttu-id="7e4c6-211">2015</span><span class="sxs-lookup"><span data-stu-id="7e4c6-211">December 2015</span></span>  <br/> |
|<span data-ttu-id="7e4c6-212">#ССЫЛКА!</span><span class="sxs-lookup"><span data-stu-id="7e4c6-212">#REF!</span></span>  <br/> |<span data-ttu-id="7e4c6-213">2148141031</span><span class="sxs-lookup"><span data-stu-id="7e4c6-213">2148141031</span></span>  <br/> |<span data-ttu-id="7e4c6-214">2023</span><span class="sxs-lookup"><span data-stu-id="7e4c6-214">2023</span></span>  <br/> |
|<span data-ttu-id="7e4c6-215">#ИМЯ?</span><span class="sxs-lookup"><span data-stu-id="7e4c6-215">#NAME?</span></span>  <br/> |<span data-ttu-id="7e4c6-216">2148141037</span><span class="sxs-lookup"><span data-stu-id="7e4c6-216">2148141037</span></span>  <br/> |<span data-ttu-id="7e4c6-217">2029</span><span class="sxs-lookup"><span data-stu-id="7e4c6-217">2029</span></span>  <br/> |
|<span data-ttu-id="7e4c6-218">#ЧИСЛО!</span><span class="sxs-lookup"><span data-stu-id="7e4c6-218">#NUM!</span></span>  <br/> |<span data-ttu-id="7e4c6-219">2148141044</span><span class="sxs-lookup"><span data-stu-id="7e4c6-219">2148141044</span></span>  <br/> |<span data-ttu-id="7e4c6-220">2036</span><span class="sxs-lookup"><span data-stu-id="7e4c6-220">2036</span></span>  <br/> |
|<span data-ttu-id="7e4c6-221">#Н/Д</span><span class="sxs-lookup"><span data-stu-id="7e4c6-221">#N/A</span></span>  <br/> |<span data-ttu-id="7e4c6-222">2148141050</span><span class="sxs-lookup"><span data-stu-id="7e4c6-222">2148141050</span></span>  <br/> |<span data-ttu-id="7e4c6-223">2042</span><span class="sxs-lookup"><span data-stu-id="7e4c6-223">2042</span></span>  <br/> |
   
<span data-ttu-id="7e4c6-224">Обратите внимание на то, что значение Variant **ulVal** эквивалентно значению аргумента **CVerr** с шестнадцатеричным значением x800A0000.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-224">Note that the Variant **ulVal** value given is equivalent to the **CVerr** argument value plus x800A0000 hexadecimal.</span></span> 
  
## <a name="calling-dll-functions-directly-from-the-worksheet"></a><span data-ttu-id="7e4c6-225">Вызов функций DLL непосредственно с листа</span><span class="sxs-lookup"><span data-stu-id="7e4c6-225">Calling DLL functions directly from the worksheet</span></span>

<span data-ttu-id="7e4c6-226">Вы не сможете получить доступ к функциям DLL Win32 с листа, если не используете, к примеру, интерфейсы VBA или XLM либо не сообщите Excel заранее о функции, ее аргументах и типе возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-226">You cannot access Win32 DLL functions from the worksheet without, for example, using VBA or XLM as interfaces, or without letting Excel know about the function, its arguments, and its return type in advance.</span></span> <span data-ttu-id="7e4c6-227">Этот процесс называется регистрацией.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-227">The process of doing this is called registration.</span></span>
  
<span data-ttu-id="7e4c6-228">Ниже приведены способы, которыми можно получить доступ к функциям DLL на листе.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-228">The ways in which the functions of a DLL can be accessed in the worksheet are as follows:</span></span>
  
- <span data-ttu-id="7e4c6-229">Объявите функцию в VBA, как показано выше, и получите доступ к ней через пользовательскую функцию VBA.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-229">Declare the function in VBA as described previously and access it via a VBA user-defined function.</span></span>
    
- <span data-ttu-id="7e4c6-230">Сначала обеспечьте вызов функции DLL с помощью CALL на листе макросов XLM, а затем — доступ к ней с помощью определяемой пользователем функции XLM.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-230">Call the DLL function using CALL on an XLM macro sheet, and access it via an XLM user-defined function.</span></span>
    
- <span data-ttu-id="7e4c6-231">Используйте команду XLM или VBA, чтобы вызвать функцию XLM **REGISTER**, которая предоставляет сведения, необходимые Excel для опознания функции при ее вводе в ячейке листа.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-231">Use an XLM or VBA command to call the XLM **REGISTER** function, which provides the information that Excel needs to recognize the function when it is entered into a worksheet cell.</span></span> 
    
- <span data-ttu-id="7e4c6-232">Преобразуйте DLL в XLL и зарегистрируйте функцию с помощью функции **xlfRegister** C API после активации XLL.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-232">Turn the DLL into an XLL and register the function using the C API **xlfRegister** function when the XLL is activated.</span></span> 
    
<span data-ttu-id="7e4c6-p119">Четвертый подход изолированный: код, регистрирующий функции, и код функций хранятся в одном объекте кода. Изменение надстройки не включает изменение листа XLM или модуля кода VBA. Чтобы сделать это с широкими возможностями управления, оставаясь в рамках возможностей API C, необходимо преобразовать DLL в XLL и загрузить получившуюся надстройку с помощью диспетчера настроек. Это позволяет Excel вызывать функцию, предоставленную библиотекой DLL, при загрузке или активации надстройки, из которой затем можно зарегистрировать все функции, которые содержит XLL, и выполнять другие задачи инициализации DLL.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-p119">The fourth approach is self-contained: the code that registers the functions and the function code are both contained in the same code project. Making changes to the add-in does not involve making changes to an XLM sheet or to a VBA code module. To do this in a well-managed way while still staying within the capabilities of the C API, you must turn your DLL into an XLL and load the resulting add-in by using the Add-in Manager. This enables Excel to call a function that your DLL exposes when the add-in is loaded or activated, from which you can register all of the functions your XLL contains, and carry out any other DLL initialization.</span></span>
  
## <a name="calling-dll-commands-directly-from-excel"></a><span data-ttu-id="7e4c6-237">Вызов команд DLL непосредственно из Excel</span><span class="sxs-lookup"><span data-stu-id="7e4c6-237">Calling DLL commands directly from Excel</span></span>

<span data-ttu-id="7e4c6-238">Команды DLL Win32 недоступны напрямую из диалоговых окон и меню Excel без интерфейса, например VBA, или без предварительной регистрации команд.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-238">Win32 DLL commands are not accessible directly from Excel dialog boxes and menus without there being an interface, such as VBA, or without the commands being registered in advance.</span></span>
  
<span data-ttu-id="7e4c6-239">Получать доступ к командам DLL можно следующими способами:</span><span class="sxs-lookup"><span data-stu-id="7e4c6-239">The ways in which you can access the commands of a DLL are as follows:</span></span>
  
- <span data-ttu-id="7e4c6-240">Объявите команду в VBA так, как описано выше, и получите к ней доступ с помощью макроса VBA.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-240">Declare the command in VBA as described previously and access it via a VBA macro.</span></span>
    
- <span data-ttu-id="7e4c6-241">Сначала обеспечьте вызов команды DLL с помощью **CALL** на листе макросов XLM, а затем — доступ к ней с помощью макроса XLM.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-241">Call the DLL command using **CALL** on an XLM macro sheet, and access it via an XLM macro.</span></span> 
    
- <span data-ttu-id="7e4c6-242">Используйте команду XLM или VBA, чтобы вызвать функцию XLM **REGISTER**, которая предоставляет сведения, необходимые Excel для опознания команды при ее вводе в диалоговом окне, которое запрашивает имя команды макроса.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-242">Use an XLM or VBA command to call the XLM **REGISTER** function, which provides the information Excel needs to recognize the command when it is entered into a dialog box that expects the name of a macro command.</span></span> 
    
- <span data-ttu-id="7e4c6-243">Преобразуйте DLL в XLL и зарегистрируйте команду с помощью функции **xlfRegister** C API.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-243">Turn the DLL into an XLL and register the command using the C API **xlfRegister** function.</span></span> 
    
<span data-ttu-id="7e4c6-p120">Как упоминалось ранее в контексте функций DLL, четвертый подход является самым изолированным, так как код регистрации хранится наряду с кодом команд. Для этого необходимо преобразовать DLL в XLL и загрузить получившуюся надстройку с помощью диспетчера надстроек. Регистрация команд таким способом также позволяет присоединить команду к элементу пользовательского интерфейса, например пользовательскому меню, или настроить перехват события с вызовом команды по нажатию определенной клавиши или другому событию.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-p120">As discussed earlier in the context of DLL functions, the fourth approach is the most self-contained, keeping the registration code close to the command code. To do this, you must turn your DLL into an XLL and load the resulting add-in using the Add-in Manager. Registering commands in this way also lets you attach the command to an element of the user interface, such as a custom menu, or to set up an event trap that calls the command on a given keystroke or other event.</span></span>
  
<span data-ttu-id="7e4c6-247">Приложение Excel обрабатывает все команды XLL, зарегистрированные в нем, как имеющие такой вид:</span><span class="sxs-lookup"><span data-stu-id="7e4c6-247">All XLL commands that are registered with Excel are assumed by Excel to be of the following form.</span></span>
  
```cpp
int WINAPI my_xll_cmd(void)
{
// Function code...
    return 1;
}
```

> [!NOTE]
> <span data-ttu-id="7e4c6-p121">Excel игнорирует возвращаемое значение, если оно не вызывается с листа макросов XLM. В этом случае возвращаемое значение преобразуется в значение **TRUE** или **FALSE**. Таким образом, следует возвращать значение 1, если команда выполнена успешно, и 0, если она завершилась с ошибкой или была отменена пользователем.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-p121">Excel ignores the return value unless it is called from an XLM macro sheet, in which case the return value is converted to **TRUE** or **FALSE**. You should therefore return 1 if your command executed successfully, and 0 if it failed or was canceled by the user.</span></span> 
  
## <a name="dll-memory-and-multiple-dll-instances"></a><span data-ttu-id="7e4c6-250">Память DLL и многочисленные экземпляры DLL</span><span class="sxs-lookup"><span data-stu-id="7e4c6-250">DLL memory and multiple DLL instances</span></span>

<span data-ttu-id="7e4c6-251">Когда приложение загружает DLL, исполняемый код DLL загружается в глобальную кучу для выполнения, а для его структур данных назначается место в глобальной куче.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-251">When an application loads a DLL, the DLL's executable code is loaded into the global heap so that it can be run, and space is allocated on the global heap for its data structures.</span></span> <span data-ttu-id="7e4c6-252">Windows использует сопоставление памяти, чтобы эти области памяти отображались, как в процессе приложения. Таким образом приложение может получать к ним доступ.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-252">Windows uses memory mapping to make these areas of memory appear as if they are in the application's process so that the application can access them.</span></span>
  
<span data-ttu-id="7e4c6-253">Если второе приложение загружает эту библиотеку DLL, Windows не создает дополнительную копию исполняемого кода DLL, так как эта память доступна только для чтения.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-253">If a second application then loads the DLL, Windows does not make another copy of the DLL executable code, as that memory is read-only.</span></span> <span data-ttu-id="7e4c6-254">Windows сопоставляет память исполняемого кода DLL с процессами обоих приложений.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-254">Windows maps the DLL executable code memory to the processes of both applications.</span></span> <span data-ttu-id="7e4c6-255">Но при этом Windows выделяет другое место для частной копии структур данных DLL и сопоставляет эту копию только со вторым процессом.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-255">It does, however, allocate a second space for a private copy of the DLL's data structures and maps this copy to the second process only.</span></span> <span data-ttu-id="7e4c6-256">Благодаря этому одно приложение не может конфликтовать с данными DLL другого.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-256">This ensures that neither application can interfere with the DLL data of the other.</span></span>
  
<span data-ttu-id="7e4c6-257">Это означает, что разработчикам DLL не следует беспокоиться, что несколько приложений (или несколько экземпляров одного приложения) будут получать доступ к статическим и глобальным переменным и структурам данных.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-257">This means that DLL developers do not have to be concerned about static and global variables and data structures being accessed by more than one application, or more than one instance of the same application.</span></span> <span data-ttu-id="7e4c6-258">Каждый экземпляр всех приложений получает собственную копию данных DLL.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-258">Every instance of every application gets its own copy of the DLL's data.</span></span>
  
<span data-ttu-id="7e4c6-259">Разработчикам DLL следует позаботиться о том, чтобы один и тот же экземпляр приложения не вызывал DLL много раз из разных потоков, так как это может привести к состязанию за данные этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="7e4c6-259">DLL developers do need to be concerned about the same instance of an application calling their DLL many times from different threads, because this can result in contention for that instance's data.</span></span> <span data-ttu-id="7e4c6-260">Дополнительные сведения см. в статье [Управление памятью в Excel](memory-management-in-excel.md).</span><span class="sxs-lookup"><span data-stu-id="7e4c6-260">For more information, see [Memory Management in Excel](memory-management-in-excel.md).</span></span>
  
## <a name="see-also"></a><span data-ttu-id="7e4c6-261">См. также</span><span class="sxs-lookup"><span data-stu-id="7e4c6-261">See also</span></span>

- [<span data-ttu-id="7e4c6-262">Разработка библиотек DLL</span><span class="sxs-lookup"><span data-stu-id="7e4c6-262">Developing DLLs</span></span>](developing-dlls.md) 
- [<span data-ttu-id="7e4c6-263">Вызов Excel из библиотеки DLL или XLL</span><span class="sxs-lookup"><span data-stu-id="7e4c6-263">Calling into Excel from the DLL or XLL</span></span>](calling-into-excel-from-the-dll-or-xll.md)

