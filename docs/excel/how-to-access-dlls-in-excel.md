---
title: Доступа к библиотекам DLL в Excel
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
ms.topic: overview
keywords:
- доступ к библиотекам DLL [excel 2007], [Excel 2007] библиотеки DLL доступ к в Excel
localization_priority: Normal
ms.assetid: e2bfd6ea-efa3-45c1-a5b8-2ccb8650c6ab
description: '������� ����������: Excel 2013�| Office 2013�| Visual Studio'
ms.openlocfilehash: bfb562b6bbe824124c6b5a691745d076720ee004
ms.sourcegitcommit: 9d60cd82b5413446e5bc8ace2cd689f683fb41a7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/11/2018
ms.locfileid: "19807261"
---
# <a name="access-dlls-in-excel"></a>Доступа к библиотекам DLL в Excel

**Применимо к**: Excel 2013 | Office 2013 | Visual Studio 
  
Доступ к функции или команде DLL в Microsoft Excel можно получить несколькими способами:
  
- Через Microsoft Visual Basic для приложений (VBA) модуль кода, в котором функции или команды были сделаны доступными с помощью оператора **Declare** . 
    
- Через лист макросов XLM с помощью функции **звонков** или **регистрации** . 
    
- Непосредственно с листа или из настроенного элемента пользовательского интерфейса.
    
В этой документации не рассматриваются функции XLM. Рекомендуется использовать любой из двух остальных подходов.
  
Возможен непосредственно из таблицы или из настраиваемого элемента в пользовательском Интерфейсе, функции или команды необходимо сначала быть зарегистрированы в Excel. Сведения о регистрации команд и функций видеть [Доступ к XLL-коду в Excel](accessing-xll-code-in-excel.md).
  
## <a name="calling-dll-functions-and-commands-from-vba"></a>Вызов функции DLL-Библиотеку и команды из VBA

С помощью оператора **Declare** , можно получить доступ к функции DLL-Библиотеку и команды в VBA. Этот оператор имеет один синтаксис команд, другая — для функций. 
  
- **Синтаксис 1 - команды**
    
  ```vb
  [Public | Private] Declare Sub name Lib "libname" [Alias "aliasname"] [([arglist])]
  ```

- **Синтаксис 2 - функции**
    
  ```vb
  [Public | Private] Declare Function name Lib "libname" [Alias "aliasname"] [([arglist])] [As type]
  ```

Дополнительные ключевые слова **Общие** и **частные** указать область импортированной функции: всего проекта Visual Basic или модуль Visual Basic, соответственно. Имя — это имя, которое будет использоваться в коде VBA. Если это отличается от имени в библиотеке DLL, необходимо использовать описателя «aliasname» псевдоним, и следует присвоить имя функции, как экспортировать с библиотеки DLL. Если вы хотите получить доступ функции DLL, ссылку на библиотеку DLL порядковый номер, необходимо указать имя псевдонима, который является порядковый номер с префиксом **#**.
  
Команды должен возвращать **значение void**. Функции должен возвращать типы, VBA может распознать **ByVal**. Это означает, что некоторые типы проще возвращаются путем изменения аргументов на месте: строки, массивы, пользовательские типы и объекты.
  
> [!NOTE]
> VBA не может проверить совпадение списка аргументов и возвращаемого значения в модуле Visual Basic со значениями, закодированными в DLL. Это необходимо внимательно проверить самостоятельно, поскольку ошибка может привести к сбою Excel. 
  
Если функция или команды аргументы не передаются по или указателя, они должен предшествовать ключевое слово **ByVal** в объявлении **arglist** . Когда C/C++ функция принимает аргументы указателя или C++ функция принимает аргументы ссылку, должен быть передан **ByRef**. Ключевое слово, которое позволяет пропустить аргумента **ByRef** список, так как он используется по умолчанию в VBA. 
  
### <a name="argument-types-in-cc-and-vba"></a>Типы аргументов в C/C++ и VBA

При сравнении объявлений типов аргументов в C/C++ и VBA следует учитывать следующее.
  
- VBA **строка** передается как указатель на структуру BSTR строка байтов при передаче ByVal, а также как указатель указатель при передаче **ByRef**.
    
- VBA **Variant** , содержащего строку передается как указатель Юникод, строка Юникода BSTR структурировать при передаче **ByVal**, а также как указатель указатель при передаче **ByRef**.
    
- VBA **целое число** — это 16-разрядный лежат подписанных short в C/C++. 
    
- VBA **длинный** — это 32-разрядная версия лежат подписанных int в C/C++. 
    
- VBA и C/C++ разрешить определения типов пользовательских данных с помощью операторов **типа** и **структуры** соответственно. 
    
- VBA и C/C++ поддерживают тип данных **Variant** , определенных для C/C++ в файлы заголовков Windows OLE/COM как VARIANT. 
    
- Массивы VBA, OLE **объекты SAFEARRAY**, определенных для C/C++, файлы заголовков Windows OLE/COM в качестве **SAFEARRAY**.
    
- Тип данных VBA **валюты** передается как структура типа **кг**, определенные в файле wtypes.h файл заголовка Windows, когда передается **ByVal**и как указатель в этом случае, если передается **ByRef**.
    
В VBA элементы данных в типы пользовательских данных упакованы к границам 4-байтных, в то время как в Visual Studio по умолчанию они упакованы к границам 8 байтов. Поэтому необходимо заключить определение структуры C/C++ в `#pragma pack(4) … #pragma pack()` блока, чтобы избежать невыравненности элементы. 
  
Ниже приводится пример определений эквивалентных пользовательских типов.
  
```vb
Type VB_User_Type
    i As Integer
    d As Double
    s As String
End Type

```

```cpp
#pragma pack(4)
struct C_user_type
{
    short iVal;
    double dVal;
    BSTR bstr; // VBA String type is a byte string
}
#pragma pack() // restore default

```

VBA поддерживает больше диапазону значений в некоторых случаях не поддерживает Excel. Двойная VBA — IEEE совместимым, поддерживающие subnormal номера, который в данный момент округляются нуль в рабочем листе. Тип VBA **даты** может представлять даты как 1-янв-0100 с отрицательным сериализованных датами. Excel позволяет только сериализованных даты, большее или равное нулю. Тип VBA **валюты** — масштабируемого 64-разрядное целое число, можно достичь точность не поддерживается в тип Double 8 байтов и поэтому не соответствует в рабочем листе. 
  
Excel передает в пользовательскую функцию VBA только аргументы Variant указанных ниже типов.
  
|**Тип данных VBA**|**Тип Variant C/C++ двоичных флагов**|**Описание**|
|:-----|:-----|:-----|
|Double  <br/> |**VT_R8** <br/> ||
|Логический  <br/> |**VT_BOOL** <br/> ||
|Date  <br/> |**VT_DATE** <br/> ||
|Строка  <br/> |**VT_BSTR** <br/> |Байтовая строка Bstr OLE  <br/> |
|Диапазон  <br/> |**VT_DISPATCH** <br/> |Ссылки на диапазоны и ячейки  <br/> |
|Аргумент Variant, содержащий массив  <br/> |**VT_ARRAY** | **VT_VARIANT** <br/> |Массивы литералов  <br/> |
|Ccy  <br/> |**VT_CY** <br/> |64-разрядное целое число, масштабируемое до 4 десятичных знаков.  <br/> |
|Аргумент Variant, содержащий ошибку  <br/> |**VT_ERROR** <br/> ||
||**VT_EMPTY** <br/> |Пустые ячейки или пропущенные аргументы  <br/> |
   
Можно проверить тип Variant переданное в VBA с помощью **VarType**, за исключением того, что функция возвращает тип диапазон значений при вызове с ссылки. Для определения **типа Variant** — это объект reference **диапазона** , можно использовать функцию **IsObject** . 
  
Вы можете создать **варианты** , содержащие массивов вариантов в VBA из **диапазона** путем присвоения свойству **значение** **Variant**. Все ячейки в диапазоне от источника, отформатированные с помощью стандартного формата валюты для региональных параметров в силе во время преобразуются в элементы массива типа **Currency**. Ячейки в формате даты преобразуются в элементы массива типа **Date**. Ячейки, содержащие строки преобразуются в варианты **BSTR** Юникода. Ячейки, содержащие ошибки преобразуются в **варианты** типа **VT_ERROR**. Ячейки, содержащие **логическое** **значение True** или **False** преобразуется в **варианты** типа **VT_BOOL**. 
  
> [!NOTE]
> **Варианта** хранит **значение True,** как значение -1 и **значение False,** как 0. Числа не в формате даты или сумм в валюте преобразуются в варианты типа **VT_R8**. 
  
### <a name="variant-and-string-arguments"></a>Тип Variant и строковые аргументы

Excel работает внутри Юникода строк в формате Юникод. Когда пользовательскую функцию VBA объявлен как принимающий **строковый** аргумент, Excel преобразует указанную строку в строку байтов в зависимости от языкового стандарта. Если вы хотите функции передаваемых строки Юникод, должен принимать **Variant** вместо **строковый** аргумент VBA пользовательской функции. Функция DLL затем может принимать этого **варианта** строку Юникода BSTR из VBA. 
  
Чтобы получить строки Юникод VBA из библиотеки DLL, следует изменить **Variant** строковый аргумент на месте. Для работы необходимо объявить функции DLL как принимающий указатель для **Variant** и в коде C/C++ и объявить аргумент в коде VBA как `ByRef varg As Variant`. Необходимо освободить старые строки памяти и новое значение строки, созданные с помощью функции строку OLE Bstr только в DLL-Библиотеке.
  
Чтобы получить строку байтов VBA из библиотеки DLL, следует изменить байтов строковый аргумент BSTR на месте. Для этого необходимо объявить функции DLL как принимающий указатель на указатель в строку BSTR и в коде C/C++ и объявить аргумент в коде VBA как « **ByRef varg как строка**».
  
Следует обрабатывать только строк, которые передаются в этих способов из VBA с помощью функции строка OLE BSTR во избежание проблем, связанных с памяти. Например необходимо вызвать **SysFreeString** , чтобы освободить память перед перезаписью переданную в строку и **SysAllocStringByteLen** или **SysAllocStringLen** для выделения пространства для новой строки. 
  
Можно создать ошибки рабочего листа Excel как **вариантов** на языке VBA с помощью функция **CVerr** с аргументы, как показано в следующей таблице. Таблица ошибки могут быть возвращены для VBA из библиотеки DLL с использованием **вариантов** типа **VT_ERROR**и со следующими значениями в поле **ulVal** . 
  
|**Error**|**Значение типа Variant ulVal**|**Аргумент CVerr**|
|:-----|:-----|:-----|
|#ПУСТО!  <br/> |2148141008  <br/> |2000  <br/> |
|#ДЕЛ/0!  <br/> |2148141015  <br/> |2007  <br/> |
|#ЗНАЧ!  <br/> |2148141023  <br/> |2015  <br/> |
|#ССЫЛКА!  <br/> |2148141031  <br/> |2023  <br/> |
|#ИМЯ?  <br/> |2148141037  <br/> |2029  <br/> |
|#ЧИСЛО!  <br/> |2148141044  <br/> |2036  <br/> |
|#Н/Д  <br/> |2148141050  <br/> |2042  <br/> |
   
Обратите внимание, что значением типа Variant, **ulVal** эквивалентен **CVerr** значение аргумента, а также x800A0000 шестнадцатеричные. 
  
## <a name="calling-dll-functions-directly-from-the-worksheet"></a>Вызов функции DLL непосредственно из листа

Недоступны функций Win32 DLL из таблицы без, например, с помощью VBA или XLM как интерфейсы или не сообщив Excel заранее знаете о функцию, аргументы и его возвращаемый тип. Это процесс называется регистрации.
  
Получать доступ к функциям DLL на листе можно следующими способами:
  
- Объявите функцию в VBA, как показано выше, и получите доступ к ней через пользовательскую функцию VBA.
    
- Вызовите функцию DLL с помощью команды CALL или листа макросов XLM и получите доступ к ней через пользовательскую функцию XLM.
    
- Используйте команду XLM или VBA для вызова функции XLM **регистрации** , которая содержит сведения, который необходимо определить функцию при вводе в ячейку листа Excel. 
    
- Перевод библиотеки DLL в надстройке XLL и зарегистрировать функцию, с помощью функции интерфейса API для C **xlfRegister** при активации XLL. 
    
Четвертый подход изолированный: код, регистрирующий функции, и код функций хранятся в одном объекте кода. Изменение надстройки не включает изменение листа XLM или модуля кода VBA. Чтобы сделать это с широкими возможностями управления, оставаясь в рамках возможностей API C, необходимо преобразовать DLL в XLL и загрузить получившуюся надстройку с помощью диспетчера настроек. Это позволяет Excel вызывать функцию, предоставленную библиотекой DLL, при загрузке или активации надстройки, из которой затем можно зарегистрировать все функции, которые содержит XLL, и выполнять другие задачи инициализации DLL.
  
## <a name="calling-dll-commands-directly-from-excel"></a>Вызов DLL-Библиотека команды непосредственно из Excel

Команды DLL Win32 недоступны напрямую из диалоговых окон и меню Excel без интерфейса, например VBA, или без предварительной регистрации команд.
  
Получать доступ к командам DLL можно следующими способами:
  
- Объявите команду в VBA, как описано выше, и получите доступ к ней через макрос VBA.
    
- Вызовите команду DLL-Библиотеку, с помощью **ВЫЗОВА** на листе макросов XLM и получить к нему доступ с помощью макросов XLM. 
    
- Используйте XLM или команды VBA для вызова функции XLM **регистрации** , которая предоставляет сведения о Excel необходимо распознавать команда при вводе в диалоговое окно, которое требуется имя макроса. 
    
- Перевод библиотеки DLL в надстройке XLL и зарегистрировать команды, с помощью функции интерфейса API для C **xlfRegister** . 
    
Как упоминалось ранее в контексте функций DLL, четвертый подход является самым изолированным, так как код регистрации хранится наряду с кодом команд. Для этого необходимо преобразовать DLL в XLL и загрузить получившуюся надстройку с помощью диспетчера надстроек. Регистрация команд таким способом также позволяет присоединить команду к элементу пользовательского интерфейса, например пользовательскому меню, или настроить перехват события с вызовом команды по нажатию определенной клавиши или другому событию.
  
Предполагается, что все команды XLL, зарегистрированные в Excel, имеют указанную ниже форму.
  
```cpp
int WINAPI my_xll_cmd(void)
{
// Function code...
    return 1;
}
```

> [!NOTE]
> Excel возвращаемое значение игнорируется, если не вызывается из листа макросов XLM, в котором случае возвращаемое значение преобразуется в значение **TRUE** или **FALSE**. Следует таким образом возвращает 1, если команда выполнена успешно, а 0, если он не удалась или отменена пользователем. 
  
## <a name="dll-memory-and-multiple-dll-instances"></a>Память DLL-Библиотеку и несколько экземпляров DLL

Когда приложение загружает библиотеку DLL, DLL-Библиотека исполняемый код загружается в глобальной кучи, чтобы его можно было выполнить, а пространства, выделяемого на глобальной кучи для его структуры данных. Windows использует сопоставления памяти, чтобы эти области памяти отображаются, как если бы они находятся в процессе приложения, чтобы доступ к их приложения.
  
Если второй приложения затем загружает библиотеку DLL, Windows не выполняет еще одну копию исполняемый код библиотеки DLL, как памяти доступен только для чтения. Windows сопоставляет памяти исполняемый код DLL процессов оба приложения. Его does, тем не менее, выделите второй пространства для закрытого копию структуры данных библиотеки DLL и сопоставляется второй процесс только эту копию. Это гарантирует, что ни один из приложения могут мешать данных библиотеки DLL из другой.
  
Это означает, что разработчикам библиотеки DLL необходимо касается о статических и глобальные переменные и структуры данных к которым получают доступ приложения более одного или нескольких экземпляров одного приложения. Каждый экземпляр каждое приложение получает собственную копию данных DLL.
  
DLL-Библиотека следует разработчикам беспокоит тот же экземпляр приложения вызов количество раз их DLL из различных потоков, так как это может привести к конкуренции за этот экземпляр данных. Дополнительные сведения содержатся в разделе [Управление памятью в Excel](memory-management-in-excel.md).
  
## <a name="see-also"></a>См. также

- [Разработка библиотеки DLL](developing-dlls.md) 
- [����� � Excel �� DLL ��� XLL](calling-into-excel-from-the-dll-or-xll.md)

