---
title: Обратная совместимость
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
ms.topic: overview
keywords:
- Совместимость версий [Excel 2007], совместимость XLL [Excel 2007], обратная совместимость [Excel 2007]
localization_priority: Normal
ms.assetid: ac200824-0620-4f03-8bd2-59226c1e79d7
description: 'Относится к: Excel 2013 | Office 2013 | Visual Studio'
ms.openlocfilehash: 3e1368ef55b96be947527456e0f01918afec6663
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32301682"
---
# <a name="backward-compatibility"></a>Обратная совместимость

**Относится к**: Excel 2013 | Office 2013 | Visual Studio 
  
В этой статье рассматриваются проблемы совместимости XLL в различных версиях Microsoft Excel.
  
## <a name="useful-constant-definitions"></a>Применимые определения констант

РасСмотрите возможность включения определений, похожих на эти, в коде проекта XLL и замену всех экземпляров литеральных чисел, используемых в этом контексте. Это приводит к уточнению кода, относящегося к версии, и уменьшению вероятности ошибок, связанных с версиями, в форме безвредных номеров.
  
```cpp
#define MAX_XL11_ROWS            65536
#define MAX_XL11_COLS              256
#define MAX_XL12_ROWS          1048576
#define MAX_XL12_COLS            16384
#define MAX_XL11_UDF_ARGS           30
#define MAX_XL12_UDF_ARGS          255
#define MAX_XL4_STR_LEN           255u
#define MAX_XL12_STR_LEN        32767u
```

## <a name="getting-the-running-version"></a>Извлечение запущенной версии

Необходимо определить, какая версия выполняется с помощью `Excel4(xlfGetWorkspace, &amp;version, 1, &amp;arg)`, где `arg` в качестве числового параметра **XLOPER** задано значение 2, а версия — это строка **XLOPER** , которую затем можно привести к целому числу. Для Microsoft Excel 2013 это 15,0. Это следует сделать в функции [xlAutoOpen](xlautoopen.md) . Затем можно задать глобальную переменную, которая информирует все модули в проекте, какая версия Excel работает. В коде можно решить, следует ли вызывать API C с помощью **Excel12** и **XLOPER12**, или с помощью **Excel4** с помощью **XLOPER**s.
  
Вы можете вызвать **XLCallVer** для обнаружения версии C API, но это не указывает, какие версии пред-Excel 2007 вы используете. 
  
## <a name="creating-add-ins-that-export-dual-interfaces"></a>Создание надстроек, экспортирующих сдвоенные интерфейсы

Рассмотрим функцию XLL, которая принимает строку и возвращает значение, которое может быть любым типом данных листа. Вы можете экспортировать функцию, зарегистрированную как тип "PD", и создать прототип, как показано ниже, где строка передается как строка байтов с ограничением длины.
  
`LPXLOPER WINAPI my_xll_fn(unsigned char *arg);`
  
Несмотря на то, что это прекрасно работает, существует несколько причин, по которым это не идеальный интерфейс для кода, начиная с Excel 2007:
  
- Он подчиняется ограничениям для строк байтов API C и не может получить доступ к длинным строкам Юникода, поддерживаемым начиная с Excel 2007.
    
- В то же время, начиная с Excel 2007, Excel может передавать и принимать **XLOPER**s, внутренним образом преобразует их в **XLOPER12**s, поэтому существуют неявные неявные преобразования, начиная с версии Excel 2007, которые не отображаются при выполнении кода в более ранних версиях Excel.
    
- Возможно, эта функция может быть совершена потокобезопасным, но если строка типа изменяется на, то регистрация завершается с `PD$`ошибкой до Excel 2007.
    
По этим причинам в идеале, начиная с Excel 2007, необходимо экспортировать функцию для пользователей, зарегистрированных как `QD%$`, предполагая, что код является потокобезопасным и имеет прототип, как показано ниже.
  
`LPXLOPER12 WINAPI my_xll_fn_v12(wchar_t *arg);`
  
Другая причина, по которой вы можете зарегистрировать другую функцию, начинающуюся в Excel 2007, заключается в том, что она позволяет функциям XLL принимать до 255 аргументов, а не 30 символов более ранних версий.
  
К счастью, вы можете использовать преимущества обоих вариантов, экспортировав обе версии из проекта. Затем вы можете определить запущенную версию Excel и условно зарегистрировать наиболее подходящую функцию. Для получения дополнительных сведений и примера реализации, ознакомьтесь со статьей [Разработка надстроек (XLL) в Excel 2007](https://msdn.microsoft.com/library/aa730920.aspx).
  
Такой подход приводит к тому, что лист, работающий в Excel 2003, может отображать результаты, не превышающие тот же лист, запущенный в Excel 2007. Например, Excel 2003 будет сопоставлять строку Юникода в ячейке листа Excel 2003 с байтовым строкой ASCII и сокращать ее перед передачей в функцию XLL. Начиная с Excel 2007, Excel передает непреобразованную строку Юникода в функцию XLL, зарегистрированную в правильном виде. Это может привести к другому результату. Вы должны знать о такой возможности и последствиях для пользователей, а не только при обновлении. Например, некоторые встроенные числовые функции были улучшены в Excel 2000 и Excel 2003.
  
## <a name="new-worksheet-functions-and-analysis-toolpak-functions"></a>Новые функции листов и функции пакета анализа

Функции пакета анализа (ATP) являются частью Excel, начиная с Excel 2007. Ранее XLL мог вызвать функцию ATP только с помощью [xlUDF](xludf.md). Начиная с Excel 2007, функции ATP должны вызываться с помощью перечислений функций, определенных в Xlcall. h. В примере вызовов пользовательских функций из библиотек DLL показаны два разных метода.
  
## <a name="see-also"></a>См. также

- [Функции обратного вызова API C: Excel4, Excel12](c-api-callback-functions-excel4-excel12.md) 
- [Программирование с использованием API C в Excel](programming-with-the-c-api-in-excel.md)
- [Новые возможности API C для Excel](what-s-new-in-the-c-api-for-excel.md)

