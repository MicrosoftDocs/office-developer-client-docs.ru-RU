---
title: Обратная совместимость
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
ms.topic: overview
keywords:
- совместимость версий [excel 2007],совместимость XLL [Excel 2007],обратная совместимость [Excel 2007]
localization_priority: Normal
ms.assetid: ac200824-0620-4f03-8bd2-59226c1e79d7
description: 'Область применения: Excel 2013 | Office 2013 | Visual Studio'
ms.openlocfilehash: 3e1368ef55b96be947527456e0f01918afec6663
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32301682"
---
# <a name="backward-compatibility"></a>Обратная совместимость

**Область применения:** Excel 2013 | Office 2013 | Visual Studio 
  
В этом разделе исправлены проблемы совместимости XLL в различных версиях Microsoft Excel.
  
## <a name="useful-constant-definitions"></a>Полезные определения констант

Рассмотрите возможность включите определения, похожие на эти, в код проекта XLL и замените все экземпляры литеральных чисел, используемых в этом контексте. Это уточнение кода, относящемся к конкретной версии, и снижение вероятности ошибок, связанных с версиями, в виде неявных номеров.
  
```cpp
#define MAX_XL11_ROWS            65536
#define MAX_XL11_COLS              256
#define MAX_XL12_ROWS          1048576
#define MAX_XL12_COLS            16384
#define MAX_XL11_UDF_ARGS           30
#define MAX_XL12_UDF_ARGS          255
#define MAX_XL4_STR_LEN           255u
#define MAX_XL12_STR_LEN        32767u
```

## <a name="getting-the-running-version"></a>Получение запущенной версии

Необходимо определить, какая версия запущена с помощью , где числовой XLOPER задайте 2, а версия — строку `Excel4(xlfGetWorkspace, &amp;version, 1, &amp;arg)` `arg` **XLOPER,**  которую затем можно привести к числу. Для Microsoft Excel 2013 это 15.0. Это следует сделать в функции [xlAutoOpen](xlautoopen.md) или из нее. Затем можно установить глобальную переменную, которая сообщает всем модулям в проекте, какая версия Excel запущена. Затем код может решить, следует ли вызывать API C с помощью **Excel12** и **XLOPER12** или **Excel4** с помощью **XLOPER.**
  
Вы можете вызвать **XLCallVer,** чтобы обнаружить версию API C, но это не указывает, какая из запущенных версий до Excel 2007. 
  
## <a name="creating-add-ins-that-export-dual-interfaces"></a>Создание надстройки, экспортируют два интерфейса

Рассмотрим функцию XLL, которая принимает строку и возвращает значение, которое может быть любым из типов данных таблицы. Можно экспортировать функцию, зарегистрированную как тип "PD" и прототипируемую следующим образом, где строка передается в виде строки с подсчетом длины.
  
`LPXLOPER WINAPI my_xll_fn(unsigned char *arg);`
  
Хотя это хорошо работает, существует несколько причин, по которым этот интерфейс не является идеальным интерфейсом для кода, начиная с Excel 2007:
  
- На него накладываются ограничения на строки byte C API, и он не может получить доступ к длинным строкам Юникода, поддерживаемых начиная с Excel 2007.
    
- Хотя, начиная с Excel 2007, Excel может передавать и принимать **S XLOPER,** внутренне преобразует их в **XLOPER12,** поэтому, начиная с Excel 2007, существует неявная накладная часть преобразования, которая не существует, когда код выполняется в предыдущих версиях Excel.
    
- Возможно, эту функцию можно сделать потокобезопасной, но если строка типа изменена на , регистрация не будет выполнена, начиная  `PD$` с Excel 2007.
    
По этим причинам в идеале, начиная с Excel 2007, следует экспортировать функцию для пользователей, зарегистрированных как , предполагая, что ваш код потокобезопасн и прототипов, как поется в  `QD%$` примере.
  
`LPXLOPER12 WINAPI my_xll_fn_v12(wchar_t *arg);`
  
Еще одна причина, по которой можно зарегистрировать другую функцию, начиная с Excel 2007, заключается в том, что она позволяет функциям XLL принимать до 255 аргументов вместо 30 ограничений более ранних версий.
  
К счастью, вы можете получить преимущества обеих версий, экспортив обе версии из проекта. Затем можно определить запущенную версию Excel и условно зарегистрировать наиболее подместимую функцию. Дополнительные сведения и пример внедрения см. в примере разработки надстроек [(XLL) в Excel 2007.](https://msdn.microsoft.com/library/aa730920.aspx)
  
Такой подход приводит к тому, что на листе, запущенном в Excel 2003, могут отображаться результаты, отличае от результатов, запущенных на одном листе, начиная с Excel 2007. Например, Excel 2003 соединит строку Юникода в ячейке листа Excel 2003 со строкой byte-string ASCII и усекает ее перед передачей в функцию XLL. Начиная с Excel 2007, Excel передает невербированную строку Юникода функции XLL, зарегистрированной правильным способом. Это может привести к другому результату. Следует помнить об этой возможности и последствиях для пользователей, а не только при обновлении. Например, в Excel 2000 и Excel 2003 улучшены некоторые встроенные числимые функции.
  
## <a name="new-worksheet-functions-and-analysis-toolpak-functions"></a>Новые функции worksheet и analysis Toolpak

Функции анализа toolpak (ATP) являются частью Excel, начиная с Excel 2007. Ранее XLL могла вызывать функцию ATP только с помощью [xlUDF.](xludf.md) Начиная с Excel 2007, функции ATP должны быть вызваны с помощью функций, которые определены в xlcall.h. В примере вызова пользовательских функций из DLL демонстрируются два разных метода.
  
## <a name="see-also"></a>См. также

- [Функции обратного вызова API C: Excel4, Excel12](c-api-callback-functions-excel4-excel12.md) 
- [Программирование с использованием API C в Excel](programming-with-the-c-api-in-excel.md)
- [Новые возможности API C для Excel](what-s-new-in-the-c-api-for-excel.md)

