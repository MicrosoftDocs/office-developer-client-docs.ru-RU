---
title: Обратная совместимость
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
ms.topic: overview
keywords:
- совместимость версий [Excel 2007], совместимость XLL [Excel 2007], обратная совместимость [Excel 2007]
localization_priority: Normal
ms.assetid: ac200824-0620-4f03-8bd2-59226c1e79d7
description: 'Область применения: Excel 2013 | Office 2013 | Visual Studio'
ms.openlocfilehash: 3e1368ef55b96be947527456e0f01918afec6663
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32301682"
---
# <a name="backward-compatibility"></a>Обратная совместимость

**Область применения:** Excel 2013 | Office 2013 | Visual Studio 
  
В этом разделе проблемы совместимости XLL в различных версиях Microsoft Excel.
  
## <a name="useful-constant-definitions"></a>Полезные определения постоянной

Рассмотрите возможность включения определений, аналогичных этим, в код проекта XLL и замены всех экземпляров буквальных номеров, используемых в этом контексте. Это позволит уточнить конкретный код версии и снизить вероятность ошибок, связанных с версией, в виде безобидных номеров.
  
```cpp
#define MAX_XL11_ROWS            65536
#define MAX_XL11_COLS              256
#define MAX_XL12_ROWS          1048576
#define MAX_XL12_COLS            16384
#define MAX_XL11_UDF_ARGS           30
#define MAX_XL12_UDF_ARGS          255
#define MAX_XL4_STR_LEN           255u
#define MAX_XL12_STR_LEN        32767u
```

## <a name="getting-the-running-version"></a>Получение запущенной версии

Вы должны определить, какая версия работает с помощью, где числовой XLOPER набор 2 и версия `Excel4(xlfGetWorkspace, &amp;version, 1, &amp;arg)` `arg` **строки XLOPER,**  которые затем могут быть принуждены к integer. Для Microsoft Excel 2013 это 15.0. Вы должны сделать это в функции [xlAutoOpen](xlautoopen.md) или из нее. Затем можно установить глобальную переменную, которая информирует все модули в проекте, какая Excel запущена. Затем код может решить, вызывать API C с помощью **Excel12** и **XLOPER12** s или использовать **Excel4** с помощью **XLOPER** s.
  
Вы можете **вызвать XLCallVer,** чтобы узнать версию API C, но это не указывает, какая из Excel 2007 года запущена. 
  
## <a name="creating-add-ins-that-export-dual-interfaces"></a>Создание надстройок, экспортируют двойные интерфейсы

Рассмотрим функцию XLL, которая принимает строку и возвращает значение, которое может быть любым из типов данных таблицы. Можно экспортировать функцию, зарегистрированную как тип "PD" и прототипируемую следующим образом, где строка передается в виде строки byte с учетом длины.
  
`LPXLOPER WINAPI my_xll_fn(unsigned char *arg);`
  
Хотя это отлично работает, существует несколько причин, по которым это не идеальный интерфейс для кода, начиная с Excel 2007 г.:
  
- Он подвержен ограничениям строк byte API C и не может получить доступ к длинным строкам Юникод, поддерживаемым начиная с Excel 2007 года.
    
- Хотя, начиная с Excel 2007 г., Excel может передавать и принимать **XLOPER** s, внутренне он преобразует их в **XLOPER12** s, поэтому накладные расходы на неявное преобразование, начиная с Excel 2007 г., не существуют, когда код выполняется в более ранних версиях Excel.
    
- Возможно, эта функция может быть безопасной, но если строка типа изменена на, регистрация не будет выполнена до начала Excel `PD$` 2007 года.
    
По этим причинам, в идеале, начиная с Excel 2007 г. необходимо экспортировать функцию для пользователей, зарегистрированных в качестве, если ваш код является нитью безопасной и прототипируется следующим `QD%$` образом.
  
`LPXLOPER12 WINAPI my_xll_fn_v12(wchar_t *arg);`
  
Еще одна причина, по которой можно зарегистрировать другую функцию, начиная с Excel 2007 г., заключается в том, что она позволяет функциям XLL принимать до 255 аргументов вместо 30 ограничений предыдущих версий.
  
К счастью, вы можете использовать преимущества обоих версий, экспортировать обе версии из проекта. Затем можно обнаружить запущенную Excel и условно зарегистрировать наиболее подходящие функции. Дополнительные сведения и пример реализации см. в [примере Developing Add-ins (XLLs) в Excel 2007 г.](https://msdn.microsoft.com/library/aa730920.aspx)
  
Этот подход приводит к тому, что лист, запущенный в 2003 Excel 2003 г., может отображать различные результаты, чем один и тот же лист, запущенный с Excel 2007 г. Например, Excel 2003 г. наметит строку Юникода в ячейке таблицы Excel 2003 г. в строку byte-string ASCII и усечена до передачи ее функции XLL. Начиная с Excel 2007 Excel будет передавать неконвертированную строку Юникод в функцию XLL, зарегистрированную правильно. Это может привести к иному результату. Вы должны знать об этой возможности и последствиях для пользователей, а не только в обновлении. Например, в период с 200 Excel 0 по Excel 2003 г. некоторые встроенные числимые функции были улучшены.
  
## <a name="new-worksheet-functions-and-analysis-toolpak-functions"></a>Функции нового таблицы и функции toolpak analysis

Функции Toolpak analysis (ATP) являются частью Excel начиная с Excel 2007 г. Ранее XLL мог вызывать функцию ATP только с помощью [xlUDF.](xludf.md) Начиная с Excel 2007 г. функции ATP должны называться с помощью функций, определяемой в xlcall.h. В примере "Вызов функций, определенных пользователем" из DLLs, демонстрируются два различных метода.
  
## <a name="see-also"></a>См. также

- [Функции обратного вызова API C: Excel4, Excel12](c-api-callback-functions-excel4-excel12.md) 
- [Программирование с использованием API C в Excel](programming-with-the-c-api-in-excel.md)
- [Новые возможности API C для Excel](what-s-new-in-the-c-api-for-excel.md)

