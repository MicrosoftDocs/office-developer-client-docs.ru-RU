---
title: Обратная совместимость
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
ms.topic: overview
keywords:
- совместимость версий [excel 2007,] XLL совместимости [Excel 2007], обратной совместимости [Excel 2007]
localization_priority: Normal
ms.assetid: ac200824-0620-4f03-8bd2-59226c1e79d7
description: 'Относится к: Excel 2013 | Office 2013 | Visual Studio'
ms.openlocfilehash: 095961fa909a67b354ed43a7e093b79a9ebb4f18
ms.sourcegitcommit: 9d60cd82b5413446e5bc8ace2cd689f683fb41a7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/11/2018
ms.locfileid: "19807148"
---
# <a name="backward-compatibility"></a>Обратная совместимость

**Относится к**: Excel 2013 | Office 2013 | Visual Studio 
  
В данной статье рассматриваются вопросы совместимости XLL в различных версиях Microsoft Excel.
  
## <a name="useful-constant-definitions"></a>Полезные определения констант

Рассмотрите возможность включая определения следующего вида в коде проекта XLL и заменить все экземпляры литерала чисел, используемых в данном контексте. Это упростит код, версии и снизить вероятность возникновения ошибки, связанные с версии в виде невинные номеров.
  
```cpp
#define MAX_XL11_ROWS            65536
#define MAX_XL11_COLS              256
#define MAX_XL12_ROWS          1048576
#define MAX_XL12_COLS            16384
#define MAX_XL11_UDF_ARGS           30
#define MAX_XL12_UDF_ARGS          255
#define MAX_XL4_STR_LEN           255u
#define MAX_XL12_STR_LEN        32767u
```

## <a name="getting-the-running-version"></a>Получение используемой версии

Следует определить, какие версии выполняется с помощью `Excel4(xlfGetWorkspace, &amp;version, 1, &amp;arg)`, где `arg` — это числовой, **XLOPER** значение 2 и версия — это строка **XLOPER** , который затем может быть преобразован в тип integer. Для Microsoft Excel 2013 это 15.0. Это следует сделать в или из функции [xlAutoOpen](xlautoopen.md) . Затем можно задать глобальную переменную, чтобы сообщить всем модулям в проекте, установленной версии Excel. Код затем могут принять решение для вызова интерфейса API для C помощью **Excel12** и **XLOPER12**или с помощью **Excel4** с помощью **XLOPER**s.
  
Можно вызвать **XLCallVer** для обнаружения версии интерфейса API для C, но это не указывает, какую из версий до Microsoft Excel 2007, выполняется. 
  
## <a name="creating-add-ins-that-export-dual-interfaces"></a>Создание надстроек, экспортировать двух интерфейсов

Рассмотрим функцию XLL, который принимает строку и возвращает значение, которое может быть любой из типов данных на листе. Можно экспортировать функции, зарегистрированные как тип «PD» и создания прототипов следующим образом где строка передается как строка байтов со счетчиком длины.
  
`LPXLOPER WINAPI my_xll_fn(unsigned char *arg);`
  
Несмотря на то, что это работает нормально, существует несколько причин, почему это не идеальная интерфейса в код, начиная с версии Excel 2007:
  
- Он применяются ограничения строки байтов C API и не может получить доступ к длинных Юникод строк поддерживается начиная с версии Excel 2007.
    
- Хотя начиная с версии Excel 2007, Excel можно передавать и принимать **XLOPER**s, во внутренней сети его преобразует их в **XLOPER12**, поэтому дополнительная нагрузка неявное преобразование, начиная с версии Excel 2007, не существует при выполнении кода в более ранних версиях Excel.
    
- Возможно, что эта функция может сделать потокобезопасными, но если изменить тип строки для `PD$`, происходит ошибка регистрации в до Excel 2007.
    
По этим причинам в идеале, начиная с версии Excel 2007 следует экспортировать функцию для пользователей, зарегистрированных в качестве `QD%$`, при условии кода — это поток надежных и создания прототипов следующим образом.
  
`LPXLOPER12 WINAPI my_xll_fn_v12(wchar_t *arg);`
  
Другой причиной, почему может потребоваться регистрации различные функции, начиная с версии Excel 2007 — это, что она позволяет функциям XLL принимать до 255 аргументы, а не 30 ограничение в более ранних версиях.
  
К счастью можно воспользоваться преимуществами обеих версий путем экспорта обеих версий из проекта. Можно затем определить используемую версию Excel и условно зарегистрировать наиболее подходящую функцию. Дополнительные сведения и пример реализации в разделе [Разработка надстроек (XLL-модулей) в Excel 2007](http://msdn.microsoft.com/en-us/library/aa730920.aspx).
  
Этот подход может привести к тому, что на листе, открытом в Excel 2003 может отображать результаты, отличные от одного листа, выполнение, начиная с версии Excel 2007. К примеру приложение Excel 2003 будет сопоставить строки Юникод в строку в ячейке таблицы Excel 2003 в строку байтов ASCII и усекать перед передачей их в функцию XLL. Начиная с версии Excel 2007, Excel передает непреобразованных строка Юникода функцию XLL, зарегистрированную надлежащим образом. Это может привести к другой результат. Следует иметь в виду такой возможности и последствия для пользователей, не только в обновления. Например некоторые числовые функции были улучшены между Excel 2000 и Excel 2003.
  
## <a name="new-worksheet-functions-and-analysis-toolpak-functions"></a>Новые функции и функции пакета

Функции ПАКЕТА анализа являются частью Excel, начиная с версии Excel 2007. Раньше XLL-модуль только может вызывать функцию ATP с помощью [xlUDF](xludf.md). Начиная с версии Excel 2007, функции анализа должен быть вызван с помощью функция перечислений, определенных в xlcall.h. В примере в вызов пользовательских функций из библиотек DLL показано двумя различными способами.
  
## <a name="see-also"></a>См. также

- [Функции обратного вызова API C: Excel4, Excel12](c-api-callback-functions-excel4-excel12.md) 
- [Программирование с использованием API C в Excel](programming-with-the-c-api-in-excel.md)
- [Новые возможности API C для Excel](what-s-new-in-the-c-api-for-excel.md)

