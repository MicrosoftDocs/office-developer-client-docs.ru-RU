---
title: Асинхронные пользовательские функции
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
ms.topic: overview
localization_priority: Normal
ms.assetid: 142eb27e-fb6f-4da3-bfb7-a88115bbb5d5
description: '������� ����������: Excel 2013�| Office 2013�| Visual Studio'
ms.openlocfilehash: 5b64dfd4308da4efb5e94010fe1dc9d758a1199c
ms.sourcegitcommit: 9d60cd82b5413446e5bc8ace2cd689f683fb41a7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/11/2018
ms.locfileid: "19807132"
---
# <a name="asynchronous-user-defined-functions"></a><span data-ttu-id="8ab4c-103">Асинхронные пользовательские функции</span><span class="sxs-lookup"><span data-stu-id="8ab4c-103">Asynchronous user-defined functions</span></span>

<span data-ttu-id="8ab4c-104">**Применимо к**: Excel 2013 | Office 2013 | Visual Studio</span><span class="sxs-lookup"><span data-stu-id="8ab4c-104">**Applies to**: Excel 2013 | Office 2013 | Visual Studio</span></span> 
  
<span data-ttu-id="8ab4c-105">Microsoft Excel 2013 можно асинхронный вызов пользовательских функций.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-105">Microsoft Excel 2013 can call user-defined functions asynchronously.</span></span> <span data-ttu-id="8ab4c-106">Асинхронный вызов функции могут улучшить производительность, позволяя несколько вычислений для запуска в то же время.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-106">Calling functions asynchronously can improve performance by allowing several calculations to run at the same time.</span></span> <span data-ttu-id="8ab4c-107">При выполнении этих функций на вычислительном кластере асинхронный вызов функции включает несколько компьютеров, которые будут использоваться для выполнения вычислений.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-107">When you run user-defined functions on a compute cluster, calling functions asynchronously enables several computers to be used to complete the calculations.</span></span>
  
## <a name="when-to-use-asynchronous-user-defined-functions"></a><span data-ttu-id="8ab4c-108">Когда следует использовать асинхронных пользовательских функций</span><span class="sxs-lookup"><span data-stu-id="8ab4c-108">When to use asynchronous user-defined functions</span></span>

<span data-ttu-id="8ab4c-109">Некоторые выбранные пользователем функции еще не готова для внешних ресурсов.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-109">Some user-defined functions must wait for external resources.</span></span> <span data-ttu-id="8ab4c-110">Пока осуществляется их, блокировки потока вычислений Excel.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-110">While they wait, the Excel calculation thread is blocked.</span></span> <span data-ttu-id="8ab4c-111">В Excel 2013 можно асинхронное выполнение пользовательских функций.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-111">In Excel 2013, user-defined functions can run asynchronously.</span></span> <span data-ttu-id="8ab4c-112">Это позволяет экономить потока вычислений для запуска других вычислений во время ожидания пользовательских функций.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-112">This frees the calculation thread to run other calculations while the user-defined function waits.</span></span>
  
<span data-ttu-id="8ab4c-113">В Excel 2007 с любым опытом может выполнить несколько пользовательских функций в то же время, увеличьте число потоков, используемых в нескольких потоков пересчетов.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-113">In Excel 2007, programmers could run multiple user-defined functions at the same time by increasing the number of threads used in multiple-thread recalculations.</span></span> <span data-ttu-id="8ab4c-114">Этот метод имеет недостатки в первую очередь, так как число потоков, устанавливается ограниченные приложения и не может управляться на уровне одной функции или надстроек.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-114">This method has drawbacks primarily because the number of threads is a setting scoped to an application and cannot be controlled at the level of a single function or an add-in.</span></span>
  
<span data-ttu-id="8ab4c-115">Функции должны ждать освобождения внешних ресурсов следует использовать вызовов асинхронных пользовательских функций с любым опытом.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-115">Programmers should use asynchronous user-defined function calls when the function must wait for external resources.</span></span> <span data-ttu-id="8ab4c-116">К примеру функция, которая отправляет запрос SOAP через Интернет необходимо дождаться сети, чтобы отправить запрос, удаленного сервера, чтобы завершить запрос и сети для возвращения результата.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-116">For example, a function that sends a SOAP request over the Internet must wait for the network to deliver the request, the remote server to complete the request, and the network to return the result.</span></span> <span data-ttu-id="8ab4c-117">В этом случае нет не значительные сетей повторяться и Excel можно продолжить выполнение других вычислений.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-117">In this case, there is no significant computing occurring and Excel can continue with other calculations.</span></span>
  
<span data-ttu-id="8ab4c-118">Программисты также можно использовать асинхронных пользовательских функций, когда функция отправляет запросы к вычислительному кластеру.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-118">Programmers can also use asynchronous user-defined functions when a function is sending requests to a compute cluster.</span></span> <span data-ttu-id="8ab4c-119">В этом случае не только задержек в сети ожидания, но кластера может выполнять отдельные вызовов на отдельных серверах.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-119">In this case, there is not only network latency to wait for, but the cluster can execute separate calls on separate servers.</span></span> <span data-ttu-id="8ab4c-120">Не ожидая для каждого звонка закончить, вызовы можно перекрытием для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-120">By not waiting for each call to finish, the calls can be overlapped to improve performance.</span></span> <span data-ttu-id="8ab4c-121">В некоторых случаях это улучшение имеет значение.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-121">In some cases this improvement is significant.</span></span>
  
> [!NOTE]
> <span data-ttu-id="8ab4c-122">Пользовательские функции не может быть зарегистрирована как обе асинхронного и кластера безопасных.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-122">User-defined functions cannot be registered as both asynchronous and cluster safe.</span></span> 
  
## <a name="writing-an-asynchronous-user-defined-function"></a><span data-ttu-id="8ab4c-123">Написание асинхронных пользовательских функций</span><span class="sxs-lookup"><span data-stu-id="8ab4c-123">Writing an asynchronous user-defined function</span></span>

<span data-ttu-id="8ab4c-124">Асинхронные пользовательские функции должны отслеживать дескриптор и использовать этот дескриптор при Excel о том, что вызов функции завершения.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-124">Asynchronous user-defined functions must keep track of a handle and use that handle when informing Excel that the function call is finished.</span></span> <span data-ttu-id="8ab4c-125">Асинхронных пользовательских функций разбивается на две части.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-125">An asynchronous user-defined function is split into two pieces.</span></span> <span data-ttu-id="8ab4c-126">Первая часть — это стандартные UDF точка входа, запустит второй отдельной асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-126">The first piece is the standard UDF entry point, which will launch a second, separate asynchronous operation.</span></span> <span data-ttu-id="8ab4c-127">Во время точка входа UDF делаться обратных вызовов в Microsoft Excel.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-127">Callbacks into Excel should be made during the UDF entry point.</span></span> <span data-ttu-id="8ab4c-128">Запуск первой части функции будет возвращать управления потока вычислений в Excel, которая по-прежнему вычислений.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-128">The first launching portion of the function will then return control of its calculation thread to Excel, which will continue calculation.</span></span> <span data-ttu-id="8ab4c-129">После завершения второй асинхронной операции необходимо обратного вызова Excel и предоставляют Excel с помощью его результат.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-129">When the second asynchronous operation is complete, it must call back into Excel and provide Excel with its result.</span></span> 
  
> [!NOTE]
> <span data-ttu-id="8ab4c-130">Все аргументы, был передан в пользовательской функции, необходимая для асинхронного часть она должна быть глубокой скопировать, так как Excel освобождает следующие аргументы при возврате точка входа пользовательских Функций.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-130">Any arguments passed into the UDF that are needed by the asynchronous portion the function must be deep copied because Excel frees these arguments when the UDF entry point returns.</span></span> 
  
<span data-ttu-id="8ab4c-131">Excel предоставляет набор событий, которые надстройки XLL можно использовать для управления жизненным циклом асинхронные вызовы пользовательских Функций.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-131">Excel provides a set of events that an XLL add-in can use in order to manage the life cycle of asynchronous UDF calls.</span></span> <span data-ttu-id="8ab4c-132">Эти события указывают, что завершения с помощью вычисления или отмены вычисления.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-132">These events indicate that Excel is finished with calculations or that the calculation was canceled.</span></span>
  
### <a name="declaring-an-asynchronous-function"></a><span data-ttu-id="8ab4c-133">Объявление асинхронные функции</span><span class="sxs-lookup"><span data-stu-id="8ab4c-133">Declaring an asynchronous function</span></span>

<span data-ttu-id="8ab4c-134">Асинхронные пользовательские функции как асинхронная необходимо объявить при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-134">You must declare asynchronous user-defined functions as asynchronous when they are registered.</span></span> <span data-ttu-id="8ab4c-135">Это осуществляется путем добавления параметра, которая представлена точек на структуру XLOPER12 «X» в строке тип регистрации в любом месте в списке параметров UDF.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-135">This is performed by adding a parameter that points to a XLOPER12 structure, represented by "X" in the registration type string, anywhere in the list of UDF parameters.</span></span> <span data-ttu-id="8ab4c-136">Excel использует этот параметр для передачи дескриптор асинхронного вызова.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-136">Excel uses this parameter to pass the asynchronous call handle.</span></span> <span data-ttu-id="8ab4c-137">Надстройки XLL передает маркер асинхронного вызова и результат функции в Excel при готовности результат.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-137">The XLL add-in must pass the asynchronous call handle and the result of the function back to Excel when the result is ready.</span></span> <span data-ttu-id="8ab4c-138">Кроме того, возвращаемый тип UDF должен быть **void**, обозначенного «>» первым символом в тип string.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-138">In addition, the return type of the UDF should be **void**, designated by ">" as the first character in the type string.</span></span> <span data-ttu-id="8ab4c-139">Тип возвращаемого значения void, так как синхронные частью UDF не возвращает значение в Excel.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-139">The return type is void because the synchronous part of the UDF does not return a value to Excel.</span></span> <span data-ttu-id="8ab4c-140">Вместо этого надстройка XLL возвращает значение асинхронно посредством обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-140">Instead, the XLL add-in returns a value asynchronously through a callback.</span></span> 
  
<span data-ttu-id="8ab4c-141">Асинхронные функции можно объявить как потоками и затем используется синхронный частью пользовательскую Функцию на многопоточные вычисления.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-141">You can declare asynchronous functions as thread-safe and then the synchronous part of the UDF is used in a multi-threaded recalculation.</span></span> 
  
<span data-ttu-id="8ab4c-142">В следующем примере кода показана асинхронных пользовательских функций зарегистрирована с помощью "\>QX» как строка типа регистрации:</span><span class="sxs-lookup"><span data-stu-id="8ab4c-142">The following code example shows an asynchronous user-defined function registered by using "\>QX" as the registration type string:</span></span>
  
```cpp
void MyAsyncUDF(LPXLOPER12 arg1, LPXLOPER12 pxAsyncHandle)
{
…
}
```

### <a name="returning-values"></a><span data-ttu-id="8ab4c-143">Возвращаемые значения</span><span class="sxs-lookup"><span data-stu-id="8ab4c-143">Returning values</span></span>

<span data-ttu-id="8ab4c-144">Когда результат асинхронного вызова будет готов, надстройки XLL возвращает результат в Excel путем выполнения обратного вызова типа [xlAsyncReturn](xlasyncreturn.md).</span><span class="sxs-lookup"><span data-stu-id="8ab4c-144">When the result of the asynchronous call is ready, the XLL add-in returns the result to Excel by performing a callback of type [xlAsyncReturn](xlasyncreturn.md).</span></span>
  
<span data-ttu-id="8ab4c-145">**xlAsyncReturn** является единственным обратного вызова, которые можно использовать в потоках не вычислений во время пересчета.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-145">**xlAsyncReturn** is the only callback you can use on non-calculation threads during recalculation.</span></span> <span data-ttu-id="8ab4c-146">Таким образом асинхронная часть асинхронных пользовательских Функций не следует выполнять любые другие обратных вызовов.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-146">Therefore, the asynchronous part of an asynchronous UDF should not perform any other callbacks.</span></span> 
  
### <a name="handling-events"></a><span data-ttu-id="8ab4c-147">Обработка событий</span><span class="sxs-lookup"><span data-stu-id="8ab4c-147">Handling events</span></span>

<span data-ttu-id="8ab4c-148">Начиная с версии Excel 2010, XLL-модулей может получать события, предназначенное для управления жизненным циклом асинхронные функции.</span><span class="sxs-lookup"><span data-stu-id="8ab4c-148">Starting in Excel 2010, XLLs can receive events designed to manage the asynchronous function life cycle.</span></span> <span data-ttu-id="8ab4c-149">Дополнительные сведения см в [Обработке событий](handling-events.md).</span><span class="sxs-lookup"><span data-stu-id="8ab4c-149">For more information, see [Handling Events](handling-events.md).</span></span>
  
## <a name="see-also"></a><span data-ttu-id="8ab4c-150">См. также</span><span class="sxs-lookup"><span data-stu-id="8ab4c-150">See also</span></span>

- [<span data-ttu-id="8ab4c-151">���������� XLL-������� ��� Excel 2013</span><span class="sxs-lookup"><span data-stu-id="8ab4c-151">Developing Excel XLLs</span></span>](developing-excel-xlls.md)

