---
title: Управление памятью в Excel
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
ms.topic: overview
keywords:
- память xloper12 [excel 2007],управление памятью в Excel,стек Excel,строки [Excel 2007], управление памятью,управление памятью в Excel,память XLOPER [Excel 2007],память [Excel 2007], рекомендации по управлению
localization_priority: Normal
ms.assetid: 3bf5195b-6235-43cf-8795-0c7b0a63a095
description: 'Область применения: Excel 2013 | Office 2013 | Visual Studio'
ms.openlocfilehash: f129dac2971f01c8ada15f0028958132b1945746
ms.sourcegitcommit: 8657170d071f9bcf680aba50b9c07f2a4fb82283
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "33419543"
---
# <a name="memory-management-in-excel"></a>Управление памятью в Excel

 **Область применения:** Excel 2013 | Office 2013 | Visual Studio 
  
Если вы хотите создавать эффективные и стабильные XLL-надстройки, особого внимания требует управление памятью. Неправильное управление памятью может привести к целому ряду проблем в Microsoft Excel — от незначительных, таких как небольшие утечки памяти или ее неэффективное распределение и инициализация, до серьезных, таких как дестабилизация Excel.
  
Неправильное управление памятью — наиболее распространенная причина серьезных проблем, связанных с надстройками. Следовательно, создавайте проект только при наличии хорошо продуманной и последовательной стратегии управления памятью. 
  
С появлением многопоточного пересчета книг в Microsoft Office Excel 2007 управлять памятью стало сложнее. Если вы хотите создавать и экспортировать потокобезопасные функции листов, необходимо разрешать конфликты, которые могут возникать, если несколько потоков конкурируют за доступ.
  
Ниже приведены рекомендации для следующих трех типов структуры данных:
  
- **XLOPER** и **XLOPER12**;
    
- строки, не входящие в состав **XLOPER** или **XLOPER12**;
    
- массивы **FP** и **FP12**. 
    
## <a name="xloperxloper12-memory"></a>Память XLOPER и XLOPER12

Структура данных **XLOPER**/ **XLOPER12** включает несколько подтипов, содержащих указатели на блоки памяти, в частности строки (**xltypeStr**), массивы (**xltypeMulti**) и внешние ссылки (**xltypeRef**). Кроме того, обратите внимание, что массивы **xltypeMulti** могут содержать строку **XLOPER**/ **XLOPER12**, которая указывает на другие блоки памяти. 
  
Структуру **XLOPER**/ **XLOPER12** можно создать несколькими способами: 
  
- в Excel при подготовке аргументов для передачи в функцию XLL;
    
- в Excel при возвращении **XLOPER** или **XLOPER12** во время вызова API C; 
    
- в DLL при создании аргументов для передачи во время вызова API C;
    
- в DLL при создании возвращаемого значения функции XLL.
    
Блок памяти, принадлежащий к типу указателей на память, можно выделить под что-то несколькими способами:
  
- как статический блок в библиотеке DLL за пределами кода функции (в этом случае необязательно выделять или освобождать память);
    
- как статический блок в библиотеке DLL, входящий в код функции (в этом случае необязательно выделять или освобождать память);
    
- с помощью динамического выделения и освобождения в библиотеке DLL (**malloc** и **free**, **new** и **delete** и т. д.);
    
- с помощью динамического выделения в Excel.
    
Учитывая число возможных источников памяти **XLOPER**/ **XLOPER12** и количество ситуаций, в которых для структур данных **XLOPER**/ **XLOPER12** выделяется эта память, неудивительно, что эта тема может быть очень сложной. Тем не менее, если следовать нескольким правилам и рекомендациям, ее можно значительно упростить. 
  
### <a name="rules-for-working-with-xloperxloper12"></a>Правила работы с XLOPER/XLOPER12

- Не пытайтесь освободить память или перезаписать структуры данных **XLOPERs**/ **XLOPER12**, которые передаются как аргументы в функцию XLL. Эти аргументы предназначены только для чтения. Дополнительные сведения см. в разделе "Возвращение **XLOPER** или **XLOPER12** путем изменения аргументов на месте" статьи [Известные проблемы с разработкой XLL в Excel](known-issues-in-excel-xll-development.md).
    
- Если приложение Excel выделило память для структуры данных **XLOPER**/ **XLOPER12**, возвращаемой в DLL во время вызова API C: 
    
  - Когда структура **XLOPER**/ **XLOPER12** больше не будет вам нужна, необходимо освободить память, вызвав функцию [xlFree](xlfree.md). Не используйте для этого другие методы, например free или delete.
    
  - Если возвращается тип **xltypeMulti**, не перезаписывайте структуры данных **XLOPER**/ **XLOPER12** в массиве, особенно если они содержат строки или вы пробуете перезаписать их строкой.
    
  - Чтобы получить в Excel структуру **XLOPER**/ **XLOPER12** как возвращаемое значение функции DLL, необходимо сообщить приложению Excel о памяти, которую необходимо освободить после завершения работы. 
    
- Функцию **xlFree** необходимо вызывать только для структуры данных **XLOPER**/ **XLOPER12**, созданной в качестве возвращаемого значения при вызове API C. 
    
- Если библиотека DLL выделила память для структуры данных **XLOPER**/ **XLOPER12**, которую нужно получить в Excel в качестве возвращаемого значения функции DLL, необходимо сообщить приложению Excel, что библиотека DLL должна освободить память. 
    
### <a name="guidelines-for-memory-management"></a>Рекомендации по управлению памятью

- Используйте определенный метод для выделения и освобождения памяти в библиотеке DLL. Не смешивайте методы. Рекомендуем использовать нужный метод как структуру или класс памяти, где его можно изменять, не изменяя код в других местах.
    
- При создании массивов **xltypeMulti** в библиотеке DLL выделяйте память для строк определенным способом: всегда выделяйте память динамически или всегда используйте статическую память. В этом случае, освобождая память, вы будете знать, что необходимо всегда освобождать строки или никогда этого не делать. 
    
- Создавайте глубокие копии выделенной приложением Excel памяти при копировании созданной с помощью Excel структуры данных **XLOPER**/ **XLOPER12**.
    
- Не помещайте выделенные приложением Excel строки **XLOPER**/ **XLOPER12** в массивы **xltypeMulti**. Создавайте глубокие копии строк и храните указатели на эти копии в массиве. 
    
## <a name="freeing-excel-allocated-xloperxloper12-memory"></a>Освобождение выделенной приложением Excel памяти XLOPER/XLOPER12

В приведенной ниже команде XLL используется функция **xlGetName** для получения строки, содержащей имя DLL-файла и путь к нему, и функция **xlcAlert** для ее отображения в диалоговом окне оповещения.
  
```cs
int WINAPI show_DLL_name(void)
{
    XLOPER12 xDllName;
    if(Excel12(xlfGetName, &xDllName, 0) == xlretSuccess)
    {
        // Display the name.
        Excel12(xlcAlert, 0, 1, &xDllName);
        // Free the memory that Excel allocated for the string.
        Excel12(xlFree, 0, 1, &xDllName);
    }
    return 1;
}

```

Когда функции больше не нужна память, на которую указывает **xDllName**, она может освободить ее, вызвав [функцию xlFree](xlfree.md), одну из функций API C, предназначенную исключительно для библиотек DLL. 
  
Функция **xlFree** подробно описана в справочнике по функциям (см. статью [Функции API C, которые можно вызывать только из библиотеки DLL или XLL](c-api-functions-that-can-be-called-only-from-a-dll-or-xll.md)), но обратите внимание на следующее:
  
- Вы можете передавать указатели нескольким структурам данных **XLOPER**/ **XLOPER12** во время одного вызова функции **xlFree**. Единственное ограничение при этом — количество аргументов функции, которое поддерживается в используемой версии Excel (30 в Excel 2003, 255 в Excel 2007 и более поздних версий).
    
- Функция **xlFree** задает для содержащегося указателя значение **NULL**, чтобы обеспечить безопасность при попытке освобождения уже освобожденной структуры данных **XLOPER**/ **XLOPER12**. **xlFree** — это единственная функция API C, которая изменяет свои аргументы. 
    
- Вы можете безопасно вызывать функцию **xlFree** для любой структуры данных **XLOPER**/ **XLOPER12**, которая используется для получения возвращаемого значения при вызове API C, независимо от того, есть ли в ней указатель на память. 
    
## <a name="returning-xloperxloper12s-to-be-freed-by-excel"></a>Возвращение структур данных XLOPER или XLOPER12 для освобождения в Excel

Предположим, вы хотите заменить команду, приведенную в качестве примера в предыдущем разделе, на функцию листа, которая возвращает имя DLL-файла и путь к нему, если передается аргумент типа **Boolean** со значением **true**, и **#Н/Д**, если он не передается. Вы не можете вызвать функцию **xlFree**, чтобы освободить память строк, прежде чем возвращать ее в Microsoft Excel. Если ее не освободить, при каждом вызове функции работа надстройки будет приводить к утечке памяти. Чтобы обойти эту проблему, можно в поле **xltype** структуры данных **XLOPER**/ **XLOPER12** задать значение **xlbitXLFree** в файле xlcall.h. В результате Excel получит указание освобождать возвращаемую память после копирования выходного значения. 
  
### <a name="example"></a>Пример

В следующем примере кода показано преобразование команды XLL из предыдущего раздела в функцию листа XLL.
  
```cs
LPXLOPER12 WINAPI get_DLL_name(int calculation_trigger)
{
    static XLOPER12 xRtnValue; // Not thread-safe
    Excel12(xlfGetName, &xRtnValue, 0);
// If xlfGetName failed, xRtnValue will be #VALUE!
    if(xRtnValue.xltype == xltypeStr)
    {
// Tell Excel to free the string memory after
// it has copied out the return value.
        xRtnValue.xltype |= xlbitXLFree;
    }
    return &xRtnValue;
}
```

Функции XLL, которые используют структуры **XLOPER**/ **XLOPER12**, необходимо объявить как такие, которые принимают и возвращают указатели на **XLOPER**/ **XLOPER12**. Использование в этом примере статической памяти **XLOPER12** в функции не является потокобезопасным. Вы можете неправильно зарегистрировать эту функцию как потокобезопасную, но существует риск того, что значения **xRtnValue** будет заменено одним потоком до того, как другой поток завершит работу с ним. 
  
Значение **xlbitXLFree** необходимо задавать после вызова функции обратного вызова Excel, которая его выделяет. Если задать его до этого, оно будет перезаписано и не даст нужного эффекта. Если вы хотите использовать это значение в качестве аргумента во время вызова другой функции API C до его возвращения на лист, это значение следует задавать после такого вызова. В противном случае вы перепутаете функции, которые не маскируют это значение до проверки типа **XLOPER**/ **XLLOPER12**. 
  
## <a name="returning-xloperxloper12s-to-be-freed-by-the-dll"></a>Возвращение структур данных XLOPER или XLOPER12 для освобождения в библиотеке DLL

Аналогичная проблема возникает, когда надстройка XLL выделяет память **XLOPER**/ **XLOPER12** и хочет возвратить ее в Excel. Excel распознает еще одно значение, которое можно задать в поле **xltype** структуры данных **XLOPER**/ **XLOPER12**, — **xlbitDLLFree** в файле xlcall.h. 
  
Получая структуру **XLOPER**/ **XLOPER12** с этим значением, Excel пытается вызвать функцию [xlAutoFree](xlautofree-xlautofree12.md) (для **XLOPER**) или **xlAutoFree12** (для **XLOPER12**), которую должна экспортировать надстройка XLL. Эта функция более подробно описана в справочнике по функциям (см. статью [Функции диспетчера надстроек и интерфейса XLL](add-in-manager-and-xll-interface-functions.md)), но пример минимальной реализации приведен здесь. Она предназначена для освобождения памяти **XLOPER**/ **XLOPER12** тем же способом, которым она изначально была выделена. 
  
### <a name="examples"></a>Примеры

Действие функции в приведенном ниже примере аналогично действию предыдущей функции (за исключением того, что она содержит текст "The full pathname for this DLL is" перед именем DLL).
  
```cs
#include <string.h>
LPXLOPER12 WINAPI get_DLL_name_2(int calculation_trigger)
{
    static XLOPER12 xRtnValue; // Not thread-safe
    Excel12(xlfGetName, &xRtnValue, 0);
// If xlfGetName failed, xRtnValue will be #VALUE!
    if(xRtnValue.xltype != xltypeStr)
        return &xRtnValue;
// Make a copy of the DLL path and file name.
    wchar_t *leader = L"The full pathname for this DLL is ";
    size_t leader_len = wcslen(leader);
    size_t dllname_len = xRtnValue.val.str[0];
    size_t msg_len = leader_len + dllname_len;
    wchar_t *msg_text = (wchar_t *)malloc(msg_len + 1);
    wcsncpy_s(msg_text + 1, leader, leader_len);
    wcsncpy_s(msg_text + 1 + leader_len, xRtnValue.val.str + 1,
        dllname_len);
    msg_text[0] = msg_len;
// Now the original string has been copied Excel can free it.
    Excel12(xlFree, 0, 1, &xRtnValue);
// Now reuse the XLOPER12 for the new string.
    xRtnValue.val.str = msg_text;
// Tell Excel to call back into the DLL to free the string
// memory after it has copied out the return value.
    xRtnValue.xltype     = xltypeStr | xlbitDLLFree;
    return &xRtnValue;
}
```

Ниже показана минимальная реализация функции **xlAutoFree12** в надстройке XLL, экспортировавшей предыдущую функцию. 
  
```cs
void WINAPI xlAutoFree12(LPXLOPER12 p_oper)
{
    if(p_oper->xltype == (xltypeStr | xlbitDLLFree))
        free(p_oper->val.str);
}
```

Этой реализации достаточно, только если надстройка XLL возвращает строки **XLOPER12** и они выделяются с помощью функции **malloc**. Обратите внимание, что в этом случае тест 
  
 ` if(p_oper->xltype == xltypeStr) `
  
даст сбой, так как задано значение **xlbitDLLFree**. 
  
В общем, функции **xlAutoFree** и **xlAutoFree12** необходимо реализовать так, чтобы они освобождали память, связанную с созданными при помощи XLL массивами **xltypeMulti** и внешними ссылками **xltypeRef**. 
  
Вы можете реализовать функции XLL так, чтобы ВСЕ они возвращали динамически выделяемые структуры данных **XLOPER** и **XLOPER12**. В этом случае потребуется задать значение **xlbitDLLFree** для всех таких структур данных **XLOPER** и **XLOPER12** независимо от подтипа. Кроме того, необходимо реализовать функции **xlAutoFree** и **xlAutoFree12**, чтобы освободить эту память, а также память, указанную в **XLOPER**/ **XLOPER12**. Это один из способов сделать возвращаемое значение потокобезопасным. Например, предыдущую функцию можно переписать следующим образом:
  
```cs
#include <string.h>
LPXLOPER12 WINAPI get_DLL_name_3(int calculation_trigger)
{
// Thread-safe
    LPXLOPER12 pxRtnValue = (LPXLOPER12)malloc(sizeof(XLOPER12));
    Excel12(xlfGetName, pxRtnValue, 0);
// If xlfGetName failed, pxRtnValue will be #VALUE!
    if(pxRtnValue->xltype != xltypeStr)
    {
// Even though an error type does not point to memory,
// Excel needs to pass this oper to xlAutoFree12 to
// free pxRtnValue itself.
        pxRtnValue->xltype |= xlbitDLLFree;
        return pxRtnValue;
    }
// Make a copy of the DLL path and file name.
    wchar_t *leader = L"The full pathname for this DLL is ";
    size_t leader_len = wcslen(leader);
    size_t dllname_len = pxRtnValue->val.str[0];
    size_t msg_len = leader_len + dllname_len;
    wchar_t *msg_text = (wchar_t *)malloc(msg_len + 1);
    wcsncpy_s(msg_text + 1, leader, leader_len);
    wcsncpy_s(msg_text + 1 + leader_len, pxRtnValue->val.str + 1,
        dllname_len);
    msg_text[0] = msg_len;
// Now the original string has been copied Excel can free it.
    Excel12(xlFree, 0, 1, pxRtnValue);
// Now reuse the XLOPER12 for the new string.
    pxRtnValue->val.str = msg_text;
    pxRtnValue->xltype = xltypeStr | xlbitDLLFree;
    return pxRtnValue;
}
void WINAPI xlAutoFree12(LPXLOPER12 p_oper)
{
    if(p_oper->xltype == (xltypeStr | xlbitDLLFree))
        free(p_oper->val.str);
    free(p_oper);
}
```

Дополнительные сведения о функциях **xlAutoFree** и **xlAutoFree12** см. в статье [xlAutoFree/xlAutoFree12](xlautofree-xlautofree12.md).
  
## <a name="returning-modify-in-place-arguments"></a>Возвращение аргументов, изменяемых на месте

В Excel функция XLL может возвращать значение, изменяя аргумент на месте. Это возможно, только если аргумент передается в виде указателя. Для этого функцию необходимо зарегистрировать так, чтобы указать Excel, какой аргумент будет изменяться. 
  
Этот метод для возвращения значения поддерживается для всех типов данных, которые можно передавать с помощью указателя, но особенно полезен для следующих типов:
  
- строки байтов ASCII, для которых предусмотрен счетчик длины и которые оканчиваются нулем;
    
- строки расширенных символов Юникода со счетчиком длины, оканчивающиеся нулем (в Excel 2007 и более поздних версий);
    
- массивы **FP** с плавающей запятой; 
    
- массивы **FP12** с плавающей запятой (в Excel 2007 и более поздних версий). 
    
> [!NOTE]
> Не следует пытаться возвращать таким образом структуру **XLOPER** или **XLOPER12**. Дополнительные сведения см. в статье [Известные проблемы с разработкой XLL в Excel](known-issues-in-excel-xll-development.md). 
  
Преимущество этого способа над использованием оператора возвращения заключается в том, что Excel выделяет память для возвращаемых значений. Завершив чтение возвращаемых данных, Excel освобождает память. Это освобождает функцию XLL от управления памятью. Этот способ потокобезопасен: когда функция в Excel вызывается одновременно в различных потоках, для каждого такого вызова предусмотрен свой буфер.
  
Это удобно при использовании приведенных выше типов данных, потому что механизм обратного вызова DLL для освобождения памяти после возвращения, который используется для структуры **XLOPER**/ **XLOPER12**, не существует для простых строк и массивов **FP**/ **FP12**. Следовательно, при возвращении созданной с помощью DLL строки или массива с плавающей запятой у вас есть приведенные ниже варианты. 
  
- Установите постоянный указатель для динамически выделяемого буфера, возвратите указатель. Во время следующего вызова функции (1) убедитесь, что значение указателя — не ноль, (2) освободите ресурсы, выделенные во время предыдущего вызова, и обнулите значение указателя, (3) повторно используйте указатель для нового выделенного блока памяти.
    
- Создайте строки и массивы в статическом буфере, который не нужно освобождать, и возвратите указатель в него.
    
- Измените аргументы на месте, записав строку или массив непосредственно в пространство, выделенное приложением Excel.
    
В противном случае необходимо создать **XLOPER**/ **XLOPER12** и использовать функцию **xlbitDLLFree**, а также **xlAutoFree**/ **xlAutoFree12** для освобождения ресурсов. 
  
Последний вариант может быть самым простым, если передается аргумент того же типа, что и возвращаемое значение. Обратите внимание, что размеры буферов ограничены и его не следует переполнять (это может вызвать сбой Excel). Размеры буфера для строк и массивов **FP**/ **FP12** приведены ниже. 
  
## <a name="strings"></a>Строки

Проблемы с управлением памятью строк — наиболее распространенная причина нестабильной работы приложений и надстроек. Это понятно, учитывая множество различных типов строк и способов обработки. Есть строки, которые оканчиваются нулем или для которых используется счетчик длины (а еще строки, для которых выполняются оба эти условия); статические или динамические буферы; строки фиксированной длины или практически неограниченной длины; память, управляемая операционной системой (например, OLE Bstr), или неуправляемые строки, а также другие варианты.
  
Программисты C/C++ чаще всего используют строки, оканчивающиеся нулем. Стандартная библиотека C предназначена для работы с такими строками. Статические строковые литералы в коде компилируются в строки, оканчивающиеся нулем. Кроме того, Excel работает со строками со счетчиком длины, которые обычно не оканчиваются нулем. Сочетание этих фактов требует четкого и последовательного подхода к обработке строк и памяти строк в DLL и XLL.
  
Ниже приведены наиболее распространенные проблемы.
  
- Передача пустого или недопустимого указателя в функцию, которая ожидает допустимый указатель и не проверяет или не может проверить его допустимость.
    
- Переполнение буфера строки функцией, которая не сопоставляет или не может сопоставить размер буфера и длину записываемой строки.
    
- Попытка освободить память буфера строки, если он статический или уже освобожденный, а также если способы освобождения и выделения не совпадают.
    
- Утечки памяти в результате выделения без последующего освобождения строк (обычно в часто вызываемой функции).
    
### <a name="rules-for-strings"></a>Правила для строк

Как и для **XLOPER**/ **XLOPER**, для строк существуют правила и рекомендации, которым необходимо следовать. Рекомендации не отличаются от приведенных в предыдущем разделе. Дополнительные правила для строк приведены ниже.
  
 **Правила:**
  
- Не пытайтесь освободить память или перезаписать строки **XLOPER**/ **XLOPER12**, а также простые строки со счетчиком длины или строки, оканчивающиеся нулем, которые передаются как аргументы в функцию XLL. Такие аргументы предназначены только для чтения.
    
- Если Excel выделяет память для строки **XLOPER**/ **XLOPER12** с возвращаемым значением функции обратного вызова API C, освободите ее с помощью функции **xlFree** или задайте значение **xlbitXLFree** при ее возвращении в Excel из функции XLL. 
    
- Если библиотека DLL динамически выделяет буфер строк для **XLOPER**/ **XLOPER12**, после завершения работы освободите его тем же способом, который использовался для выделения, или задайте **xlbitDLLFree** при его возвращении в Excel из функции XLL, а затем освободите его с помощью функции **xlAutoFree**/ **xlAutoFree12**.
    
- Если Excel выделяет память для массива **xltypeMulti**, возвращаемого в библиотеку DLL во время вызова API C, не перезаписывайте строки **XLOPER**/ **XLOPER12** в массиве. Для освобождения этих массивов необходимо использовать только функцию **xlFree** или значение **xlbitXLFree** при возвращении из функции XLL.
    
### <a name="string-types-supported"></a>Поддерживаемые типы строк

**Строки xltypeStr для XLOPER/XLOPER12 в API C**

|**Строка байтов: **XLOPER****|**Строки расширенных символов: **XLOPER12****|
|:-----|:-----|
|Все версии Excel  <br/> |Начиная с Excel 2007  <br/> |
|Максимальная длина: 255 байтов расширенного кода ASCII  <br/> |Максимальная длина: 32 767 символов Юникода  <br/> |
|Первый байт (без знака) = длина  <br/> |Первый символ Юникода = длина  <br/> |
   
> [!IMPORTANT]
> Строки **XLOPER** или **XLOPER12** не должны оканчиваться нулем. 
  
**Строки C/C++**

|**Строки байтов**|**Строки расширенных символов**|
|:-----|:-----|
|Оканчивающиеся нулем (**char** *), тип "C", максимальная длина составляет 255 байтов расширенного кода ASCII  <br/> |Оканчивающиеся нулем (**wchar_t** *), тип "C%", максимальная длина составляет 32 767 символов Юникода  <br/> |
|Со счетчиком длины (**unsigned char** *) "D"  <br/> |Со счетчиком длины (**wchar_t** *) "D%"  <br/> |
   
### <a name="strings-in-xltypemulti-xloperxloper12-arrays"></a>Строки в массивах XLOPER/XLOPER12 xltypeMulti

В некоторых случаях Excel создает массив **xltypeMulti** для использования в библиотеках DLL и XLL. Несколько информационных функций XLM возвращают такие массивы. Например, функция API C **xlfGetWorkspace** при передаче ей аргумента *44* возвращает массив, содержащий строки, которые описывают все зарегистрированные процедуры DLL. Функция API C **xlfDialogBox** возвращает измененную копию аргумента массива, содержащую глубокие копии строк. Возможно, чаще всего библиотека XLL обнаруживает массив **xltypeMulti** при его передаче в качестве аргумента в функцию XLL или преобразовании в этот тип из типа ссылок на диапазон. В таких случаях Excel создает глубокие копии строк в исходных ячейках и указывает на них в массиве. 
  
Если вы хотите изменить эти строки в библиотеке DLL, следует создать собственные глубокие копии. При создании собственных массивов **xltypeMulti** не следует помещать в них выделенные приложением Excel строки **XLOPER**/ **XLOPER12**. Существует риск того, что они будут освобождены неправильно или не освобождены вообще. Кроме того, следует создавать глубокие копии строк и хранить указатели на копии в массиве.
  
 **Примеры**
  
В следующем примере функция создает динамически выделяемую копию строки Юникода со счетчиком длины. Обратите внимание, что вызывающая сторона в конечном счете должна освободить память, выделяемую в этом примере, с помощью оператора **delete**[], а исходная строка не должна оканчиваться нулем. Строка копии усекается, если это необходимо для безопасности, и не оканчивается нулем.
  
```cs
#include <string.h>
#define MAX_V12_STRBUFFLEN    32678
    
wchar_t * deep_copy_wcs(const wchar_t *p_source)
{
    if(!p_source)
        return NULL;
    size_t source_len = p_source[0];
    bool truncated = false;
    if(source_len >= MAX_V12_STRBUFFLEN)
    {
        source_len = MAX_V12_STRBUFFLEN - 1; // Truncate the copy
        truncated = true;
    }
    wchar_t *p_copy = new wchar_t[source_len + 1];
    wcsncpy_s(p_copy, p_source, source_len + 1);
    if(truncated)
        p_copy[0] = source_len;
    return p_copy;
}
```

Затем с помощью этой функции можно безопасно копировать **XLOPER12**, как показано на примере следующей экспортируемой функции XLL, возвращающей копию аргумента, если это строка. Все другие типы возвращаются как пустая строка. Обратите внимание, что диапазоны не обрабатываются — функция возвращает **#ЗНАЧ!**. Эту функцию необходимо зарегистрировать как такую, которая принимает аргумент типа "U", для передачи ссылок в виде значений. Она эквивалентна встроенной функции листа **T()** (за исключением того, что **AsText** также преобразует ошибки в пустые строки). В этом примере кода предполагается, что **xlAutoFree12** освобождает переданный указатель, а также его содержимое, с помощью оператора **delete**.
  
```cs
LPXLOPER12 WINAPI AsText(LPXLOPER12 pArg)
{
    LPXLOPER12 pRtnVal = new XLOPER12;
// If the input was an array, only operate on the top-left element.
    LPXLOPER *pTemp;
    if(pArg->xltype == xltypeMulti)
        pTemp = pArg->val.array.lparray;
    else
        pTemp = pArg;
    switch(pTemp->xltype)
    {
        case xltypeErr:
        case xltypeNum:
        case xltypeMissing:
        case xltypeNil:
        case xltypeBool:
            pRtnVal->xltype = xltypeStr | xlbitDLLFree;
            pRtnVal->val.str = deep_copy_wcs(L"\000");
            return pRtnVal;
        case xltypeStr:
            pRtnVal->xltype = xltypeStr | xlbitDLLFree;
            pRtnVal->val.str = deep_copy_wcs(pTemp->val.str);
            return pRtnVal;
        
        default: // xltypeSRef, xltypeRef, xltypeFlow, xltypeInt
            pRtnVal->xltype = xltypeErr | xlbitDLLFree;
            pRtnVal->val.err = xlerrValue;
            return pRtnVal;
    }
}
```

### <a name="returning-modify-in-place-string-arguments"></a>Возвращение строковых аргументов, изменяемых на месте

Аргументы, зарегистрированные как аргументы типов **F**, **G**, **F%** и **G%**, можно изменять на месте. Подготавливая строковые аргументы для этих типов, Excel создает буфер максимального размера. Затем Excel копирует в него строку аргумента, даже если она значительно короче. Это позволяет функции XLL записывать возвращаемое значение непосредственно в ту же память. 
  
Ниже приведены размеры буфера, установленные для этих типов.
  
- **Строки байтов:** 256 байтов, включая счетчик длины (тип "G") или завершающий символ нуля (тип "F"). 
    
- **Строки в кодировке Юникод:** 32 768 расширенных символов (65 536 байтов), включая счетчик длины (тип "G%") или завершающий символ нуля (тип "F%"). 
    
> [!NOTE]
> Эту функцию невозможно вызвать непосредственно из Visual Basic для приложений (VBA), так как вы не можете гарантировать выделение буфера достаточно большого размера. Безопасно эту функцию можно вызвать только из другой библиотеки DLL, если вы явно выделили достаточно большой буфер. 
  
Ниже приведен пример функции XLL, которая обращает последовательность расширенных символов в переданной строке, оканчивающейся нулем, используя стандартную функцию библиотеки **wcsrev**. Аргумент в этом случае будет зарегистрирован как аргумент типа **F%**.
  
```cs
void WINAPI reverse_text_xl12(wchar_t *text)
{
    _wcsrev(text);
}
```

## <a name="persistent-storage-binary-names"></a>Постоянное хранилище (двоичные имена)

Двоичные имена определяются и связываются с блоками двоичных (то есть неструктурированных) данных, хранящихся вместе с книгой. Они создаются с помощью функции [xlDefineBinaryName](xldefinebinaryname.md), а для получения данных используется функция [xlGetBinaryName](xlgetbinaryname.md). Подробные описания обеих функций представлены в справочнике по функциям (см. статью [Функции API C, которые можно вызывать только из библиотеки DLL или XLL](c-api-functions-that-can-be-called-only-from-a-dll-or-xll.md)). Обе эти функции используют **XLOPER**/ **XLOPER12** для **xltypeBigData**. 
  
Сведения об известных проблемах, которые ограничивают практическое применение двоичных имен, см. в статье [Известные проблемы](known-issues-in-excel-xll-development.md).
  
## <a name="excel-stack"></a>Стек Excel

Excel использует стек вместе со всеми загруженными библиотеками DLL. Места в стеке обычно более чем достаточно для обычного использования. О нем не нужно беспокоиться, если вы выполняете следующие рекомендации: 
  
- Не передавайте очень большие структуры в качестве аргументов функций в виде значений в стеке. Передавайте указатели или ссылки.
    
- Не возвращайте большие структуры в стеке. Возвращайте указатели на статическую или динамически выделяемую память или используйте аргументы, передаваемые с использованием ссылки.
    
- Не объявляйте очень большие структуры автоматических переменных в коде функции. Если необходимо, объявите их как статические.
    
- Не вызывайте функции рекурсивно, если не уверены, что рекурсия всегда будет неполной. Вместо этого используйте цикл.
    
Получая обратный вызов от библиотеки DLL с помощью API C, Excel сначала проверяет, достаточно ли места в стеке для самого худшего сценария. Если Excel посчитает, что свободного места может быть недостаточно, он обработает вызов как небезопасный, даже если на самом деле места достаточно. В этом случае при обратном вызове возвращается код **xlretFailed**. При обычном использовании API C и стека сбой вызова API C вряд ли произойдет по этой причине.
  
Если вы хотите исключить недостаток места в стеке из возможных причин сбоя, узнайте объем стека, вызвав функцию [xlStack](xlstack.md). 
  
## <a name="see-also"></a>См. также



[Многопоточный пересчет в Excel](multithreaded-recalculation-in-excel.md)
  
[Многопоточность и конфликты памяти в Excel](multithreading-and-memory-contention-in-excel.md)
  
[Разработка XLL-файлов для Excel](developing-excel-xlls.md)

