---
title: Разработка библиотек DLL
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
ms.topic: overview
keywords:
- dlls [excel 2007], creating,creating DLLs [Excel 2007]
ms.assetid: 5d69d06d-a126-4c47-82ad-17112674c8a3
description: 'Область применения: Excel 2013 | Office 2013 | Visual Studio'
localization_priority: Priority
ms.openlocfilehash: 89dd7b65ad94ba2fc7e1cf3f99ee163d3003d0fe
ms.sourcegitcommit: d6695c94415fa47952ee7961a69660abc0904434
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/17/2019
ms.locfileid: "28704751"
---
# <a name="developing-dlls"></a>Разработка библиотек DLL

**Область применения**: Excel 2013 | Office 2013 | Visual Studio 
  
Библиотека — это скомпилированный код, который обеспечивает функции исполняемого приложения и предоставляет ему данные. Библиотеки могут быть связаны статически и динамически, обычно у них расширение LIB и DLL соответственно. Статические библиотеки (например, библиотека времени выполнения C) связываются с приложением во время компиляции и становятся частью полученного исполняемого файла. Приложение загружает библиотеку DLL, когда она необходима (обычно при запуске). Одна библиотека DLL может загружать другую библиотеку DLL и динамически ссылаться на нее.
  
## <a name="benefits-of-using-dlls"></a>Преимущества библиотек DLL

Ниже приведены основные преимущества библиотек DLL.
  
- Все приложения могут использовать одну копию на диске.
    
- Исполняемые файлы приложений хранятся в меньшем размере.
    
- Возможность разбивать большие проекты. Разработчики приложений и библиотек DLL должны только согласовать интерфейс соответствующих частей. Этот интерфейс экспортируется в библиотеке DLL.
    
- Разработчики DLL могут обновлять библиотеки DLL, чтобы повысить их эффективность или исправить ошибку, не обновляя все использующие их приложения, если экспортированный интерфейс библиотеки DLL не изменяется.
    
С помощью DLL можно добавлять функции и команды в Microsoft Excel.
  
## <a name="resources-for-creating-dlls"></a>Ресурсы для создания библиотек DLL

Вот что нужно, чтобы создать библиотеку DLL:
  
- Редактор исходного кода.
    
- Компилятор для преобразования исходного кода в объектный, совместимый с оборудованием.
    
- Компоновщик для добавления кода из статических библиотек и создания исполняемого DLL-файла.
    
В современных интегрированных средах разработки (IDE), например Microsoft Visual Studio, есть все эти компоненты, а также смарт-редакторы, инструменты для отладки кода и управления несколькими проектами, мастера создания проектов и другие важные инструменты.
  
Вы можете создавать библиотеки DLL на нескольких языках, например C/C++, Pascal и Visual Basic. Так как исходный код API Excel — C и C++, в этой документации рассматриваются только эти два языка.
  
## <a name="exporting-functions-and-commands"></a>Экспорт функций и команд

При компиляции проекта DLL компилятор и компоновщик должны знать, какие функции экспортировать, чтобы предоставить к ним доступ в приложении. В этом разделе описаны возможные способы.
  
При компиляции исходного кода компиляторы обычно изменяют имена функций. Для этого они обычно добавляют символы в начало или конец имени. Этот процесс называется декорирование имени. Необходимо убедиться, что приложение, загружающее библиотеку DLL, может распознать имя экспортируемой функции. Для этого может потребоваться дать указание компоновщику сопоставить расширенное имя с более простым именем экспорта. Это может быть имя из исходного кода или другое.
  
Способ декорирования имени зависит от языка и способа вызова функции, задаваемого компилятором, т. е. соглашения о вызовах. Стандартное межпроцессное соглашение о вызовах для Windows, используемое в библиотеках DLL, — это WinAPI. В файлах заголовков Windows оно обозначено как **WINAPI** с помощью декларатора Win32 **__stdcall**.
  
Функция, экспортируемая в DLL-файл для Excel (функция листа, функция, эквивалентная листу макросов, или пользовательская команда) всегда должна использовать соглашение о вызовах **WINAPI** / **__stdcall**. В определение функции необходимо явно включить указатель **WINAPI**, так как по умолчанию в компиляторах Win32 используется соглашение о вызовах  **__cdecl**, также обозначенное как **WINAPIV**.
  
Вы можете сообщить компоновщику о необходимости экспорта функции, а также ее внешнее имя несколькими способами:
  
- Поместите функцию в DEF-файл после ключевого слова **EXPORTS** и добавьте ссылку на этот файл в параметр проекта DLL во время связывания. 
    
- Используйте декларатор **__declspec(dllexport)** в определении функции. 
    
- Используйте директиву препроцессора **#pragma** для отправки сообщения компоновщику. 
    
В проекте можно использовать все три способа, они поддерживаются и компилятором, и компоновщиком, но не следует экспортировать одну функцию более чем одним способом. Например, предположим, что библиотека DLL содержит два модуля исходного кода, C и C++, которые содержат две функции для экспорта — **my\_C\_export** и **my\_Cpp\_export** соответственно. Для простоты предположим, что функции принимают один числовой аргумент двойной точности и возвращают данные того же типа. В следующих разделах описываются варианты экспорта функций с помощью каждого из этих методов. 
  
### <a name="using-a-def-file"></a>С помощью DEF-файла

```C
double WINAPI my_C_export(double x)
{
/* Modify x and return it. */
    return x * 2.0;
}
```

```cpp
double WINAPI my_Cpp_export(double x)
{
// Modify x and return it.
    return x * 2.0;
}
```

<br/>

DEF-файл должен содержать следующие строки.
  
`EXPORTS my_C_export = _my_C_export@8  my_Cpp_export`

<br/>

Ниже приведен общий синтаксис строки, следующей за оператором **EXPORTS**. 
  
`entryname[=internalname] [@ordinal[NONAME]] [DATA] [PRIVATE]`

Обратите внимание, что функция C декорирована, но в DEF-файле компоновщику явно дано указание предоставлять эту функцию, используя имя из исходного кода (в данном примере). Компоновщик неявно экспортирует функцию C++, используя имя исходного кода, так что в DEF-файл необязательно включать расширенное имя.
  
Соглашение для вызовов функций API 32-разрядной Windows предусматривает следующее декорирование функций C: **function_name** становится _ **function_name@** _n_, где _n_ — количество байтов, выраженное в виде десятичного числа, принимаемого всеми аргументами, при этом количество байтов для каждого округляется до ближайшего числа, кратного четырем. 
  
> [!NOTE]
> Размер всех указателей в Win32 — четыре байта. Тип возвращаемого значения не влияет на декорирование имени. 
  
Чтобы компилятор C++ предоставлял функции, используя нерасширенные имена, заключите функцию и ее прототипы во внешний блок "C" {…}, как показано в приведенном ниже примере. (Фигурные скобки **{}** здесь опущены, так как объявление относится только к блоку кода функции, расположенному непосредственно за ним). 
  
```cpp
extern "C"
double WINAPI my_undecorated_Cpp_export(double x)
{
// Modify x and return it.
    return x * 2.0;
}

```

При размещении прототипов функции C в файлах заголовков, которые могут быть включены в исходные файлы C или C++, необходимо включить следующую директиву препроцессора.
  
```cpp
#ifdef __cplusplus
extern "C" {
#endif
double WINAPI my_C_export(double x);
double WINAPI my_Cdecorated_Cpp_export(double x);
#ifdef __cplusplus
}
#endif
```

### <a name="using-the-declspecdllexport-declarator"></a>С помощью декларатора __declspec(dllexport)

Ключевое слово **__declspec(dllexport)** можно использовать в объявлении функции указанным ниже образом. 
  
```cpp
__declspec(dllexport) double WINAPI my_C_export(double x)
{
/* Modify x and return it. */
    return x * 2.0;
}
```

Ключевое слово **__declspec(dllexport)** необходимо добавить в крайней левой части объявления. Преимущества этого подхода: функцию не нужно указывать в DEF-файле, а состояние экспорта указывается вместе с определением. 
  
Если вы не хотите декорировать имя функции C++, необходимо объявить функцию следующим образом.
  
```cpp
extern "C"
__declspec(dllexport) double WINAPI my_undecorated_Cpp_export(double x)
{
// Modify x and return it.
    return x * 2.0;
}
```

Компоновщик сделает функцию доступной под именем my_undecorated_Cpp_export, то есть именем из исходного кода, без декорирования.
  
### <a name="using-a-pragma-preprocessor-linker-directive"></a>С помощью директивы компоновщика препроцессора #pragma

Последние версии Microsoft Visual Studio поддерживают два предопределенных макроса, которые при использовании с директивой **#pragma** позволяют давать указание компоновщику экспортировать функции непосредственно в коде функции. Макросы __FUNCTION__ и __FUNCDNAME__ (обратите внимание на два символа подчеркивания с каждой стороны) используются с недекорированными и декорированными именами функций соответственно. 
  
Например, при использовании Microsoft Visual Studio эти строки можно включить в общий файл заголовка, как показано ниже.
  
```cpp
#if _MSC_VER > 1200 // Later than Visual Studio 6.0
#define EXPORT comment(linker, "/EXPORT:"__FUNCTION__"="__FUNCDNAME__)
#else // Cannot use this way of exporting functions.
#define EXPORT
#endif // else need to use DEF file or __declspec(dllexport)

```

Если такой заголовок включен в исходные файлы, две функции, приведенные в качестве примера, можно экспортировать следующим образом.
  
Код C:
  
```C
double WINAPI my_C_export(double x)
{
#pragma EXPORT
/* Modify x and return it. */
    return x * 2.0;
}
```

Код C++:
  
```cpp
double WINAPI my_Cpp_export(double x)
{
#pragma EXPORT
// Modify x and return it.
    return x * 2.0;
}
```

Обратите внимание, что директиву необходимо поместить в код функции. Ее можно развернуть, только если параметры **/EP** и **/P** компилятора не заданы. При использовании этого способа исчезает необходимость в DEF-файле и объявлении **__declspec(dllexport)**, а спецификация состояния экспорта указывается в коде функции. 
  
## <a name="see-also"></a>См. также

- [Доступ к библиотекам DLL в Excel](how-to-access-dlls-in-excel.md)
- [Вызов Excel из библиотеки DLL или XLL](calling-into-excel-from-the-dll-or-xll.md)
- [Понятия, связанные с программированием, для Excel](excel-programming-concepts.md)
- [Разработка XLL-файлов для Excel](developing-excel-xlls.md)

