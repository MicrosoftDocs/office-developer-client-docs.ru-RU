---
title: Сведения о конечном автомате репликации
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
localization_priority: Normal
ms.assetid: cf36c6cb-57b4-7b2b-e23d-e0bc8696de96
description: 'Дата последнего изменения: 9 марта 2015 г.'
ms.openlocfilehash: a0644e4bf5c6847d61cc59e203d50f61ad142e84
ms.sourcegitcommit: 8657170d071f9bcf680aba50b9c07f2a4fb82283
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "33416484"
---
# <a name="about-the-replication-state-machine"></a>Сведения о конечном автомате репликации

  
  
**Относится к**: Outlook 2013 | Outlook 2016 
  
В этом разделе представлен обзор конечного автомата для Microsoft Outlook 2013 и Microsoft Outlook 2010, русская версия данных.
  
> [!NOTE]
> API репликации должен быть полностью реализован в соответствии с инструкциями в этом разделе, чтобы он был полезен или поддерживается. API репликации доступен исключительно для репликации изменений Outlook 2013 или Outlook 2010 на сервере и с него. 
  
## <a name="iostx-and-the-state-machine"></a>IOSTX и state Machine

Клиент вызывает **[IOSTX::SyncBeg,](iostx-syncbeg.md)** **[IOSTX::SyncEnd,](iostx-syncend.md)** **[IOSTX::SyncHdrBeg](iostx-synchdrbeg.md)** и **[IOSTX::SyncHdrEnd](iostx-synchdrend.md)** в последовательности для синхронизации папок и элементов Outlook 2013 или Outlook 2010 между локальным хранилищем и сервером. Фактическая последовательность вызовов зависит от данных, которые необходимо реплицировать (например, иерархии папок Outlook 2013 или Outlook 2010, папки Outlook 2013 или Outlook 2010, почтовых элементов, элементов календаря и т. п.) и направления синхронизации (отправка из локального магазина на сервер или загрузка с сервера в локальное хранилище). Вот типичная последовательность вызовов: 
  
1. Клиент вызывает **IOSTX::SyncBeg** для начала репликации, указав идентификатор состояния и указатель на адрес соответствующей структуры данных. 
    
2. Outlook 2013 или Outlook 2010 выделяет структуру данных и инициализирует структуру данных с необходимыми сведениями для клиента. 
    
3. Клиент выполняет репликацию, обновляя структуру данных для передачи в локальное хранилище всех необходимых сведений о репликации.
    
4. После выполнения репликации клиент вызывает **[IOSTX::SetSyncResult](iostx-setsyncresult.md)** и **IOSTX::SyncEnd,** чтобы уведомить локальное хранилище о завершении определенной репликации. 
    
> [!NOTE]
> Клиент всегда вызывает **IOSTX::SyncEnd,** чтобы закончить репликацию, которую клиент начал для определенного состояния. В зависимости от общих данных, которые требуется синхронизировать клиенту, клиент может вызывать пару вызовов **IOSTX::SyncBeg** и **IOSTX::SyncEnd** несколько раз. 
  
## <a name="state-table"></a>Таблица State

> [!NOTE]
> В следующей таблице перечислены все допустимые состояния на автомате репликации, а также соответствующие идентификаторы состояния и структуры данных. В **столбце "Реплицированные** данные" термин "элементы" включает элементы почты, календаря, контакта, заметки, журнала и задачи. При репликации изменений из локального хранения на сервер используйте идентификаторы состояния, определяющие "UPLOAD" и структуры данных с префиксом "UP" **(например, LR_SYNC_UPLOAD_HIERARCHY** и **[UPHIER).](uphier.md)** При репликации изменений с сервера в локальное хранилище используйте идентификаторы состояния, определяющие "DOWNLOAD" и структуры данных с префиксом "DN" (например, **LR_SYNC_DOWNLOAD_HIERARCHY** и **[DNHIER).](dnhier.md)** 
  
|||||
|:-----|:-----|:-----|:-----|
|**State** <br/> |**Реплицированные данные** <br/> |**Идентификатор состояния** <br/> |**Структура данных** <br/> |
|[Состояние бездействия](idle-state.md) <br/> | *Нет*  <br/> |**LR_SYNC_IDLE** <br/> | *Нет*  <br/> |
|[Состояние синхронизации](synchronize-state.md) <br/> |Папки или элементы  <br/> |**LR_SYNC** <br/> |**[SYNC](sync.md)** <br/> |
|[Состояние иерархии отправки](upload-hierarchy-state.md) <br/> |Folders  <br/> |**LR_SYNC_UPLOAD_HIERARCHY** <br/> |**[UPHIER](uphier.md)** <br/> |
|[Состояние папки отправки](upload-folder-state.md) <br/> |Folder  <br/> |**LR_SYNC_UPLOAD_FOLDER** <br/> |**[UPFLD](upfld.md)** <br/> |
|[Синхронизация состояния содержимого](synchronize-contents-state.md) <br/> |Элементы  <br/> |**LR_SYNC_CONTENTS** <br/> |**[SYNCCONT](synccont.md)** <br/> |
|[Состояние отправки таблицы](upload-table-state.md) <br/> |Элементы  <br/> |**LR_SYNC_UPLOAD_TABLE** <br/> |**[UPTBL](uptbl.md)** <br/> |
|[Состояние отправки сообщения](upload-message-state.md) <br/> |Элемент  <br/> |**LR_SYNC_UPLOAD_MESSAGE** <br/> |**[UPMSG](upmsg.md)** <br/> |
|[Состояние отправки состояния чтения](upload-read-status-state.md) <br/> |Элементы  <br/> |**LR_SYNC_UPLOAD_MESSAGE_READ** <br/> |**[UPREAD](upread.md)** <br/> |
|[Состояние отправки данных об удалении](upload-delete-status-state.md) <br/> |Элементы  <br/> |**LR_SYNC_UPLOAD_MESSAGE_DEL** <br/> |**[UPDEL](updel.md)** <br/> |
|[Состояние скачивания иерархии](download-hierarchy-state.md) <br/> |Folders  <br/> |**LR_SYNC_DOWNLOAD_HIERARCHY** <br/> |**[DNHIER](dnhier.md)** <br/> |
|[Состояние скачивания таблицы](download-table-state.md) <br/> |Элементы  <br/> |**LR_SYNC_DOWNLOAD_TABLE** <br/> |**[DNTBL](dntbl.md)** <br/> |
|[Скачивание состояния загона сообщения](download-message-header-state.md) <br/> |Заголовок сообщения  <br/> |**LR_SYNC_DOWNLOAD_HEADER** <br/> |**[HDRSYNC](hdrsync.md)** <br/> |
   
## <a name="state-transition-diagram"></a>Схема перехода состояния

На следующей схеме показаны переходы состояния, которые происходят при отправке или выполнении полной синхронизации (скачивание с последующим отправкой) папок или содержимого папок (почта, календарь, контакт, заметка, задача или элементы журнала). 
  
@@@@@NEED ВСТАВИТЬ ЗДЕСЬ ОТСУТСТВУЮЩИЕ ОБЪЕКТЫ @@@@@@
  
## <a name="example-uploading-a-folder-hierarchy"></a>Пример. Отправка иерархии папок

 При отправке иерархии папок происходит следующая последовательность действий: 
  
|||||
|:-----|:-----|:-----|:-----|
|**Шаг** <br/> |**Действие** <br/> |**State** <br/> |**Связанная структура данных** <br/> |
|1.  <br/> |Клиент инициирует отправку иерархии с **помощью IOSTX::SyncBeg.**  <br/> |**LR_SYNC_UPLOAD_HIERARCHY** <br/> |**UPHIER** <br/> |
|2.  <br/> |Outlook 2013 или Outlook 2010 заполняет **UPHIER** данными для клиента. Это включает инициализацию параметров [out]:  *iEnt*  имеет 0, а  *cEnt*  — количество папок в иерархии, которые требуется отправить.  <br/> |**LR_SYNC_UPLOAD_HIERARCHY** <br/> |**UPHIER** <br/> |
|3.  <br/> |Клиент загружает фактическую иерархию. Например, если  *cEnt*  имеет 10, для каждой из 10 папок клиент вызывает **IOSTX::SyncBeg,** указав соответствующий идентификатор состояния и структуру данных для отправки папки.  <br/> |**LR_SYNC_UPLOAD_FOLDER** <br/> |**UPFLD** <br/> |
|4.  <br/> |Outlook 2013 или Outlook 2010 заполняет **UPFLD** путем инициализации параметров [out], включая причину отправки папки, указатель на объект папки и ИД записи для папки.  <br/> |**LR_SYNC_UPLOAD_FOLDER** <br/> |**UPFLD** <br/> |
|5.  <br/> |Клиент загружает указанную папку.  <br/> |**LR_SYNC_UPLOAD_FOLDER** <br/> |**UPFLD** <br/> |
|6.  <br/> |Клиент сообщает локальному магазину о завершении отправки папки: после успешного выполнения клиент устанавливает параметр [in]  *ulFlags*  в **UPFLD** с **UPF_OK,** а затем вызывает **IOSTX::SetSyncResult (S_OK)** и **IOSTX::SyncEnd**. При сбое клиент не будет устанавливать  *ulFlags*  с **UPF_OK** флагом. Он вызывает **IOSTX::SetSyncResult,** передавая значение **HRESULT,** и **IOSTX::SyncEnd**.  <br/> |**LR_SYNC_UPLOAD_FOLDER** <br/> |**UPFLD** <br/> |
|7.  <br/> |Если **UPF_OK** настроен, Outlook 2013 или Outlook 2010 очищает внутренний запрос на отправку папки. Затем, независимо от состояния  *ulFlags,*  будет очищена любая внутренняя информация регистрации. Хотя в иерархии для отправки все еще есть папки *(iEnt*  по-прежнему  *меньше, чем cEnt),* клиент и Outlook 2013 или Outlook 2010 повторяют шаги 3–7.  <br/> |**LR_SYNC_UPLOAD_FOLDER** <br/> |**UPFLD** <br/> |
|8.  <br/> |Клиент сообщает локальному хранилище о завершении отправки иерархии: после успешного выполнения клиент устанавливает флаг [in] в **UPHIER** с **помощью UPH_OK,** а затем вызывает **IOSTX::SetSyncResult (S_OK)** и **IOSTX::SyncEnd**. В случае сбоя клиент  не будет устанавливать UPH_OK флага. Он вызывает **IOSTX::SetSyncResult,** передавая значение **HRESULT,** и **IOSTX::SyncEnd**.  <br/> |**LR_SYNC_UPLOAD_HIERARCHY** <br/> |**UPHIER** <br/> |
|9.  <br/> |Если **UPH_OK** настроен, Outlook 2013 или Outlook 2010 очищает внутренний запрос на отправку иерархии. Затем, независимо от состояния  *ulFlags,*  будет очищена любая внутренняя информация регистрации.  <br/> |**LR_SYNC_UPLOAD_HIERARCHY** <br/> |**UPHIER** <br/> |
   
## <a name="see-also"></a>См. также



[Сведения об API репликации](about-the-replication-api.md)
  
[��������� MAPI](mapi-constants.md)
  
[SYNCSTATE](syncstate.md)

