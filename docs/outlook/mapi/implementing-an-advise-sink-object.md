---
title: Реализация объекта Посоветуйте раковину
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 7461c4f6-7030-4ba2-ada4-26ebfbbfa001
description: 'Дата последнего изменения: 9 марта 2015 г.'
ms.openlocfilehash: ecaad65d28f74b843b86ca82dab9a833ade77363
ms.sourcegitcommit: 8657170d071f9bcf680aba50b9c07f2a4fb82283
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "33412109"
---
# <a name="implementing-an-advise-sink-object"></a>Реализация объекта Посоветуйте раковину

  
  
**Область применения**: Outlook 2013 | Outlook 2016 
  
Клиент может либо реализовать собственные объекты раковины, либо использовать функцию утилиты [HrAllocAdviseSink.](hrallocadvisesink.md) **HrAllocAdviseSink** создает объект помойки с реализацией **OnNotify,** вызываемой функцией вызова. 
  
Есть преимущества и недостатки использования **HrAllocAdviseSink**. Он может сохранить работу, но не обеспечивает контроль над учетом ссылок на создаваемого объекта раковины. Таким образом, клиенты, которые должны тщательно контролировать выпуск раковины рекомендации или у них есть взаимозависимости между раковиной рекомендации и другим клиентом, должны создать собственную реализацию **IMAPIAdviseSink** и вообще избегать использования **HrAllocAdviseSink.** 
  
Клиент, реализующий собственную раковину консультирования, должен сделать его независимым объектом, не связанным с любыми другими объектами или зависимым от них, чтобы исключить возможные сложности в учете ссылок и выпуске объектов. Однако, если необходимо реализовать раковину рекомендации в составе другого объекта или включить в качестве члена данных обратный указатель на другой объект, рекомендуется сохранить два отдельных отсчета ссылок: один для объекта, на который ссылается раковина рекомендации, и один для раковины рекомендации. 
  
Когда количество ссылок на ссылаемый объект падает до нуля, все его методы могут привести к сбой и его vtable может быть уничтожен, но память для раковины рекомендации должна оставаться нетронутой до тех пор, пока его количество ссылок также не опускается до нуля. Это означает, что метод  выпуска приемника рекомендации должен усугубить количество ссылок и завершить уничтожение объекта, когда этот счет достигнет нуля. Если два отдельных отсчета ссылок не поддерживаются, легко непреднамеренно уничтожить раковину рекомендации в рамках процесса выпуска **обхватываемого** объекта. 
  
Клиенты, использующие **HrAllocAdviseSink** для реализации раковины рекомендации, должны быть одинаково осторожны, чтобы не включать функцию вызова в качестве метода в другом объекте раковины. Для клиентов C++ возникает соблазн сделать это  и передать этот указатель в качестве параметра. Это опасная стратегия, так как клиенты обычно о бесплатном объекте, когда его количество ссылок достигает нуля. Освободив память для объекта-раковины  рекомендации, этот указатель станет недействительным. 
  
В зависимости от типа события и источника консультаций метод **OnNotify** может обрабатывать события различными способами. В следующей таблице предлагаются предложения по обработке некоторых стандартных событий. 
  
|**Тип события**|**Обработка в OnNotify**|
|:-----|:-----|
|Объект перемещен  <br/> |Если исходный родитель перемещенного объекта связан с новым родителем, обновите представление, начиная с папки или контейнера адресной книги с наивысшим уровнем в иерархии. Если два родительских контейнера не связаны между собой, обновите оба представления.  <br/> |
|Новое сообщение  <br/> |Измените пользовательский интерфейс, чтобы сообщить пользователю о поступлении одного или более новых сообщений. Поместите папку получения в текущем представлении.  <br/> |
|Error  <br/> |Для всех объектов, за исключением сеанса, при необходимости войдите в журнал ошибки и верни. Для объекта сеанса по возможности отключите вход.  <br/> |
|Поиск завершен  <br/> |Обработка не требуется.  <br/> |
   
> [!NOTE]
> Обработчики уведомлений должны быть повторно. 
  

