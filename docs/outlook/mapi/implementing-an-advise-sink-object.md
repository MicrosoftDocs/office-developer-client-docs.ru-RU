---
title: Реализация объекта приемника уведомлений
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 7461c4f6-7030-4ba2-ada4-26ebfbbfa001
description: 'Дата последнего изменения: 9 марта 2015 г.'
ms.openlocfilehash: ecaad65d28f74b843b86ca82dab9a833ade77363
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32351102"
---
# <a name="implementing-an-advise-sink-object"></a>Реализация объекта приемника уведомлений

  
  
**Область применения**: Outlook 2013 | Outlook 2016 
  
Клиент может либо реализовать собственные объекты приемника уведомлений, либо использовать служебную функцию [храллокадвисесинк](hrallocadvisesink.md). **Храллокадвисесинк** создает объект приемника уведомлений с реализациЕй **OnNotify** , которая вызывает функцию обратного вызова. 
  
Использование **храллокадвисесинк**имеет преимущества и недостатки. Он может сохранить работу, но не позволяет контролировать подсчет ссылок на созданный им объект приемника уведомлений. Таким образом, клиенты, которым необходимо тщательно контролировать освобождение приемника уведомлений или которые взаимозависимости между ним, и другой клиентский объект должен создать собственную реализацию **имапиадвисесинк** и не использовать ** Храллокадвисесинк** вообще. 
  
Клиент, реализующий собственный приемник уведомлений, должен сделать этот объект независимым, не связанным с другими объектами, чтобы избежать потенциальных осложнений в подсчете ссылок и выпуске объектов. Тем не менее, если вы должны реализовать свой приемник уведомлений в рамках другого объекта или включить указатель обратного использования в другой объект в качестве элемента данных, рекомендуется поддерживать два отдельных счетчика ссылок: один для объекта, на который ссылается приемник уведомлений, а другой — для приемник уведомлений. 
  
Если количество ссылок объекта, на который указывает ссылка, становится равным нулю, все его методы могут закончиться с ошибками, а память для приемника уведомлений должна остаться без изменений до тех пор, пока значение счетчика ссылок также не станет равно нулю. Это означает, что метод **освобождения** приемника уведомлений должен уменьшить значение счетчика ссылок и закончить удаление объекта при достижении этим значением этого счетчика нуля. Если два отдельных счетчика ссылок не поддерживаются, можно было бы легко уничтожить приемник уведомлений в рамках процесса **освобождения** объекта. 
  
Клиенты, использующие **храллокадвисесинк** для реализации приемника уведомлений, должны иметь одинаковую осторожность, чтобы не включать функцию обратного вызова в другой объект приемника уведомлений. Для клиентов C++ это делается и передайте этот указатель в качестве параметра. __ Это небезопасная стратегия, так как клиенты обычно освобождают объект, когда его число ссылок достигает нуля. Освобождение памяти для объекта приемника уведомлений приведет к неправильному __ отображению указателя. 
  
В зависимости от типа события и источника уведомления метод onNotify может обрабатывать **** события различными способами. В следующей таблице представлены рекомендации по обработке некоторых стандартных событий. 
  
|**Тип события**|**Обработка в onNotify**|
|:-----|:-----|
|Объект перемещен  <br/> |Если исходный родительский элемент перемещенного объекта связан с новым родительским элементом, обновите представление, начиная с папки или контейнера адресной книги, наивысшего в иерархии. Если два родительских контейнера не связаны, обновите оба их представления.  <br/> |
|Новое сообщение  <br/> |Изменение пользовательского интерфейса для информирования пользователя о поступлении одного или нескольких новых сообщений. Помещение папки "получение" в текущее представление.  <br/> |
|Error  <br/> |При необходимости заносить в журнал все объекты, кроме сеанса, и возвращать сообщение об ошибке. Для объекта Session выйдите из системы, если это возможно.  <br/> |
|Поиск завершен  <br/> |Обработка не требуется.  <br/> |
   
> [!NOTE]
> Обработчики уведомлений должны быть повторными. 
  

