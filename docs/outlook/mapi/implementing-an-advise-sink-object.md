---
title: Реализация объекта приемника уведомлений
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 7461c4f6-7030-4ba2-ada4-26ebfbbfa001
description: 'Дата последнего изменения: 9 марта 2015 г.'
ms.openlocfilehash: b457fce208923ce01686812f20031e365842ccd8
ms.sourcegitcommit: 0cf39e5382b8c6f236c8a63c6036849ed3527ded
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/23/2018
ms.locfileid: "22593678"
---
# <a name="implementing-an-advise-sink-object"></a>Реализация объекта приемника уведомлений

  
  
**Применимо к**: Outlook 2013 | Outlook 2016 
  
Клиент можно реализовать собственных объектов приемника уведомлений или использовать вспомогательную функцию, [HrAllocAdviseSink](hrallocadvisesink.md). **HrAllocAdviseSink** создает объект приемника уведомлений с реализацией **OnNotify** , которая вызывает функцию обратного вызова. 
  
Есть свои преимущества и недостатки использования **HrAllocAdviseSink**. Он существенно упростить процесс, но предоставляет не контролирует подсчета объект приемника уведомлений, он создает ссылок. Таким образом должны создавать свои собственные реализации **IMAPIAdviseSink** и избегайте использования **клиентов, который необходимо тщательно контролировать их приемник уведомлений выпуска или, у которых взаимозависимость их приемник уведомлений и другого клиентского объекта HrAllocAdviseSink** полностью. 
  
Реализация собственного приемник уведомлений клиента должна обеспечивать независимый объект не связанные с и не зависят от других объектов, чтобы исключить определенные сложности в выпуске инвентаризации и объект ссылки. Тем не менее, если необходимо реализовать вашей приемник уведомлений в рамках другой объект или включить обратная указатель на другой объект в качестве члена данных, рекомендуется поддерживать счетчики два отдельных ссылок: один для объект ссылается на приемник уведомлений, другая — для уведомить приемника. 
  
Когда счетчик ссылок объекта ссылки становится равным нулю, все его методы может не работать и его vtable, можно удалять, но памяти для приемник уведомлений должны оставаться целыми до того времени, после его счетчика также становится равным нулю. Это означает, что приемник уведомлений **выпуске** метод должен уменьшить его счетчика и завершить удаление объекта при этого счетчика будет равно нулю. Если не сохраняются счетчики два отдельных ссылок, будет случайно удалить приемник уведомлений в рамках процесса **выпуска** охватывающий объекта. 
  
Для клиентов, использующих **HrAllocAdviseSink** для реализации приемника уведомления должно быть одинаково избегать включить их функции обратного вызова метода в другой объект приемник уведомлений. Для клиентов C++ заманчиво этого и передать указатель _this_ в качестве параметра. Это опасные стратегия, так как клиенты обычно освобождает объект, когда счетчик ссылок на него будет равно нулю. Освобождение памяти для объекта приемник уведомлений будет отображен недопустимый указатель _this_ . 
  
В зависимости от типа события и источник уведомлений метод **OnNotify** можно обрабатывать события разными способами. В следующей таблице приведено предложений в обработка некоторых стандартных событий. 
  
|**Тип события**|**Обработка в OnNotify**|
|:-----|:-----|
|Объект перемещен  <br/> |Если исходной родительской перемещенный объект относится к новым родительским, обновите начала представление с папки или наивысший в иерархии контейнер адресной книги. Если двух родительских контейнеров не связанных, обновите оба их представления.  <br/> |
|Новое сообщение  <br/> |Изменение пользовательского интерфейса для оповещения пользователя о поступления один или несколько новых сообщений. Поместите папку получения в текущем представлении.  <br/> |
|Error  <br/> |Для всех объектов за исключением сеанса входа ошибки при необходимости и возврата. Для объекта сеанса выйдите из системы, если это возможно.  <br/> |
|Поиск завершен  <br/> |Обработка не требуется.  <br/> |
   
> [!NOTE]
> Обработчики уведомлений должно быть повторные. 
  

