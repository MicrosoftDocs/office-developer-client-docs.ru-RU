---
title: Поддержка уведомлений о событиях
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: a1e3e49c-8d1d-4f7e-ba5a-be441f0f10ae
description: 'Дата последнего изменения: 23 июля 2011 г.'
ms.openlocfilehash: 83c102c25b17b6769c0c676bbadd874224f75cf6
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32327428"
---
# <a name="supporting-event-notification"></a>Поддержка уведомлений о событиях

  
  
**Область применения**: Outlook 2013 | Outlook 2016 
  
Так как поддержка уведомлений о событиях может быть сложной, MAPI предоставляет три метода объекта поддержки, которые реализуют самые сложные части процесса. Эти методы работают как единое целое, а поставщик должен использовать все три или ни один из них.
  
Методы поддержки MAPI используют клавиши уведомления для управления подключениями между приемниками уведомлений и объектами, которые создают уведомления. Ключ уведомления — это структура [нотифкэй](notifkey.md) , содержащая двоичные данные, определяющие объект в разных процессах. Ключ уведомления обычно копируется из долгосрочного идентификатора записи исходного объекта Advise. Если клиент предоставил идентификатор записи в вызове метода **advise**, его можно использовать для ключа уведомления. Если параметр _лпентрид_ to **advise** имеет значение null, используйте идентификатор элемента самого внешнего возможного объекта контейнера, например, хранилища сообщений. 
  
Чтобы использовать методы поддержки, вызовите [имаписуппорт:: Subscribe](imapisupport-subscribe.md) всякий раз, когда клиент вызывает метод **advise** для регистрации в уведомлении. Выделение структуры [нотифкэй](notifkey.md) и создание уникального ключа уведомления для исходного объекта рекомендаций. Например, поставщик хранилища сообщений, предлагающий уведомить клиента о том, что сообщение получено в определенную папку, создает ключ уведомления для этой папки. Передайте указатель на структуру **нотифкэй** в вызове, чтобы **** подписаться вместе с указателем на приемник уведомлений клиента. **Subscribe** вызывает метод [IUnknown:: AddRef](https://msdn.microsoft.com/library/b4316efd-73d4-4995-b898-8025a316ba63%28Office.15%29.aspx) приемника уведомлений, чтобы увеличить значение счетчика ссылок, и MAPI сохраняет указатель до отмены регистрации. 
  
Вы можете передать флаг НОТИФИ_СИНК, чтобы **** подписаться на запрос, который **уведомляет** вести себя синхронно и не возвращался до тех пор, пока не будет выполнен вызов методов [имапиадвисесинк:: OnNotify](imapiadvisesink-onnotify.md) для зарегистрированных приемников уведомлений. Установите этот флаг только для внутреннего использования. Не задавайте его при ответе на вызов метода Client **advise** . Уведомление о событиях между клиентами и поставщиками всегда является асинхронным. То есть MAPI гарантирует, что вызов, в течение которого событие произойдет, вернется клиенту перед выполнением любого из **** вызовов OnNotify. 
  
Если вы установили флаг НОТИФИ_СИНК, не вносите никаких изменений в объекты приемника уведомлений и не передавайте для **подписки**приемник уведомлений о оболочке, созданный [хрсиссреададвисесинк](hrthisthreadadvisesink.md) . **Хрсиссреададвисесинк** создает потокобезопасную версию приемника уведомлений, которая будет использоваться только с асинхронным уведомлением. 
  
Если приемник уведомлений, зарегистрированный для синхронного уведомления **** , возвращается из OnNotify с установленным флагом Каллбакк_дисконтинуе, [Имаписуппорт:: notify](imapisupport-notify.md) устанавливает флаг нотифи_канцелед и возвращает результат без совершения вызовов OnNotify. **** 
  
После **** того как подписаться, вы больше не должны удерживать свой экземпляр приемника уведомлений клиента. ВыЗовите его метод [IUnknown:: Release](https://msdn.microsoft.com/library/4b494c6f-f0ee-4c35-ae45-ed956f40dc7a%28Office.15%29.aspx) , чтобы освободить его. **Subscribe** возвращает ненулевой номер подключения, который необходимо возвратить клиенту. Номер подключения представляет ссылку между источником уведомлений и приемником уведомлений. Он остается действительным до тех пор, пока клиент не **** выполнит вызов метода unadvise. 
  
Когда клиент готов к отмене регистрации, он вызывает метод **unadvise** . Передайте номер подключения из вызова **unadvise** в [имаписуппорт:: unadvise](imapisupport-unsubscribe.md). **Unsubscribe** вызывает метод **IUnknown:: Release** приемника уведомлений. Как и в случае **** с предложением **advise** и unadvise, необходимо связать вызовы подписываться и **** unadvise. **** Необходимо выполнить один вызов, чтобы **** отменить подписку для каждого вызова, выполняемого для **подписки**. Тем не менее, не нужно вызывать **Subscribe** каждый раз, когда вызывается метод **advise** . И наоборот, вы можете позвонить по нему, чтобы настроить внутренние уведомления. 
  
При возникновении события выделяйте одну или несколько структур [уведомлений](notification.md) типа, подходящих для события, и вызовите [Имаписуппорт:: notify](imapisupport-notify.md). **Notify** создает уведомление для каждого зарегистрированного приемника уведомлений. Необходимо задать нулевое значение для всех неиспользуемых элементов структуры [уведомлений](notification.md) . Этот метод инициализации структуры **уведомлений** помогает клиентам создавать небольшие, быстрые и менее подверженные ошибкам реализации OnNotify **** . 
  
Обратите внимание, что для каждого события требуется отдельная структура **уведомления** , даже для нескольких событий одного типа. Например, если три клиента зарегистрированы для уведомления таблицы в определенной таблице и в таблицу добавлены пять строк, необходимо создать пять структур **обжект_нотификатион** для вызова **Notify** . Пакетное уведомление, например, дает лучшую производительность, чем вызов **Notify** пять раз. Для каждого вызова **уведомления** MAPI вызывает метод [имапиадвисесинк:: OnNotify](imapiadvisesink-onnotify.md) каждого зарегистрированного приемника уведомлений. Если зарегистрированных приемников уведомлений нет, MAPI игнорирует вызов. 
  
Поставщики услуг, которые отправляют пакетные уведомления, должны упорядочивать их, чтобы их можно было интерпретировать от первого уведомления до последней. Этот порядок особенно необходим, если пакет уведомлений содержит ряд событий, например ТАБЛЕ_РОВ_АДДЕД с одним событием, которое ссылается на предыдущую строку, добавленную в другом событии в том же пакете.
  
## <a name="see-also"></a>См. также



[Поставщики службы MAPI](mapi-service-providers.md)

