---
title: имапипропсавечанжес
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
ms.topic: reference
ms.prod: office-online-server
localization_priority: Normal
api_name:
- IMAPIProp.SaveChanges
api_type:
- COM
ms.assetid: 864dbc3e-2039-435a-a279-385d79d1d13f
description: 'Дата последнего изменения: 23 июля 2011 г.'
ms.openlocfilehash: 2c8244180a5cafedc887fa72f36f233fb5084f79
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32316634"
---
# <a name="imapipropsavechanges"></a>IMAPIProp::SaveChanges

  
  
**Относится к**: Outlook 2013 | Outlook 2016 
  
Делает неизменными все изменения, внесенные в объект с момента последнего выполнения операции сохранения. 
  
```cpp
HRESULT SaveChanges(
  ULONG ulFlags
);
```

## <a name="parameters"></a>Параметры

 _ulFlags_
  
> возврата Битовая маска флагов, определяющих, что происходит с объектом при вызове метода **IMAPIProp:: SaveChanges** . Можно задать следующие флаги: 
    
NON_EMS_XP_SAVE
  
> Указывает, что сообщение не было доставлено с сервера Microsoft Exchange. Этот флаг следует использовать в сочетании с методом [IMAPIFolder:: CreateMessage](imapifolder-createmessage.md) и флагом ITEMPROC_FORCE, чтобы указать, что в PST-хранилище, в котором сообщение может быть доступно для обработки правил, перед тем как хранилище файлов личных папок уведомит любой прослушивающий клиент о том, что сообщение получено. Эта обработка правил применяется только к новым сообщениям, созданным с помощью [IMAPIFolder:: CreateMessage](imapifolder-createmessage.md) на сервере, который не является сервером Exchange Server, в этом случае сервер Exchange уже обработал правила для этого сообщения. 
    
FORCE_SAVE 
  
> Изменения должны быть записаны в объект, переопределяя все предыдущие изменения, внесенные в объект, и объект должен быть закрыт. Для успешного выполнения операции должно быть задано разрешение на чтение и запись. Флаг FORCE_SAVE используется после предыдущего вызова метода **SaveChanges** , возвращаемого MAPI_E_OBJECT_CHANGED. 
    
KEEP_OPEN_READONLY 
  
> Изменения должны быть зафиксированы и объект должен оставаться открытым для чтения. Дополнительные изменения не выполняются. 
    
KEEP_OPEN_READWRITE 
  
> Изменения должны быть зафиксированы, а объект должен оставаться открытым для разрешения на чтение и запись. Этот флаг обычно устанавливается при первом открытии объекта для разрешения на чтение и запись. Дальнейшие изменения объекта разрешены. 
    
MAPI_DEFERRED_ERRORS 
  
> Позволяет успешно возвращать **SaveChanges** , возможно, до того, как изменения будут полностью зафиксированы. 
    
SPAMFILTER_ONSAVE
  
> Включает фильтрацию нежелательной почты для сохраняемого сообщения. Поддержка фильтрации нежелательной почты доступна только в том случае, если тип адреса электронной почты отправителя соответствует протоколу SMTP, а сообщение сохранено в хранилище для файлов личных папок (PST).
    
## <a name="return-value"></a>Возвращаемое значение

S_OK 
  
> Фиксация изменений выполнена успешно.
    
MAPI_E_NO_ACCESS 
  
> **SaveChanges** не может оставить объект открытым для доступа только для чтения, если KEEP_OPEN_READONLY задано, или разрешение на чтение и запись, если задано значение KEEP_OPEN_READWRITE. Изменения не фиксируются. 
    
MAPI_E_OBJECT_CHANGED 
  
> Объект изменился с момента его открытия.
    
MAPI_E_OBJECT_DELETED 
  
> Объект был удален после его открытия.
    
## <a name="remarks"></a>Примечания

Метод **IMAPIProp:: SaveChanges** вносит изменения свойств в постоянные для объектов, поддерживающих модель обработки транзакций, таких как сообщения, вложения, контейнеры адресной книги и пользовательские объекты обмена сообщениями. Объекты, не поддерживающие транзакции, такие как папки, хранилища сообщений и разделы профилей, немедленно выполняют изменения. Вызов **SaveChanges** не требуется. 
  
Так как поставщики услуг не требуют создания идентификатора записи для своих объектов до тех пор, пока все свойства не будут сохранены, свойство объекта **PR_ENTRYID** ([PidTagEntryId](pidtagentryid-canonical-property.md)) может быть недоступно до тех пор, пока не будет вызван метод **SaveChanges** . Некоторые поставщики ожидают, пока не будет установлен флаг KEEP_OPEN_READONLY вызова **SaveChanges** . KEEP_OPEN_READONLY указывает, что изменения, сохраняемые в текущем вызове, будут последними изменениями, которые будут выполнены для объекта. 
  
Некоторые реализации хранилищ сообщений не показывают новые сообщения в папке до тех пор, пока клиент не сохранит изменения в сообщениях с помощью **SaveChanges** и освободит объекты сообщения с помощью метода [IUnknown:: Release](https://msdn.microsoft.com/library/ms682317%28v=VS.85%29.aspx) . Кроме того, некоторые реализации объектов не могут создать свойство **PR_ENTRYID** для вновь созданного объекта, пока не будет вызван метод **SaveChanges** , а некоторые из них могут сделать это только после вызова **SaveChanges** с помощью KEEP_OPEN_READONLY Set в _ulFlags_.
  
## <a name="notes-to-implementers"></a>Примечания для исполнителей

Если вы получили флаг KEEP_OPEN_READONLY, вы можете оставить доступ к объекту как для чтения и записи. Однако поставщик не может оставить объект в состоянии "только для чтения", когда передается флаг KEEP_OPEN_READWRITE.
  
Когда клиент сохраняет несколько вложений в несколько сообщений, он вызывает метод **SaveChanges** для каждого вложения и каждого сообщения. Часто клиенты задают MAPI_DEFERRED_ERRORS для каждого из этих вызовов, кроме последнего. Ошибки можно возвращать при последнем вызове или более ранних вызовах. Вы можете даже проигнорировать флаг. 
  
Если KEEP_OPEN_READWRITE или KEEP_OPEN_READONLY заданы вместе с MAPI_DEFERRED_ERRORS, можно проигнорировать запрос дефермент об ошибке. Если MAPI_DEFERRED_ERRORS не задан в _ulFlags_, то для вызова **SaveChanges** можно возвратить одну из ранее выводимых ошибок. 
  
Предоставляет ли удаленный поставщик транспорта функциональную реализацию этого метода, это необязательно и зависит от других вариантов дизайна в вашей реализации. Если вы реализуете этот метод, сделайте это в соответствии с документацией. Так как объекты Folder и Status не являются транзакционными, по крайней мере, реализация **SaveChanges** удаленным поставщиком транспорта должна возвращать S_OK без фактического выполнения каких-либо действий. 
  
## <a name="notes-to-callers"></a>Примечания для вызывающих методов

Если клиент передает KEEP_OPEN_READONLY, вызывает метод [IMAPIProp:: SetProps](imapiprop-setprops.md) , а затем снова вызывает **SaveChanges** , та же реализация может закончиться с ошибками. 
  
После получения MAPI_E_NO_ACCESS из вызова, в котором вы задаете KEEP_OPEN_READWRITE, у вас остается разрешение на чтение и запись для объекта. Вы можете вызвать метод **SaveChanges** еще раз, передав флаг KEEP_OPEN_READONLY или без флагов с KEEP_OPEN_SUFFIX. 
  
Поддерживает ли поставщик флаг KEEP_OPEN_READWRITE зависит от реализации поставщика. 
  
Чтобы указать, что единственный вызов, который следует выполнить для объекта, после **SaveChanges** — **IUnknown:: Release**, set без флагов для параметра _ulFlags_ . Сообщение об ошибке **SaveChanges** указывает на то, что не удалось сделать ожидающие изменения постоянными. Различные поставщики обрабатывают отсутствие флагов для вызова **SaveChanges** по-разному. Некоторые поставщики считают это состояние тем же, что и KEEP_OPEN_READONLY; другие поставщики интерпретируются так же, как KEEP_OPEN_READWRITE. Другие поставщики отключают объект, когда они не получают флаги для вызова **SaveChanges** . 
  
Некоторые свойства, обычно вычисляемые, не могут быть обработаны до тех пор, пока не будет вызван метод **SaveChanges** , а в некоторых случаях **он освободится**.
  
При выполнении массовых изменений, таких как сохранение вложений в нескольких сообщениях, отложить обработку ошибок путем установки флага MAPI_DEFERRED_ERRORS в _ulFlags_. Если вы сохраняете несколько вложений в несколько сообщений, сделайте один вызов **SaveChanges** на каждое вложение и один вызов **SaveChanges** для каждого сообщения. Установите флаг MAPI_DEFERRED_ERRORS для каждого вызова вложения и для всех сообщений, кроме последнего. 
  
Если **SaveChanges** возвращает MAPI_E_OBJECT_CHANGED, проверьте, был ли изменен исходный объект. Если да, предупредите пользователя, кто может запрашивать, что изменения перезапишут предыдущие изменения, или сохранить объект в другом месте. Если исходный объект был удален, предупредите пользователя, чтобы предоставить ему возможность сохранить объект в другом расположении. 
  
Вы не можете вызвать **SaveChanges** с флагом FORCE_SAVE на открытом объекте, который был удален. 
  
Если **SaveChanges** возвращает ошибку, объект, чьи изменения были сохранены, остается открытым, независимо от флагов, заданных в параметре _ulFlags_ . 
  
> [!IMPORTANT]
> NON_EMS_XP_SAVE и SPAMFILTER_ONSAVE _ulFlags_ могут быть не определены в файле заголовков, доступных для загрузки, в этом случае можно добавить его в код, используя следующие значения: >`#define SPAMFILTER_ONSAVE ((ULONG) 0x00000080)`>  `#define NON_EMS_XP_SAVE ((ULONG) 0x00001000)`
  
Дополнительную информацию можно узнать в статье [Сохранение свойств MAPI](saving-mapi-properties.md).
  
## <a name="see-also"></a>См. также



[IMAPIProp::SetProps](imapiprop-setprops.md)
  
[Каноническое свойство PidTagEntryId](pidtagentryid-canonical-property.md)
  
[IMAPIProp : IUnknown](imapipropiunknown.md)


[Сохранение свойств MAPI](saving-mapi-properties.md)

