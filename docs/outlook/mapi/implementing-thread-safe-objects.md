---
title: Реализация потокобезопасных объектов
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 3c911694-b953-4d35-9a3a-22c17cfd79bc
description: 'Дата последнего изменения: 23 июля 2011 г.'
ms.openlocfilehash: 8c8c89f3626d54f04896ad54de5d7e480dd9b568
ms.sourcegitcommit: 9d60cd82b5413446e5bc8ace2cd689f683fb41a7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/11/2018
ms.locfileid: "19809345"
---
# <a name="implementing-thread-safe-objects"></a><span data-ttu-id="50502-103">Реализация потокобезопасных объектов</span><span class="sxs-lookup"><span data-stu-id="50502-103">Implementing Thread-Safe Objects</span></span>

  
  
<span data-ttu-id="50502-104">**Относится к**: Outlook</span><span class="sxs-lookup"><span data-stu-id="50502-104">**Applies to**: Outlook</span></span> 
  
<span data-ttu-id="50502-105">С объектами, возвращенные вызовы методов интерфейса напрямую отвечает поставщика для обеспечения безопасности потока.</span><span class="sxs-lookup"><span data-stu-id="50502-105">With objects that are returned from interface method calls directly, it is the provider's responsibility to ensure thread-safety.</span></span> <span data-ttu-id="50502-106">С помощью объектов обратного вызова отвечает клиентское приложение.</span><span class="sxs-lookup"><span data-stu-id="50502-106">With callback objects, it is the client application's responsibility.</span></span>
  
<span data-ttu-id="50502-107">Клиент можно реализовать обратного вызова уведомления потоками путем вызова MAPI служебной программы [HrThisThreadAdviseSink](hrthisthreadadvisesink.md).</span><span class="sxs-lookup"><span data-stu-id="50502-107">A client can implement a thread-safe notification callback by calling the MAPI utility [HrThisThreadAdviseSink](hrthisthreadadvisesink.md).</span></span> <span data-ttu-id="50502-108">**HrThisThreadAdviseSink** преобразует приемник не являющихся потокобезопасными уведомлений в один являющихся потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="50502-108">**HrThisThreadAdviseSink** transforms a non-thread-safe advise sink into a thread-safe one.</span></span> <span data-ttu-id="50502-109">Для обратных вызовов хода выполнения нет такого служебной программы.</span><span class="sxs-lookup"><span data-stu-id="50502-109">For progress callbacks, there is no such utility.</span></span> <span data-ttu-id="50502-110">Клиент можно использовать объект хода выполнения потоками MAPI или создать новое вручную.</span><span class="sxs-lookup"><span data-stu-id="50502-110">A client can choose to use the MAPI thread-safe progress object or create one manually.</span></span> 
  
<span data-ttu-id="50502-111">Объект потоками может или не также принять во внимание потока.</span><span class="sxs-lookup"><span data-stu-id="50502-111">A thread-safe object might or might not also be thread-aware.</span></span> <span data-ttu-id="50502-112">Поток объект поддерживает отдельные контекст для каждого потока, который он используется.</span><span class="sxs-lookup"><span data-stu-id="50502-112">A thread-aware object maintains a separate context for every thread that is using it.</span></span> <span data-ttu-id="50502-113">Поставщиков услуг не требуются для поддержки поддержка потоков в их объектами потоками несмотря на то, что поток-сведения о поддержке может быть полезен в некоторых случаях.</span><span class="sxs-lookup"><span data-stu-id="50502-113">Service providers are not required to support thread-awareness in their thread-safe objects, although supporting thread-awareness can be useful in some situations.</span></span> <span data-ttu-id="50502-114">Две таблицы MAPI всегда отправлять собственные контекста по определению.</span><span class="sxs-lookup"><span data-stu-id="50502-114">Two MAPI tables always provide their own context by definition.</span></span> <span data-ttu-id="50502-115">Одной таблицы, используемые на различных потоках не поддерживает и не следует предоставлять уникальный контекста.</span><span class="sxs-lookup"><span data-stu-id="50502-115">One table used on different threads does not and should not provide unique context.</span></span>
  
<span data-ttu-id="50502-116">Клиент можно выбрать получение уведомлений в том же потоке, который использовался для **MAPIInitialize** позвонить, в том же потоке, который использовался для вызова **уведомлений** или в отдельном потоке, принадлежащие MAPI.</span><span class="sxs-lookup"><span data-stu-id="50502-116">A client can choose between receiving notifications on the same thread that was used for the **MAPIInitialize** call, on the same thread that was used for the **Advise** call, or on a separate thread owned by MAPI.</span></span> <span data-ttu-id="50502-117">Чтобы убедиться, что уведомления о получении на тот же поток, который использовался для вызова **MAPIInitialize**, клиент вызывает [MAPIInitialize](mapiinitialize.md) и передает ноль в член **ulFlags** структуры [MAPIINIT_0](mapiinit_0.md) .</span><span class="sxs-lookup"><span data-stu-id="50502-117">To ensure that notifications arrive on the same thread that was used to call **MAPIInitialize**, a client calls [MAPIInitialize](mapiinitialize.md) and passes zero in the **ulFlags** member of the [MAPIINIT_0](mapiinit_0.md) structure.</span></span> <span data-ttu-id="50502-118">Во время цикла основного сообщения нажмите доставить уведомления.</span><span class="sxs-lookup"><span data-stu-id="50502-118">Notifications are then delivered during the main message loop.</span></span> 
  
<span data-ttu-id="50502-119">Чтобы получать уведомления о потоке владении MAPI, клиент вызывает **MAPIInitialize** с членом **ulFlags** структуры **MAPIINIT_0** , задайте значение MAPI_MULTITHREAD_NOTIFICATIONS.</span><span class="sxs-lookup"><span data-stu-id="50502-119">To receive notifications on the MAPI-owned thread, a client calls **MAPIInitialize** with the **ulFlags** member of the **MAPIINIT_0** structure set to MAPI_MULTITHREAD_NOTIFICATIONS.</span></span> <span data-ttu-id="50502-120">Выполнен вызов **уведомлений** с помощью клиента уведомить объектом приемника, а не оболочку версии.</span><span class="sxs-lookup"><span data-stu-id="50502-120">The **Advise** call is made with the client's advise sink object rather than a wrapped version.</span></span> 
  
<span data-ttu-id="50502-121">Чтобы убедиться, что уведомления о получении на тот же поток, который использовался для вызова **уведомлений**, клиент вызывает [HrThisThreadAdviseSink](hrthisthreadadvisesink.md) и этапы, которые только что созданный оболочку уведомить приемник для **уведомлений** , а не на исходный приемник уведомлений.</span><span class="sxs-lookup"><span data-stu-id="50502-121">To ensure that notifications arrive on the same thread that was used to call **Advise**, a client calls [HrThisThreadAdviseSink](hrthisthreadadvisesink.md) and passes the newly created wrapped advise sink to **Advise** rather than the original advise sink.</span></span> <span data-ttu-id="50502-122">**MAPIInitialize** может быть вызван с помощью любого из значение флага.</span><span class="sxs-lookup"><span data-stu-id="50502-122">**MAPIInitialize** can be called with either flag value.</span></span> 
  

