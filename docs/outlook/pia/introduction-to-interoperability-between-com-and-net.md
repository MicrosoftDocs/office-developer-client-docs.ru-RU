---
title: Введение во взаимодействие между COM и .NET
TOCTitle: Introduction to interoperability between COM and .NET
ms:assetid: 6b2d099a-ec6f-4099-aaf6-e61003fe5a32
ms:mtpsurl: https://msdn.microsoft.com/library/office/bb610378(v=office.15)
ms:contentKeyID: 55119776
ms.date: 07/24/2014
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 3b19135900974c3fa379aa9f4acb18ee98a2f8c5
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "32360613"
---
# <a name="introduction-to-interoperability-between-com-and-net"></a><span data-ttu-id="c287a-102">Введение во взаимодействие между COM и .NET</span><span class="sxs-lookup"><span data-stu-id="c287a-102">Introduction to interoperability between COM and .NET</span></span>

<span data-ttu-id="c287a-103">При разработке в COM и .NET используются сильно отличающиеся системы типов и механизмы управления временем жизни объектов, созданием и наследованием интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="c287a-103">The Component Object Model (COM) and .NET development have vastly different type systems and mechanisms for object lifetime management, interface creation, and interface inheritance.</span></span> 

<span data-ttu-id="c287a-104">Например, тип **Variant** в COM соответствует типу данных **System.Object** в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c287a-104">For example, a **Variant** type in COM is a **System.Object** data type in the .NET Framework.</span></span> <span data-ttu-id="c287a-105">Чтобы создать объект, клиент COM вызывает функцию [CoCreateInstance](https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), а управляемый клиент может использовать такие ключевые слова, как new или New, встроенные в управляемый язык программирования.</span><span class="sxs-lookup"><span data-stu-id="c287a-105">To create an object, a COM client calls [CoCreateInstance](https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), whereas a managed client can use keywords such as new or New that are built in to a managed programming language.</span></span> 

<span data-ttu-id="c287a-106">В то время как COM не поддерживает классическое наследование, и клиент COM для освобождения компонентного класса управляет внутренним счетчиком ссылок, предоставленным в интерфейсе [IUnknown](https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown), управляемый клиент использует для освобождения объекта сборщик мусора среды CLR, предоставленный платформой .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c287a-106">While COM does not support classical inheritance and a COM client manages an internal reference count provided by [IUnknown](https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown) to free a coclass, a managed client relies on the common language runtime (CLR) garbage collector provided by the .NET Framework to free an object.</span></span> 

<span data-ttu-id="c287a-107">При таких различиях между COM и .NET разработка управляемого клиента для объектной модели COM требует использования механизма, разрешающего эти различия.</span><span class="sxs-lookup"><span data-stu-id="c287a-107">Given such differences between COM and .NET development, developing a managed client on a COM object model requires a mechanism that resolves these differences.</span></span> <span data-ttu-id="c287a-108">Оболочка времени выполнения (Runtime Callable Wrapper, RCW)  это механизм, обеспечивающий прозрачное взаимодействие между моделью и COM и управляемой моделью программирования.</span><span class="sxs-lookup"><span data-stu-id="c287a-108">The Runtime Callable Wrapper (RCW) is a mechanism that promotes transparent communication between COM and the managed programming model.</span></span>

<span data-ttu-id="c287a-109">В этой статье приведено высокоуровневое описание того, как RCW облегчает взаимодействие между COM и управляемой моделью программирования.</span><span class="sxs-lookup"><span data-stu-id="c287a-109">This topic gives a high-level description of how the RCW facilitates communication between COM and the managed programming model.</span></span> <span data-ttu-id="c287a-110">Обратите внимание, что хотя в этом разделе для иллюстрирования механизма работы этой оболочки используется Visual Studio, разрабатывать управляемый клиент, используя сборку взаимодействия, можно и не в Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="c287a-110">Note that even though this topic uses Visual Studio to illustrate the RCW mechanism, you can use an interop assembly outside of Visual Studio to develop a managed client.</span></span>

## <a name="facilitating-interoperability-the-interop-assembly-and-rcw"></a><span data-ttu-id="c287a-111">Упрощение взаимодействия: сборка взаимодействия и вызываемая оболочка времени выполнения</span><span class="sxs-lookup"><span data-stu-id="c287a-111">Facilitating interoperability: the Interop Assembly and RCW</span></span>

### <a name="compile-time"></a><span data-ttu-id="c287a-112">Время компиляции</span><span class="sxs-lookup"><span data-stu-id="c287a-112">Compile time</span></span>

<span data-ttu-id="c287a-113">Сборка взаимодействия определяет управляемые интерфейсы, сопоставляемые с библиотекой типов на основе COM, с которыми может взаимодействовать управляемый клиент.</span><span class="sxs-lookup"><span data-stu-id="c287a-113">An interop assembly defines managed interfaces that map to a COM-based type library and that a managed client can interact with.</span></span> <span data-ttu-id="c287a-114">Чтобы использовать сборку взаимодействия в Visual Studio, сначала добавьте ссылку на соответствующий компонент COM.</span><span class="sxs-lookup"><span data-stu-id="c287a-114">To use an interop assembly in Visual Studio, first add a reference to the corresponding COM component.</span></span> <span data-ttu-id="c287a-115">Visual Studio автоматически создает локальную копию сборки взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="c287a-115">Visual Studio will automatically generate a local copy of the interop assembly.</span></span> <span data-ttu-id="c287a-116">Эта сборка взаимодействия содержит одно пространство имен, в котором у каждого COM-объекта в объектной модели COM есть управляемый интерфейс-эквивалент.</span><span class="sxs-lookup"><span data-stu-id="c287a-116">The interop assembly contains one namespace, under which there is a managed equivalent interface of each COM object in the COM object model.</span></span> 

<span data-ttu-id="c287a-117">На рисунке 1 показан управляемый клиент, которому нужно использовать библиотеку типов COM, определяющую компонентный класс X. Управляемый клиент вызывает класс X, который является управляемым интерфейсом-эквивалентом для компонентного класса X, в соответствии с определением в сборке взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="c287a-117">Figure 1 illustrates a managed client that wants to use a COM type library that defines coclass X. The managed client calls class X, which is the managed equivalent interface for coclass X, as defined in the interop assembly.</span></span> <span data-ttu-id="c287a-118">Во время компиляции управляемый проект компилируется со сведениями о классе X из сборки взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="c287a-118">At compile time, the managed project is compiled with information about class X from the interop assembly.</span></span>

<span data-ttu-id="c287a-119">**Рисунок 1. Управляемое приложение, скомпилированное со сборкой взаимодействия, взаимодействующей с неуправляемой библиотекой типов**</span><span class="sxs-lookup"><span data-stu-id="c287a-119">**Figure 1. A managed application compiled with an interop assembly that interoperates with an unmanaged type library**</span></span>

![Управляемое приложение, скомпилированное со сборкой взаимодействия, взаимодействующей с неуправляемой библиотекой типов](media/pia-unmanaged-type-library.gif)
  
<span data-ttu-id="c287a-p106">В общем случае, как только задается ссылка на библиотеку типов, Visual Studio создает копию сборки взаимодействия для этой библиотеки типов. Может существовать любое количество сборок взаимодействия, описывающих один и тот же тип COM. Но у библиотеки типов может быть только одна основная сборка взаимодействия (PIA), которая является сборкой взаимодействия, опубликованной библиотекой типов. В отличие от других сборок взаимодействия PIA не создается при каждом добавлении ссылки на библиотеку типов в Visual Studio. Вместо этого PIA устанавливается в глобальный кэш сборок на компьютере только один раз. При добавлении ссылки на библиотеку типов в Visual Studio автоматически загружается PIA.</span><span class="sxs-lookup"><span data-stu-id="c287a-p106">In general, as long as you set a reference to a type library, Visual Studio generates a copy of an interop assembly for that type library. Any number of interop assemblies can exist to describe the same COM type. However, a type library can have only one Primary Interop Assembly (PIA), which is the interop assembly published by the type library. Unlike other interop assemblies, the PIA is not generated every time you add a reference in Visual Studio. Instead, you install the PIA to the global assembly cache (GAC) just once on a computer. When you add a reference to the type library, Visual Studio automatically loads the PIA.</span></span>

<span data-ttu-id="c287a-127">Чтобы запрограммировать управляемое решение для Outlook, следует использовать Outlook PIA.</span><span class="sxs-lookup"><span data-stu-id="c287a-127">To program a managed solution for Outlook, you should use the Outlook PIA.</span></span> <span data-ttu-id="c287a-128">Чтобы включить сведения из Outlook PIA в управляемую надстройку, сначала необходимо установить Outlook PIA в глобальный кэш сборок.</span><span class="sxs-lookup"><span data-stu-id="c287a-128">To incorporate information from the Outlook PIA into a managed add-in, first you must install the Outlook PIA in the GAC.</span></span> <span data-ttu-id="c287a-129">При использовании Visual Studio для создания управляемого проекта PIA загружается в Visual Studio после добавления ссылки на библиотеку типов Outlook.</span><span class="sxs-lookup"><span data-stu-id="c287a-129">If you are using Visual Studio to create the managed project, after adding a reference to the Outlook type library, Visual Studio loads the PIA.</span></span> <span data-ttu-id="c287a-130">В обозревателе объектов (в пространстве имен Microsoft.Office.Interop.Outlook) можно видеть управляемые интерфейсы, имена которых соответствуют объектам в объектной модели Outlook.</span><span class="sxs-lookup"><span data-stu-id="c287a-130">In the object browser, under the namespace Microsoft.Office.Interop.Outlook, you can see managed interfaces that have names corresponding to objects in the Outlook object model.</span></span> <span data-ttu-id="c287a-131">Например, интерфейс Account соответствует объекту **Account** в объектной модели Outlook.</span><span class="sxs-lookup"><span data-stu-id="c287a-131">For example, the Account interface corresponds to the **Account** object in the Outlook object model.</span></span> <span data-ttu-id="c287a-132">При компиляции управляемого проекта эти сведения вносятся в исполняемый файл.</span><span class="sxs-lookup"><span data-stu-id="c287a-132">When you compile the managed project, this information is incorporated in your executable.</span></span>

### <a name="run-time"></a><span data-ttu-id="c287a-133">Время выполнения</span><span class="sxs-lookup"><span data-stu-id="c287a-133">Run time</span></span>

<span data-ttu-id="c287a-p108">Во время выполнения, используя сведения, предоставленные сборкой взаимодействия, среда CLR .NET Framework создает оболочку времени выполнения для каждого компонентного класса, с которым взаимодействует управляемый клиент. Обратите внимание, что среда выполнения создает для каждого компонентного класса только одну оболочку времени выполнения, независимо от количества интерфейсов, полученных клиентом от этого компонентного класса. Оболочка времени выполнения является типом класса .NET Framework, служащим оболочкой компонентного класса COM. Оболочка времени выполнения отслеживает экземпляры компонентного класса и освобождает ссылки на них, только когда клиенту больше не нужна оболочка времени выполнения. Таким образом, управляемому клиенту, в отличие от неуправляемого клиента, не нужно управлять временем жизни объекта COM.</span><span class="sxs-lookup"><span data-stu-id="c287a-p108">At run time, with the information provided by an interop assembly, the .NET Framework CLR creates an RCW for each coclass the managed client interacts with. Note that the runtime creates only one RCW for each coclass, regardless of how many interfaces the client has obtained from the coclass. The RCW is a .NET Framework class type that wraps around the COM coclass. The RCW keeps track of the instances of the coclass and releases references to them only when the client no longer needs the RCW. This way, a managed client does not have to manage the lifetime of an object the way an unmanaged client would under COM.</span></span>

<span data-ttu-id="c287a-p109">На рисунке 2 показано, как во время выполнения оболочка времени выполнения перехватывает вызов API из управляемого клиента и, используя сведения из сборки взаимодействия, прозрачно сопоставляет вызов с соответствующим API в компонентном классе COM. Этот процесс происходит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="c287a-p109">Figure 2 illustrates an RCW intercepting an API call from a managed client at run time, and using information from the interop assembly, transparently mapping the call to the corresponding API in the COM coclass. The following process describes how this happens:</span></span>

1.  <span data-ttu-id="c287a-141">Управляемый клиент вызывает метод A' класса X', как определено в сборке взаимодействия для библиотеки типов COM.</span><span class="sxs-lookup"><span data-stu-id="c287a-141">The managed client calls method A' of class X' as defined in the interop assembly for a COM type library.</span></span>

2.  <span data-ttu-id="c287a-142">Если оболочка времени выполнения для класса X' еще не существует, среда выполнения .NET Framework использует сведения из сборки взаимодействия и создает эту оболочку для класса X'.</span><span class="sxs-lookup"><span data-stu-id="c287a-142">If an RCW does not yet exist for class X', the .NET Framework runtime uses information from the interop assembly and creates an RCW for class X'.</span></span>

3.  <span data-ttu-id="c287a-143">Оболочка времени выполнения перехватывает вызов метода A', преобразует аргументы в соответствующие типы COM и вызывает метод A компонентного класса X, определенного в библиотеке типов COM.</span><span class="sxs-lookup"><span data-stu-id="c287a-143">The RCW intercepts the call to method A', translates the arguments into corresponding COM types, and invokes method A of coclass X as defined in the COM type library.</span></span>

<span data-ttu-id="c287a-144">**Рисунок 2. Вызываемая оболочка времени выполнения перехватывает вызов из управляемого исполняемого файла и сопоставляет его с коклассом в неуправляемой библиотеке типов**</span><span class="sxs-lookup"><span data-stu-id="c287a-144">**Figure 2. An RCW intercepts a call from a managed executable and maps it to a coclass in an unmanaged type library**</span></span>

![Вызываемая оболочка времени выполнения перехватывает вызов из управляемого исполняемого файла и сопоставляет его с коклассом в неуправляемой библиотеке типов](media/pia-unmanaged-type-library-2.gif)
  

## <a name="see-also"></a><span data-ttu-id="c287a-146">См. также</span><span class="sxs-lookup"><span data-stu-id="c287a-146">See also</span></span>

- [<span data-ttu-id="c287a-147">Причины использования Outlook PIA</span><span class="sxs-lookup"><span data-stu-id="c287a-147">Why use the Outlook PIA</span></span>](why-use-the-outlook-pia.md)
- [<span data-ttu-id="c287a-148">Установка и создание ссылок на Outlook PIA</span><span class="sxs-lookup"><span data-stu-id="c287a-148">Installing and referencing the Outlook PIA</span></span>](installing-and-referencing-the-outlook-pia.md)

