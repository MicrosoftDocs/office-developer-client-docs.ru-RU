---
title: Работа с XML-схемами в InfoPath
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
localization_priority: Normal
ms.assetid: c1d70e9f-b9fc-7bdb-107e-d0cd8191607b
description: В шаблоне формы, создаваемом с помощью Microsoft InfoPath, схема XML (XSD) используется для выполнения проверки данных в XML, который представляет вводные, отредактированные и выводные данные из формы InfoPath. Каждый шаблон формы, созданный в конструкторе форм InfoPath, содержит как минимум один файл схемы XSD (XSD), используемый для проверки во время выполнения.
ms.openlocfilehash: 6b19399e4f31f6270fa6f360a8428c725050ce16
ms.sourcegitcommit: 0cf39e5382b8c6f236c8a63c6036849ed3527ded
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/23/2018
ms.locfileid: "22568275"
---
# <a name="working-with-xml-schemas-in-infopath"></a>Работа с XML-схемами в InfoPath

В шаблоне формы, создаваемом с помощью Microsoft InfoPath, схема XML (XSD) используется для выполнения проверки данных в XML, который представляет вводные, отредактированные и выводные данные из формы InfoPath. Каждый шаблон формы, созданный в конструкторе форм InfoPath, содержит как минимум один файл схемы XSD (XSD), используемый для проверки во время выполнения.
  
> [!NOTE]
> Содержащиеся в данной статье сведения предназначены для шаблонов форм, разработанных для использования в редакторе InfoPath. Совместимые с браузером шаблоны форм имеют более строгие требования к схемам XSD. Дополнительные сведения см. в документации о схемах XML в совместимых с браузером шаблонах форм, доступной на веб-сайте MSDN. 
  
## <a name="using-externally-authored-xml-schemas"></a>Использование созданных во внешней среде схем XML

Чтобы загрузить файл схемы XSD, созданный вне приложения InfoPath, выполните следующие действия.
  
### <a name="to-create-a-form-template-based-on-an-external-schema"></a>Создание шаблона формы на основе внешней схемы

1. В Backstage, нажмите **Создать**, щелкните **XML или схему** в разделе **Дополнительные шаблоны форм**, а затем нажмите **Создать форму**.
    
2. В **мастере источника данных**, укажите нужный файл схемы XSD, а затем нажмите кнопку **Далее** и следуйте инструкциям на оставшихся страницах мастера. 
    
## <a name="unsupported-xsd-constructs"></a>Неподдерживаемые конструкции XSD

В следующих разделах описываются конструкции XSD, которые приложение InfoPath не может обрабатывать во время выполнения. Создавая шаблоны форм в конструкторе форм InfoPath, этих конструкций рекомендуется избегать.
  
## <a name="entity-and-entities-types"></a>Типы ENTITY и ENTITIES

Для типов **ENTITY** и **ENTITIES** требуется определение типа документа (DTD), которое не поддерживается в InfoPath. В InfoPath не допускается разработка шаблона формы по такой схеме и выводится сообщение об ошибке с рекомендацией изменить тип **ENTITY** на тип **NCName**, производным которого является **ENTITY**. 
  
> [!NOTE]
>  Если шаблон формы InfoPath создается вручную не в режиме конструктора и в этом шаблоне используется XSD с типами **ENTITY** и **ENTITIES**, шаблон формы может работать во время выполнения в случае, если файл Template.xml содержит необходимый DTD для этих типов. 
  
## <a name="required-xsdany-element"></a>Обязательный элемент "xsd:any"

Экземпляр элемента подстановочного знака **xsd:any**, то есть экземпляр элемента **xsd:any** со значением атрибута **minOccurs** больше нуля ("required any"), запрещает детерминированное создание в InfoPath допустимого экземпляра для данного фрагмента схемы. При генерировании формы, использующей этот фрагмент схемы, в приложении InfoPath должна быть возможность создания допустимого экземпляра. Выполняя действия в **мастере источника данных**, при работе со схемами, имеющими обязательные элементы **xsd:any**, потребуется выбрать элемент схемы, который будет использоваться вместо обязательного элемента **xsd:any**. 
  
## <a name="elements-with-an-abstract-complex-type"></a>Элементы абстрактного сложного типа

Режим конструктора InfoPath поддерживает разработку шаблона формы в схемах, использующих абстрактные сложные типы. Например, если у элемента с именем  `shippingAddress` есть абстрактный сложный тип с именем  `address`, имеющий две производные,   `USAddress` и  `CanadianAddress`  InfoPath принимает любой экземпляр  `shippingAddress` в качестве выбора между  `shippingAddress` с типом  `USAddress` и  `shippingAddress` с типом  `CanadianAddress`. В этом примере, если указанные схемы не содержат типов, производных от адреса, InfoPath запрашивает дополнительную схему, удовлетворяющую данному требованию. 
  
## <a name="xsd-constructs-with-reduced-functionality"></a>Конструкции XSD с ограниченной функциональностью

В следующем разделе описаны конструкции XSD, функциональность которых ограничивается при использовании для создания шаблона формы в конструкторе форм InfoPath.
  
## <a name="substitution-groups"></a>Группы подстановки

Все элементы группы подстановки отображаются в области задач **Поля**. В приложении InfoPath возможности подстановки представлены в виде варианта всех групп подстановки (включая определяющий элемент (если он не является абстрактным)). Если для абстрактного элемента группы подстановки отсутствуют, InfoPath выведет запрос на предоставление схемы, содержащей хотя бы один элемент, который является группой подстановки. 
  
## <a name="unbounded-choice-elements"></a>Неограниченные элементы выбора

В следующем фрагменте схемы представлен неограниченный элемент выбора:
  
```XML
<xsd:choice maxOccurs="unbounded"> 
    <xsd:element name="my_element_1"/> 
    <xsd:element name="my_element_2"/> 
</xsd:choice> 

```

В приложении InfoPath повторяющиеся элементы выбора отображаются в виде повторяющихся вариантов в области задач **Поля**. Элемент управления **Повторяющаяся группа выбора** можно использовать для представления разнородного списка, определенного повторяющимся элементом выбора в XSD. 
  
## <a name="repeating-sequence"></a>Повторяющаяся последовательность

В следующем фрагменте схемы представлена повторяющаяся последовательность:
  
```XML
<xsd:sequence maxOccurs="unbounded"> 
    <xsd:element name="my_element_1"/> 
    <xsd:element name="my_element_2" minOccurs="0"/> 
</xsd:sequence> 

```

До тех пор пока в повторяющейся последовательности будет находиться необходимый элемент, приложение InfoPath будет загружать XSD без изменений, позволяя выполнять привязку элементов управления повторяющегося раздела к повторяющейся последовательности.
  
## <a name="choice-of-model-groups"></a>Выбор групп моделей

В следующем фрагменте схемы представлен элемент выбора, содержащий несколько групп моделей:
  
```XML
<xsd:choice> 
    <xsd:element name="my_element_1"/> 
    <xsd:sequence> 
        <xsd:element name="my_element_2"/> 
        <xsd:element name="my_element_3"/> 
    </xsd:sequence> 
</xsd:choice> 

```

Режим конструктора InfoPath поддерживает такие конструкции XSD без внесения изменений со стороны конструктора форм. Приложение InfoPath не изменяет значение схемы и упрощает указанную выше конструкцию выбора до эквивалентного свернутого одного варианта в области задач **Поля**. 
  
## <a name="optional-sibling-with-same-qualified-name"></a>Необязательный элемент того же уровня с тем же классифицированным именем

В следующем фрагменте схемы представлен необязательный элемент того же уровня с тем же классифицированным именем (`QName`):
  
```xml
<xsd:sequence> 
    <xsd:element name="my_element_1" minOccurs="0"/> 
    <xsd:element name="my_element_2"/> 
            <xsd:element name="my_element_1"/> 
</xsd:sequence> 

```

Выражения **XPath** для этих узлов могут быть сложными, поскольку в конструкторе форм InfoPath необходимо принимать во внимание каждый возможный экземпляр XML. InfoPath не открывает части схемы, для которых создание правильных привязок **XPath** может быть затруднительным. О пропущенных разделах схемы выводятся соответствующие предупреждения. 
  
## <a name="xsd-constructs-with-special-meaning-in-infopath"></a>Конструкции XSD, имеющие особое значение в InfoPath

В следующих разделах описываются конструкции XSD, имеющие особое значение при использовании для создания шаблона формы в режиме конструктора. В этих разделах рассказывается о принципах использования таких конструкций в схемах для активации различных типов поведений.
  
## <a name="adding-new-element-fields-and-groups-with-the-fields-task-pane"></a>Добавление новых полей и групп элементов с помощью области задач "Поля"

Схему можно построить так, чтобы использовать область задач **Поля** для добавления новых полей и групп элементов во время разработки. Для этого элемент в схеме необходимо объявить с помощью дополнительного неограниченного элемента **xsd:any**, который указывает атрибут пространства имен с подстановочным знаком **##any**. Затем в режиме конструктора можно использовать область задач **Поля** для добавления к элементу новых полей и групп. Например, новый контент можно добавить к следующему элементу. 
  
```XML
<xsd:element name="open"> 
    <xsd:complexType> 
         <xsd:sequence> 
             <xsd:any minOccurs="0" maxOccurs="unbounded" namespace="##any"processContents="lax"/> 
         </xsd:sequence> 
    </xsd:complexType> 
</xsd:element> 

```

## <a name="adding-new-attribute-fields-with-the-fields-task-pane"></a>Добавление новых полей атрибута с помощью области задач "Поля"

Так же как и в случае с элементом, разработчик может объявить атрибут с элементом **anyAttribute** с атрибутом пространства имен в виде подстановочного знака **##any**. Во время разработки область задач **Поля** используется для добавления нового контента к этому атрибуту схемы. 
  
```XML
<xsd:element name="open"> 
    <xsd:complexType> 
        <xsd:anyAttribute namespace="##any" processContents="lax"/> 
    </xsd:complexType> 
</xsd:element> 

```

## <a name="storing-xml-signatures-in-the-data-source"></a>Хранение подписей XML в источнике данных

Чтобы пользователи могли во время выполнения ставить на форму цифровую подпись, схема источника данных должна объявить именованную подпись элемента для хранения данных о подписях XML (цифровой подписи), которые создаются при подписывании формы пользователем. Это объявление осуществляется с помощью элемента **xsd:any** с атрибутом пространства имен, указанным в качестве пространства имен подписей XML с подстановочным знаком, а именно: "http://www.w3c.org/2000/09/xmldsig#" 
  
```XML
<xsd:element name="signature"> 
    <xsd:complexType> 
        <xsd:sequence> 
            <xsd:any namespace="http://www.w3c.org/2000/09/xmldsig#"  
             processContents="lax" minOccurs="0" maxOccurs="unbounded"/> 
        <xsd:sequence> 
    </xsd:complexType> 
</xsd:element> 

```

## <a name="binding-a-field-to-a-rich-text-box-control"></a>Привязка поля к элементу управления "Rich Text Box"

 Элементы управления **Rich Text Box** в InfoPath предназначены для создания общих XHTML; следовательно, схема должна указывать, что в XML и экземпляре формы является допустимым любое число узлов текста и XHTML. Для формирования такой спецификации служит следующая конструкция XSD. 
  
```XML
<xsd:element name="xhtml"> 
    <xsd:complexType mixed="true"> 
        <xsd:sequence> 
            <xsd:any minOccurs="0" maxOccurs="unbounded" namespace="http://www.w3.org/1999/xhtml" processContents="lax"/> 
        </xsd:sequence> 
    </xsd:complexType> 
</xsd:element> 

```

> [!NOTE]
> InfoPath никогда не изменяет содержимое файла схемы XSD, но при разработке приложение может логически вывести его подмножество. Файл схемы в рамках шаблона формы никогда не изменяется как во время разработки, так и во время выполнения. 
  
## <a name="debugging-common-xsd-errors"></a>Общие ошибки отладки XSD

Если созданные во внешней среде файлы XSD загружаются для создания шаблонов форм в конструкторе форм InfoPath, возможен вывод следующих типов сообщений об ошибках: сообщения об ошибках MSXML или сообщения об ошибках InfoPath. Сообщения об ошибках MSXML отображаются в разделе **Сведения** диалогового окна сообщения об ошибках InfoPath и всегда начинаются со ссылки на имя пути к файлу схемы, вызвавшему ошибку. В InfoPath поддерживаются лишь некоторые допустимые конструкции схемы XSD; они рассматриваются в разделе "Неподдерживаемые конструкции XSD". В следующих разделах представлено описание общих ошибок, которые могут привести к сбоям загрузки схем в InfoPath. 
  
## <a name="the-xsd-namespace-declaration"></a>Объявление пространства имен XSD

Аналогично всем стандартам W3C схемы XML (XSD) прошли длительный процесс экспертной оценки, прежде чем стать рекомендуемым средством. Существовало множество рабочих проектов и, соответственно, на основе новых устанавливаемых стандартов было создано много XSD-файлов. В ходе этого процесса корпорация Майкрософт разработала специальный язык схемы, XML-Data Reduced (XDR), который был включен в MSXML 3.0. Начиная с выпуска MSXML 4.0 основные службы XML Майкрософт поддерживают полную рекомендацию XSD. Многие программы по созданию схем не использовали XSD до полной рекомендации. В более старых версиях этих программ могут быть созданы устаревшие файлы XSD, не поддерживаемые инфраструктурой MSXML 5.0, от которой зависит InfoPath.
  
Чтобы убедиться, что файл XSD поддерживает полную рекомендацию XSD, он должен содержать в теге \<schema\> следующее объявление пространства имен:
  
```XML
xmlns:xsd="http://www.w3.org/2001/XMLSchema"
```

Подобно всем объявлениям пространства имен XML префиксом XML (в данном случае "XSD") может быть любая допустимая строка префикса. Наиболее распространены префиксы "XSD", "XS" и "" (префикса нет). Если это объявление пространства имен отсутствует, MSXML обычно сообщает об ошибке, связанной с неправильным определением корня.
  
## <a name="importing-and-including-schemas"></a>Импорт и включение схем

Схемы XSD являются расширяемыми и могут импортировать и включать в свой состав другие схемы. Обычно импорт схемы выполняется, если указанная в атрибуте **targetNamespace** схема отличается от текущей схемы. Схему необходимо включить в другую, если указанная в атрибуте **targetNamespace** схема совпадает с текущей. 
  
Семантики импорта и включения схем выглядят следующим образом.
  
```XML
<xsd:import namespace = "[anyURI]" schemaLocation = "[anyURI]"/> 
<xsd:include schemaLocation = "[anyURI]"/> 

```

При отсутствии атрибута **schemaLocation** (так бывает с некоторыми конверторами) MSXML выводит ошибку, поскольку не удается найти файл. При получении подобного сообщения следует проверить, что ресурс или расположение, указанные в атрибуте "schemaLocation", доступны пользователям шаблона формы. Разумеется, ошибки возникают и в случае, когда атрибут **schemaLocation** ссылается на нерабочий или несуществующий сервер или каталог либо если у пользователей нет прав на доступ. Кроме того, нужно проверить допустимость всех импортированных и включенных схем. 
  
> [!NOTE]
> Ошибки, вызванные проблемами с атрибутом **schemaLocation**, представляют сложность только при первом импорте InfoPath схем; то есть при первой разработке формы на основе существующей схемы. После этого InfoPath работает с кэшированными версиями файлов схемы, сохраненных в шаблоне формы. 
  
Использование пустого атрибута пространства имен допускается при импорте схемы, если она не указывает атрибут **targetNamespace**. Обычно пространство имен при импорте должно соответствовать атрибуту **targetNamespace**, указанному в импортируемой схеме. 
  
## <a name="nondeterministic-schemas"></a>Недетерминированные схемы

Инфраструктура MSXML 5.0, от которой зависит приложение InfoPath, может с большой вероятностью выявлять и выводить ошибки для оповещения о недетерминированных схемах, однако в итоговых сообщениях об ошибках не указывается номер строки, определяющий часть схемы, вызвавшую ошибку. В этом разделе рассматриваются вопросы о детерминированности файлов схемы XSD, а также объясняется значение недетерминированности. Здесь представлены и общие ошибки, которых следует избегать.
  
Схемы XSD существуют для проверки структуры данных XML и семантик типов. Для решения этой задачи система проверки (в данном случае MSXML 5.0) должна сопоставить узлы XML объявлениям XSD. Без этого сопоставления проверка не выполняется. Если сопоставление гарантировано, то схема является детерминированной. Если существует один экземпляр XML, делающий сопоставление невозможным, схема является недетерминированной.
  
В следующем примере представлена недетерминированная схема.
  
```XML
<xsd:element name="file_Information"> 
    <xsd:complexType> 
        <xsd:sequence> 
            <xsd:element name="file_name"/> 
            <xsd:choice> 
                <xsd:element name="file_path"/> 
                <xsd:sequence> 
                    <xsd:element name="file_path" minOccurs="0"/> 
                    <xsd:element name="URI"/> 
                </xsd:sequence> 
            </xsd:choice> 
        </xsd:sequence> 
    </xsd:complexType> 
</xsd:element> 

```

Чтобы показать, почему сегмент XSD является недетерминированным, предположим, что имеется следующий фрагмент XML, который нужно проверить с помощью этой схемы.
  
```XML
<file_Information> 
    <file_name>my_Schema.xsd</file_name> 
    <file_path>c:\xsd</file_path> 
</file_Information> 

```

В данном фрагменте XML не ясно, является ли элемент  *\<file_path\>*  необходимым узлом из первой части объявления выбора или дополнительным узлом из второй части объявления выбора. Это различие очень важно по следующим причинам. 
  
1. Если фрагмент XML проверен по первой части объявления выбора, тогда XML считается допустимым в данной схеме.
    
2. Если фрагмент XML проверен по второй части объявления выбора, тогда схема признается недопустимой из-за отсутствия необходимого узла \<URI\>. 
    
Некоторые системы проверки XSD не выдают ошибки при проверке по данной схеме, поскольку существует допустимый путь. MSXML является более жестким и выводит ошибку о недетерминированности схемы.
  
Далее представлено еще несколько примеров недетерминированных схем. В первом рассматриваются дополнительные элементы. Такие ситуации часто возникают с преобразованиями из XDR в XSD и связаны с различиями в заданных по умолчанию учетных данных в двух языках схем. Сначала следует рассмотреть дополнительные элементы, объявленные с помощью элементов **xsd:choice** и **xsd:sequence**. Дополнительные элементы, объявленные в элементе **xsd:sequence**, обычно проходят проверку надлежащим образом до тех пор, пока элементы с одинаковыми именами не будут присутствовать более одного раза и между ними будут находиться только дополнительные элементы. 
  
```XML
<xsd:element name="container"> 
    <xsd:complexType> 
        <xsd:sequence> 
            <xsd:element ref="aNode" /> 
            <xsd:element ref="anotherNode" minOccurs="0"/> 
            <xsd:element ref="aNode" /> 
        </xsd:sequence> 
    </xsd:complexType> 
</xsd:element> 

```

Чтобы понять, почему этот сегмент схемы является недетерминированным, предположим, что имеется следующий недопустимый фрагмент XML.
  
```XML
<container> 
    <aNode/> 
    <aNode/> 
    <anotherNode/> 
</container> 

```

Глядя на этот фрагмент, становится ясна причина его недействительности: перед элементом  `<aNode>` находятся два элемента  `<anotherNode>`, тогда как допускается только один. 
  
Теперь предположим, что нужно проверить следующий экземпляр XML.
  
```XML
<container> 
    <aNode/> 
    <aNode/> 
</container> 

```

Сложность заключается в определении действительности экземпляра. Есть ли два элемента  `<aNode>`, из которых допускается только один, или есть элемент  `<aNode>`, в котором он допускается, и другой, в котором он допускается? Схема является недетерминированной, поскольку узнать ответ невозможно. 
  
Таким же образом использование дополнительных элементов, объявленных в элементе **xsd:choice**, обычно является проблематичным. В следующем упрощенном примере нельзя определить, происходит ли выбор один раз при отсутствии дополнительного элемента либо он не происходит вообще. 
  
```XML
<xsd:choice> 
    <xsd:element name="node" minOccurs="0"/> 
</xsd:choice> 

```

Последний не вызывающий доверия способ заключается в использовании элемента **xsd:any** без определения пространства имен, как в  `<xsd:any namespace="##other"/>`, после элемента **xsd:sequence**. Эта конструкция вносит особые сложности, когда следует за дополнительным элементом. При повторном обращении к предыдущему примеру и изменении последнего узла на элемент **xsd:any** видно, что предыдущие аргументы о недетерминированности по-прежнему применимы, как показано далее. 
  
```XML
<xsd:element name="container"> 
    <xsd:complexType> 
        <xsd:sequence> 
            <xsd:element ref="aNode" /> 
            <xsd:element ref="anotherNode" minOccurs="0"/> 
            <xsd:any />     
        </xsd:sequence> 
    </xsd:complexType> 
</xsd:element> 

```

## <a name="illegal-enumeration-values"></a>Недопустимые значения перечисления

Обычно схемы XSD не выполняют никаких проверок до тех пор, пока не будет проверен фактический документ экземпляра. Исключением является наличие в схеме перечисления. В этом случае схема проверяет значения перечисления по типам перечисления, чтобы гарантировать, что они представляют правильные значения узлов. Далее приведено два примера.
  
```XML
<xsd:simpleType name="showTimes"> 
    <xsd:restriction base="xsd:time"> 
        <xsd:enumeration value="18:30:00"/> 
        <xsd:enumeration value="20:45:00"/> 
        <xsd:enumeration value="eleven o'clock"/> 
    </xsd:restriction> 
</xsd:simpleType> 

```

Эта схема недопустима, поскольку значение "eleven o'clock" не является допустимым для элемента типа **xsd:time**.
  
Далее приведен более сложный пример.
  
```XML
<xsd:simpleType name="concession"> 
    <xsd:restriction base="xsd:NMTOKEN"> 
        <xsd:enumeration value="GummyBears"/> 
        <xsd:enumeration value="SnowCaps"/> 
        <xsd:enumeration value="M&Ms"/> 
    </xsd:restriction> 
</xsd:simpleType> 

```

Чтобы понять причину, по которой этой пример признается недействительным, необходимо разобраться в способе определения типа **xsd:NMTOKEN**. В спецификации типов данных W3C тип **NMTOKEN** определен следующим образом: "NMTOKEN (маркер имени)  это сочетание символов имени." 
  
При дальнейшем изучении становится ясно, что "&" не является допустимым символом имени, и поэтому "M&Ms" не проходит проверку в качестве типа **NMTOKEN**. 
  
## <a name="empty-sequence-or-choice-elements"></a>Пустые элементы последовательности или выбора

Иногда MSXML выдает ошибки об объявлениях схемы, содержащих пустые элементы **xsd:choice** или **xsd:sequence**, как показано в следующем примере. 
  
```XML
<xsd:element name="emptyContainer"> 
    <xsd:complexType> 
        <xsd:choice /> 
    </xsd:complexType> 
</xsd:element> 

```

Для решения проблемы следует удалить пустой тег  `<xsd:choice />`. 
  
## <a name="regular-expressions"></a>Регулярные выражения

В MSXML 5.0 могут возникнуть проблемы, связанные с проверкой загружаемых шаблонов регулярных выражений. Регулярные выражения могут быть сложными, поэтому их нужно использовать с осторожностью. Похоже, каждое средство синтаксического анализа XSD использует гибкий язык регулярных выражений (т. е. официальный язык регулярных выражений XSD с элементами из других подобных языков). Если конструктор форм InfoPath не может проанализировать регулярное выражение, возможно, приложение InfoPath сформировало недопустимые демонстрационные данные либо не сформировало их совсем. Такая ситуация приемлема во время разработки, так как демонстрационные данные в InfoPath используются только для форматирования. Но при использовании регулярного выражения, которое не поддерживается MSXML, в InfoPath не удастся проверить значение при заполнении пользователем формы. В документе [XML Schema. Часть 0: основные сведения (издание второе)](http://www.w3.org/TR/xmlschema-0/) описано, какие регулярные выражения XSD допустимы. Дополнительные сведения о регулярных выражениях XSD и регулярных выражениях уровня 1 Юникода см. в статье о [регулярных выражениях Юникода](http://www.unicode.org/reports/tr18/). 
  
## <a name="targetnamespace-attribute-issues"></a>Проблемы, связанные с атрибутом "targetNamespace"

Файлы XSD интересны тем, что атрибут **targetNamespace** по умолчанию ссылается только на объявления верхнего уровня несмотря на то, что  `attributeFormDefault=qualified` и  `elementFormDefault=qualified` можно задать на переопределение этого заданного по умолчанию поведения. В качестве примера предположим, что в наличии имеется следующий файл XSD. 
  
```XML
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://ns" > 
    <xsd:element name="root"> 
        <xsd:complexType> 
            <xsd:sequence> 
                <xsd:element name="local"/> 
            </xsd:sequence> 
        </xsd:complexType> 
    </xsd:element> 
</xsd:schema> 

```

И далее, документ XML выглядит следующим образом.
  
```XML
<ns:root xmlns:ns="http://ns"> 
    <local/> 
</ns:root> 

```

Поскольку квалификация по умолчанию отключена, для локальных определений не требуется конечное пространство имен. Однако если локальное определение меняется на глобальное, ссылка должна быть снабжена префиксом пространства имен. Например, следующая схема является недопустимой.
  
```XML
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://ns" > 
    <xsd:element name="root"> 
        <xsd:complexType> 
            <xsd:sequence> 
                <xsd:element ref="global"/> 
            </xsd:sequence> 
        </xsd:complexType> 
    </xsd:element> 
 
    <xsd:element name="global"/> 
</xsd:schema> 

```

Эта схема недействительна, поскольку "global" находится в пространстве имен "http://ns". ref="global" не распознается, так как заданное по умолчанию пространство имен отлично от "http://ns". Для устранения этой ошибки необходимо добавить префикс для конечного пространства имен и применять его для всех глобальных ссылок и использований типов. Исправленная схема выглядит следующим образом.
  
```XML
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"  
    xmlns:ns="http://ns" targetNamespace="http://ns" > 
    <xsd:element name="root"> 
        <xsd:complexType> 
            <xsd:sequence> 
                <xsd:element ref="ns:global"/> 
            </xsd:sequence> 
        </xsd:complexType> 
    </xsd:element> 
 
    <xsd:element name="global"/> 
</xsd:schema> 

```

Если в схеме указан атрибут **targetNamespace**, необходимо убедиться, что все глобальные ссылки имеют правильный префикс пространства имен. 
  
## <a name="xml-processing-instruction-encoding-unicode-vs-ansii"></a>Кодировка инструкции обработки XML (Юникод и ANSII)

XML поддерживает только наборы символов в кодировке Юникод. Поэтому при сохранении файлов с символами ANSII данные могут быть потеряны. Сохранение же файлов в кодировке UTF-16 может быть излишним. Чтобы сократить затраты на внедрение средство чтения XML, автор XML-документа должен указать используемую кодировку в инструкции обработки XML. Можно распознать следующую знакомую инструкцию обработки.
  
```XML
xml version="1.0" encoding="UTF-8"
```

Этот тег инструкции обработки указывает, что файл имеет кодировку UTF-8. Необходимо убедиться, что кодировка файла совпадает с кодировкой, определенной в теге инструкции обработки. Чтобы определить кодировку, можно посмотреть на байты файла и найти отметки порядка байт Юникода. Однако есть более простой способ. При возникновении трудностей с открытием схемы XSD нужно выбрать кодировку UTF-8, открыть схему в текстовом редакторе (например, в Блокноте), а затем сохранить файл с помощью кодировки UTF-8 (в Блокноте в диалоговом окне **Сохранить как** есть раскрывающийся список **Кодировка**). Если файл по-прежнему не открывается, проблема не связана с кодировкой. 
  
## <a name="maxoccurs-attribute-inside-the-xsdall-element"></a>Атрибут "maxOccurs" в элементе "xsd:all"

В связи со способом определения недетерминизма в рекомендации для схемы XML единственным допустимым значением для атрибута **maxOccurs** элемента **xsd:element** в элементе **xsd:all** является 1. Например, допустимо следующее. 
  
```XML
<xsd:all> 
    <xsd:element name="x" minOccurs="0"/> 
    <xsd:element name="docs" minOccurs="0"/> 
</xsd:all> 

```

Однако данный пример не является допустимым.
  
```XML
<xsd:all>     
    <xsd:element name="x" minOccurs="0" maxOccurs="unbounded"/> 
    <xsd:element name="docs" minOccurs="0" maxOccurs="unbounded"/> 
</xsd:all> 

```

Этот пример недопустим, поскольку системе проверки не удается определить, соответствуют ли два экземпляра  `<x/>` одному объявлению или же объявлению и другому неправильному определению. На одних и тех же строках не могут находиться два элемента с одинаковым именем в теге  `<xsd:all>`. 
  
Данный пример также интересен тем, что позволяет иметь любое количество узлов  `<x/>` и  `<docs/>`, расположенных в любом порядке внутри содержащего элемента. Несмотря на недопустимость этой структуры, существует обходной метод. Для достижения результата, показанного в следующем примере, можно использовать элемент **xsd:choice**. 
  
```XML
<xsd:choice minOccurs="0" maxOccurs="unbounded"> 
    <xsd:element name="x" /> 
    <xsd:element name="docs" /> 
</xsd:choice> 

```

## <a name="how-to-edit-or-author-an-xsd-for-infopath"></a>Изменение или создание XSD для InfoPath

В следующих разделах приведены два примера по изменению и созданию схемы для вывода в InfoPath определенных результатов.
  
## <a name="allowing-user-defined-elements-to-be-inserted-in-the-fields-task-pane"></a>Вставка определенных пользователем элементов в область задач "Поля"

Чтобы определенные пользователем элементы могли отображаться в рамках родительского элемента в области задач **Поля**, в родительский элемент необходимо вставить элемент **xsd:any**. Чтобы вставлять определенные пользователем элементы в  `<your_node_name>`, объявление XSD должно выглядеть следующим образом. 
  
```XML
<xsd:element name="your_node_name"> 
    <xsd:complexType> 
        <xsd:sequence> 
            <xsd:any namespace="##any | ##other"  
                minOccurs="0" maxOccurs="unbounded"/> 
        </xsd:sequence> 
    </xsd:complexType> 
</xsd:element> 

```

Чтобы разрешить использование определенных пользователями атрибутов, к объявлению элемента необходимо добавить  `<xsd:anyAttribute namespace="##any | ##other"/>`. 
  
## <a name="allowing-rich-text-elements-to-be-bound-in-infopath-design-and-edit-modes"></a>Привязка элементов "Rich Text" в режимах конструктора и правки InfoPath

Если нужно объявить элемент, который можно привязать к элементу управления **Rich Text Box**, он должен иметь следующую форму, содержащую элемент **xsd:any** с атрибутом пространства имен в виде "http://www.w3.org/1999/xhtml", как показано в следующем примере. 
  
```XML
<xsd:element name="your_node_name"> 
    <xsd:complexType mixed="true"> 
        <xsd:sequence> 
            <xsd:any namespace="http://www.w3.org/1999/xhtml"  
                minOccurs="0" maxOccurs="unbounded"/> 
        </xsd:sequence> 
    </xsd:complexType> 
</xsd:element> 

```

## <a name="conclusion"></a>Заключение

Благодаря поддержке InfoPath при разработке форм XML, основанных на созданных во внешней среде файлах схемы XML (XSD), можно создать шаблон формы, работающий с отраслевой или пользовательской схемой, сформированной в организации. Представленные в этой статье сведения полезны при создании файлов настраиваемой схемы XSD, совместимых с InfoPath; кроме того, вы сможете устранить общие неполадки, возникающие при загрузке созданных во внешней среде файлов XSD в среду разработки InfoPath.
  
## <a name="see-also"></a>См. также

- [W3C XML Schema](http://www.w3.org/XML/Schema)
- [XML Schema W3C. Основные сведения](http://www.w3.org/TR/xmlschema-0/)
- [Справочник по структурам XML Schema W3C](https://www.xml.com/pub/a/2000/11/29/schemas/structuresref.html)
- [Справочник по типам данных XML Schema W3C](https://www.xml.com/pub/a/2000/11/29/schemas/dataref.html)
- [Учебное пособие по XML Schema](https://www.w3schools.com/xml/schema_intro.asp)
- [Центр разработчиков XML](http://msdn.microsoft.com/en-us/xml/default.aspx)

